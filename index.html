<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">

    <title>Rust Cheatsheet</title>

    <link rel="stylesheet" type="text/css" href="rustdoc.css">
    <link rel="stylesheet" type="text/css" href="main.css">

    <style type="text/css">
    body {
    }

    .hide {
        display: none;
    }
    .clear_right {
        clear: right;
    }

    span.out-of-band {
        display: none;
    }

    section {
        font-family: Arial, Helvetica, Sans;
        font-size: 1em;

        border: 1px solid black;
        //border-collapse: collapse;
        //display: table;
        width: 20%;
        box-shadow: inset 0px 0px 4px #666;
        padding: 0 0 2px 0;
        float: left;
    }

    section h6 {
        padding: 0px;
        margin: 4px 0px 0px;
        color: rgb(187, 51, 51);
        text-align: center;
        text-decoration: underline;
    }

    section > header {
        font-family: "Nimbus Sans L";
        font-weight: bold;
        text-align: center;
        border-bottom: 1px solid black;
        padding: 3px;
        font-size: 0.8em;
    }
    section > div {
        padding: 0px 8px ;
        clear: right;
    }
    section > div.rarelyused {
        display: none;
        background-color: rgba(0, 0, 0, 0.08) !important;
    }
    section > div.rarelyused:nth-child(even) {
        background-color: rgba(0, 0, 0, 0.10) !important;
    }
    section > div:nth-child(even) {
        background-color: rgba(0, 0, 0, 0.02);
    }
    section > div code {
        white-space: pre;
        font-size: 0.7em;
        font-family: "Nimbus Sans L";
        font-weight: bold;
        line-height: 0.4em;
    }
    a {
        cursor: pointer;
    }
    a:hover {
        text-decoration: underline;
    }
    section > div span {
        color: #ae3a3c;
    }
    section > div details {
        display: block;
        //line-height: 0.4em;
        float: right;
        padding-top: 0.4em;
        font-size: 0.7em;
        color: #555;
        text-align: right;
    }

    section > hr {
        margin: 0px 0px -2px 0px;
        border: 0;
        height: 0;
        border-top: 1px solid rgba(0, 0, 0, 0.3);
        border-bottom: 1px solid rgba(255, 255, 255, 0.3);
        clear: right;

    }

    section p {
        padding: 3px 10px;
        margin: 0;
        font-size: 0.7em;
    }

    section a {
        color: black;
    }

    /* COLORS */
    section.red header {
        background-image: linear-gradient(to right bottom, #E07F7F 0%, #FFAB7A 51%);
    }
    section.red {
        background-color: #f7dcdc;
    }

    section.green header {
        background-image: linear-gradient(to right bottom, #62C958 0%, #BFF2E9 100%);
    }

    section.green {
        background-color: #e3ede1;
    }

    div.unstable code {
        color: #999;
    }

    div.outerdoc {
        display: none;
    }

    div#overlay {
        display: none;
        position: fixed;
        top: 0px;
        bottom: 0px;
        left: 0px;
        right: 0px;
        background-color: rgba(0,0,0,0.5);
    }

    div#overlayclose {
        position: fixed;
        top: 30px;
        left: 50%;
        margin-left: 413px;
        margin-top: 20px;
        font-size: 20px;
        z-index: 20; /* keep on top of other elements on the page */
    }

    div#overlaycontent {
        position: fixed;
        top: 30px;
        left: 50%;
        width: 900px;
        /* line-height: 200px; */
        height: 80%;
        overflow-y: auto;
        margin-left: -450px;
        padding: 20px;
        background-color: #f3f3f3;
        border: 1px solid gray;
        border-radius: 4px;


        /* needed styles for the overlay */
        z-index: 10; /* keep on top of other elements on the page */

    }

    div#overlaycontent {
        display: block !important;
    }

    div#hiddendocs {
        display: none;
    }

    div#search {
        position: fixed;
        top:0;
        left:0;
        right: 0;
        height: 20;
    }
    div#search input {
        margin: 2px;
        padding: 2px;
    }

    body {
        margin-top: 25px;
    }

    </style>
</head>

<body>

<div id="search">
    <input type="text" name="filter" placeholder="Click or press 's' or Ctrl+P to filter, 'Escape' to reset.">
</div>


<section id="vec" class="red filterable">
    <header><a data-doc="vec.vec">Variable sized arrays / Vectors</a></header>
    <div class="" data-tags=""><code><a data-doc="14396203256299453512.new">let mut vec: Vec&lt;T&gt; = Vec::new();</a></code></div><div class="" data-tags=""><code><a data-doc="13635792900886746473.with_capacity">            = Vec::with_capacity();</a></code></div><div class="" data-tags=""><code><a data-doc="vec.initmacro">            = vec![];</a></code></div><div class="rarelyused" data-tags=""><code><a data-doc="16558577108772906117.into_vec">            = boxedarray.into_vec()</a></code></div><div class="" data-tags=""><code><a data-doc="5271361158459940116.from-1">            = Vec::from(slice|</a><a data-doc="17754803654512296803.from-2">str|</a><a data-doc="18039240707993713856.from-3">VecDeque|</a><a data-doc="3406696279324890839.from-4">CString)</a></code></div><div class="" data-tags=""><code><a data-doc="4916098675329940284.clone">            = othervec.clone();</a></code><details>if T:Clone</details></div><hr><hr class="hide"><h6>Accessing</h6><div class="" data-tags=""><code><a data-doc="vec.elementaccess">vec[3];</a></code><details>vec[1..3], vec[..3], vec[3..], vec[..]; vec[2] = a;</details></div><div class="" data-tags=""><code><a data-doc="14477976740090734325.len">vec.len();</a></code></div><div class="" data-tags=""><code><a data-doc="6958581899992355658.is_empty">  .is_empty();</a></code></div><div class="" data-tags=""><code><a data-doc="9679528868003424202.first">  .first</a><a data-doc="7542742795630198630.first_mut"><span>_mut</span>(); </a><a data-doc="17691749592827470290.last">.last</a><a data-doc="3328591669840875117.last_mut"><span>_mut</span>();</a></code><details>-&gt; Option</details></div><div class="" data-tags=""><code><a data-doc="16642943086183077938.get">  .get</a><a data-doc="17453327878799257381.get_mut"><span>_mut</span>(index);</a></code><details>-&gt; Option</details></div><div class="" data-tags=""><code><a data-doc="11285921725179857851.contains">  .contains(needle);</a></code><details>-&gt; bool</details></div><div class="" data-tags="search scan"><code><a data-doc="iter.find">  .iter().find(|&amp;T| -> bool);</a></code><details>-&gt; Option</details></div><div class="" data-tags=""><code><a data-doc="3569276480480410680.binary_search">  .binary_search(x:&amp;T);</a></code><details>-&gt; Result&lt;usize, usize&gt;<br>Ok(i): pos, Err(i): pos for insertion</details></div><div class="rarelyused" data-tags=""><code><a data-doc="7276433757046533657.binary_search_by">  .binary_search_by(|&amp;T|->Ordering);</a></code></div><div class="rarelyused" data-tags=""><code><a data-doc="5332595294186435451.binary_search_by_key">  .binary_search_by_key(Key, |&amp;T|->Key);</a></code></div><div class="rarelyused" data-tags=""><code><a data-doc="5810522196025675113.ends_with">  .ends_with(needle);</a></code></div><div class="rarelyused" data-tags=""><code><a data-doc="8185567739793449126.starts_with">  .starts_with(needle);</a></code></div><hr><hr class="hide"><h6>Adding</h6><div class="" data-tags=""><code><a data-doc="10956568013451006989.push">  .push(3);</a></code><details>to end</details></div><div class="" data-tags=""><code><a data-doc="13726641135499648661.insert">  .insert(index, element);</a></code></div><div class="" data-tags=""><code><a data-doc="15415737837447922280.extend">  .extend(iterable);</a></code></div><div class="" data-tags=""><code><a data-doc="7794087902711693302.extend_from_slice">  .extend_from_slice(&amp;[T]);</a></code></div><div class="" data-tags=""><code><a data-doc="7827139835161839906.append">  .append(other : Vec);</a></code><details>drains other</details></div><div class="rarelyused" data-tags=""><code><a data-doc="14098237708920005647.clone_from">  .clone_from(&amp;Vec&lt;T&gt;);</a></code><details>overrides self, if T:Clone</details></div><div class="rarelyused" data-tags=""><code><a data-doc="13843048056517825852.clone_from_slice">  .clone_from_slice(&amp;[T]);</a></code><details>if T:Clone</details></div><div class="rarelyused" data-tags=""><code><a data-doc="7825918616491699784.copy_from_slice">  .copy_from_slice(&amp;[T]);</a></code><details>if T:Copy (use memcpy)</details></div><hr><hr class="hide"><h6>Removing</h6><div class="" data-tags=""><code><a data-doc="15429091652959684945.pop">  .pop();</a></code><details>removes last -> Option</details></div><div class="" data-tags=""><code><a data-doc="16199108253719120662.remove">  .remove(index);</a></code><details>-&gt; el, shifts left</details></div><div class="" data-tags=""><code><a data-doc="12642351548164574140.swap_remove">  .swap_remove(index);</a></code><details>-&gt; el, fills with last</details></div><div class="rarelyused" data-tags=""><code><a data-doc="6849249452995298128.truncate">  .truncate(i);</a></code><details>cut until .len() = i</details></div><div class="" data-tags=""><code><a data-doc="1290646562429518351.drain">  .drain(range);</a></code><details>-&gt; iter that drains</details></div><div class="" data-tags=""><code><a data-doc="11329643013703854319.clear">  .clear();</a></code></div><div class="" data-tags=""><code><a data-doc="2666466861577946537.retain">  .retain(|i| -&gt; bool);</a></code><details>in place</details></div><div class="rarelyused" data-tags=""><code><a data-doc="18117690145947997800.dedup">  .dedup();</a></code><details>removes duplicates (if T:PartialEq)</details></div><hr><hr class="hide"><h6>Manipulating</h6><div class="" data-tags=""><code><a data-doc="2612716563489981875.sort">  .sort();</a></code><details>in place</details></div><div class="" data-tags=""><code><a data-doc="14823960042327570666.sort_by">  .sort_by(|&amp;T|->Ordering);</a></code><details>in place</details></div><div class="" data-tags=""><code><a data-doc="4540047688751664783.sort_by_key">  .sort_by_key(|&amp;T|->Key);</a></code><details>Key:Ordering</details></div><div class="" data-tags=""><code><a data-doc="15615508082375761141.reverse">  .reverse();</a></code><details>in place</details></div><div class="" data-tags=""><code><a data-doc="4258543473833407574.swap">  .swap(index1, index2);</a></code></div><hr><hr class="hide"><h6>Transforming (Iter, as_, to_)</h6><div class="" data-tags=""><code><a data-doc="9077499134010481492.iter">  .iter</a><a data-doc="1560957081480711333.iter_mut"><span>_mut</span>();</a></code><details><div title="borrows value">-&gt;&<span>mut </span>T, keeps vector</div></details></div><div class="" data-tags=""><code><a data-doc="8015232293810357360.into_iter">  .into_iter();</a></code><details><div title="transfers ownership">-&gt;T, consumes vector</div></details></div><div class="" data-tags=""><code><a data-doc="8115425010145621174.chunks">  .chunks</a><a data-doc="17233738390443499846.chunks_mut"><span>_mut</span>(cnk_sz);</a></code><details>-&gt; iter over a non overlapping slice at a time</details></div><div class="" data-tags=""><code><a data-doc="16694599000034917756.windows">  .windows(wnd_sz);</a></code><details>-&gt; iter over an overlapping slice at a time</details></div><hr><hr class="hide"><div class="rarelyused" data-tags=""><code><a data-doc="17652544619175377718.into_boxed_slice">  .into_boxed_slice();</a></code><details>-&gt; Box&lt;T&gt;</details></div><div class="" data-tags=""><code><a data-doc="18221082805249619336.as_ref">  .as_ref();</a></code><details>-&gt; &amp;[T] or &amp;Vec&lt;T&gt;</details></div><div class="rarelyused" data-tags=""><code><a data-doc="15246699235484841356.to_vec">  .to_vec();</a></code><details>like clone(), if T:Clone</details></div><div class="" data-tags=""><code><a data-doc="5875694794780053927.as_slice">  .as</a><a data-doc="15816123490174700281.as_mut_slice"><span>_mut</span>_slice();</a></code><details>-&gt; &amp;<span>mut</span>[T]</details></div><hr><hr class="hide"><h6>Memory</h6><div class="rarelyused" data-tags=""><code><a data-doc="3574687539512420533.capacity">  .capacity();</a></code></div><div class="" data-tags=""><code><a data-doc="6792948386881586322.reserve">  .reserve(100);</a></code><details>in addition to .len() or more</details></div><div class="" data-tags=""><code><a data-doc="6468945894452751972.reserve_exact">  .reserve_exact(100);</a></code><details>in addition to .len()</details></div><div class="rarelyused" data-tags=""><code><a data-doc="9271989778793293846.shrink_to_fit">  .shrink_to_fit();</a></code></div><hr><hr class="hide"><h6>Split</h6><div class="" data-tags=""><code><a data-doc="5254410224583798498.split_at">  .split_at</a><a data-doc="8923742918456910262.split_at_mut"><span>_mut</span>(mid);</a></code><details>-&gt; (p1, p2), [mid] in 2nd part</details></div><div class="" data-tags=""><code><a data-doc="5012101341679388727.split">  .split</a><a data-doc="163049453469992221.split_mut"><span>_mut</span>(|&amp;T| -&gt; bool);</a></code></div><div class="" data-tags=""><code><a data-doc="2196267873978673785.splitn">  .splitn</a><a data-doc="4387684880198014871.splitn_mut"><span>_mut</span>(n, |&amp;T| -&gt; bool); </a><a data-doc="1686165125513176542.rsplitn">.rsplitn</a><a data-doc="737863001668677903.rsplitn_mut"><span>_mut</span>(_);</a></code><details>-&gt; iter over <span>mutable</span> subslices,<br> seperated by ||-&gt;true, <span>at most n times</span></details></div><div class="" data-tags=""><code><a data-doc="9854561338622172329.split_off">  .split_off(mid);</a></code><details>-&gt; Vec; [mid] in 2nd part</details></div><hr><hr class="hide"><h6>Comparision</h6><div class="rarelyused" data-tags=""><code><a data-doc="7689720323666250363.cmp">  .cmp() </a><a data-doc="6793276335168028715.eq">.eq() </a><a data-doc="4690548007565962405.ne">.ne();</a></code><details>T: PartialEq</details></div><div class="rarelyused" data-tags=""><code><a data-doc="2323966808312194852.lt">  .lt() </a><a data-doc="13372276364791705833.le">.le() </a><a data-doc="14921762095830485457.gt">.gt() </a><a data-doc="14789473908241452967.ge">.ge();</a></code><details>if T:PartialOrd</details></div><hr><hr class="hide"><div class="rarelyused" data-tags=""><code><a data-doc="1757235193742138506.hash">  .hash(state: Hasher)</a></code><details>if T:Hash</details></div><hr><hr class="hide"><h6>Traits</h6><div class="" data-tags=""><a data-doc="15125398731714025335.from"><code>From&lt;BinaryHeap&gt;</code>, </a><a data-doc="12446077907838790974.borrow"><code>Borrow</a><a data-doc="10588675754266479615.borrow_mut"><span>Mut</span></code>, </a><a data-doc="1244055280893109355.clone"><code>Clone </a><a data-doc="13278721116970488004.clone_from"><span>+</span></code>, </a><a data-doc="7669110113239414778.hash"><code>Hash </a><a data-doc="13166171292110904739.hash_slice"><span>+</span></code>, </a><a data-doc="1609730540576136982.index"><code>Index</a><a data-doc="5108033519051641611.index_mut"><span>Mut</span></code>, </a><a data-doc="17781849772444641952.deref"><code>Deref</a><a data-doc="15275472375867915505.deref_mut"><span>Mut</span></code>, </a><a data-doc="trait.FromIterator"><code>FromIterator</code>, </a><a data-doc="trait.IntoIterator"><code>IntoIterator</code>, </a><a data-doc="12925779201927661930.extend"><code>Extend</code>, </a><a data-doc="trait.PartialEq"><code>PartialEq</code>, </a><a data-doc="trait.PartialOrd"><code>PartialOrd</code>, </a><a data-doc="trait.Eq"><code>Eq</code>, </a><a data-doc="trait.Ord"><code>Ord</code>, </a><a data-doc="9968238619283657671.drop"><code>Drop</code>, </a><a data-doc="11544729834252856644.default"><code>Default</code>, </a><a data-doc="4150813030140686537.fmt"><code>Debug (if T:Debug)</code>, </a><a data-doc="12223557033592547113.as_ref"><code>AsRef</code>, </a><a data-doc="11746288218305119104.as_mut"><code>AsMut</code>, </a><a data-doc="1657108870591022558.from-1"><code>From</code>, </a><a data-doc="trait.Write"><code>Write</code></a></div>
</section>



<section id="vec" class="green filterable">
    <header><a data-doc="hm.hm">Hashmaps / Dicts</a></header>
    <div><code>use std::collections::HashMap;</code><details></details></div>
<div class="" data-tags=""><code><a data-doc="3951816119501521738.new">let mut foo: HashMap&lt;K, V&gt; = HashMap::new();</a></code></div><div class="" data-tags=""><code><a data-doc="8191949285084334880.with_capacity">            = HashMap::with_capacity();</a></code><details>K: Eq, Hash</details></div><div class="" data-tags=""><code><a data-doc="hm.clone">            = other.clone();</a></code><details>if V,K:Clone</details></div><hr><hr class="hide"><h6>Access</h6><div class="" data-tags=""><code><a data-doc="hm.index">foo[key];</a></code></div><div class="" data-tags=""><code><a data-doc="16914058508379879378.len">foo.len();</a></code></div><div class="" data-tags=""><code><a data-doc="2561269595886650242.iter">  .iter</a><a data-doc="9387861970427059807.iter_mut"><span>_mut</span>();</a></code><details>-&gt; iter over (&amp;K, &amp;<span>mut </span>V)</details></div><div class="" data-tags=""><code><a data-doc="16911220232665630235.into_iter">  .into_iter();</a></code><details>-&gt; Iter<span>Mut</span></details></div><div class="" data-tags=""><code><a data-doc="17021325784318796058.keys">  .keys();</a></code><details>-&gt; iter over keys</details></div><div class="" data-tags=""><code><a data-doc="4366484008278958505.values">  .values</a><a data-doc="12268253870461834768.values_mut"><span>_mut</span>();</a></code><details>-&gt; iter over values</details></div><div class="" data-tags=""><code><a data-doc="6296352860526464879.is_empty">  .is_empty();</a></code><details>-&gt; bool</details></div><div class="" data-tags=""><code><a data-doc="15256724127138141247.contains_key">  .contains_key(k:Q);</a></code><details>-&gt; bool</details></div><hr><hr class="hide"><h6>Manipulate</h6><div class="" data-tags=""><code><a data-doc="10306206937336477769.get">  .get</a><a data-doc="9241196281296325969.get_mut"><span>_mut</span>(k:&amp;Q);</a></code><details>-&gt; Option&lt;&amp;V&gt;, K:Borrow&lt;Q&gt;</details></div><div class="" data-tags=""><code><a data-doc="8540415240848312525.entry">  .entry(key);</a></code><details>in place manipulation</details></div><div class="" data-tags=""><code><a data-doc="354554368606142782.drain">  .drain();</a></code><details>-&gt; iter that drains</details></div><div class="" data-tags=""><code><a data-doc="12816268798660319156.clear">  .clear();</a></code></div><div class="" data-tags=""><code><a data-doc="hm.extend">  .extend(iter : &lt;Item=(</a><a data-doc="hm.extend-1"><span>&amp;</span>K,<span>&amp;</span>V)&gt;);</a></code></div><div class="" data-tags=""><code><a data-doc="6629847579497595584.insert">  .insert(k,v);</a></code><details>-&gt; Option&lt;&amp;V&gt;, None on success.</details></div><div class="" data-tags=""><code><a data-doc="15986064613564575763.remove">  .remove(k:&amp;Q);</a></code><details>-&gt; Option&lt;&amp;V&gt;</details></div><div class="" data-tags=""><code><a data-doc="13596212680900755199.from_iter">  .from_iter(iter : &lt;Item=(K,V)&gt;);</a></code><details>-&gt; HashMap</details></div><hr><hr class="hide"><h6>Manage</h6><div class="" data-tags=""><code><a data-doc="14837119453722379474.capacity">  .capacity();</a></code></div><div class="" data-tags=""><code><a data-doc="2148307557360492419.reserve">  .reserve(additional);</a></code></div><div class="" data-tags=""><code><a data-doc="12686840722232842188.shrink_to_fit">  .shrink_to_fit();</a></code></div><div class="" data-tags=""><code><a data-doc="hm.clone_from">  .clone_from(source);</a></code><details>overrides self</details></div><hr><hr class="hide"><h6>Comparision</h6><div class="" data-tags=""><code><a data-doc="17744303864984779017.eq">  .eq() </a><a data-doc="1758821620296622440.ne">.ne();</a></code><details>T: PartialEq</details></div><hr><hr class="hide"><h6>Special Hasher</h6><div class="" data-tags=""><code><a data-doc="17291470429843975631.with_hasher">let hm = HashMap::with_hasher(b);</a></code></div><div class="" data-tags=""><code><a data-doc="16546744701173878944.with_capacity_and_hasher">       = HashMap::with_capacity_and_hasher(b);</a></code></div><div class="" data-tags=""><code><a data-doc="4396959748909205563.hasher">hm.hasher(b);</a></code><details>-&gt; &amp;BuildHasher</details></div><hr><hr class="hide"><h6>Traits</h6><div class="" data-tags=""><a data-doc="hm.clone"><code>Clone </a><a data-doc="hm.clone_from"><span>+</span></code>, </a><a data-doc="hm.index"><code>Index</code>, </a><a data-doc="trait.FromIterator"><code>FromIterator</code>, </a><a data-doc="trait.IntoIterator"><code>IntoIterator</code>, </a><a data-doc="hm.extend"><code>Extend </a><a data-doc="hm.extend-1"><span>+</span></code>, </a><a data-doc="trait.PartialEq"><code>PartialEq</code>, </a><a data-doc="trait.Eq"><code>Eq</code>, </a><a data-doc="4451132110321701077.default"><code>Default</code>, </a><a data-doc="7316208468755632574.fmt"><code>Debug (if K,V:Debug)</code></a></div>
</section>

<section id="vec" class="green filterable">
    <header><a data-doc="option.option">Option</a></header>
    <div class="" data-tags=""><code>let foo : Option<T> = Some(T::new());</code></div><div class="" data-tags=""><code>                           = None;</code></div><hr><hr class="hide"><h6>If</h6><div class="" data-tags=""><code><a data-doc="6504451597404164306.is_some">  .is_some();</a></code></div><div class="" data-tags=""><code><a data-doc="17353264871639778283.is_none">  .is_none();</a></code><details></details></div><hr><hr class="hide"><h6>&amp;</h6><div class="" data-tags=""><code><a data-doc="15207913341984443606.as_ref">  .as_ref();</a></code><details>-&gt; Option&lt;&amp;T&gt;</details></div><div class="" data-tags=""><code><a data-doc="5691384552386697087.as_mut">  .as_mut();</a></code><details>-&gt; Option&lt;&amp;mut T&gt;</details></div><div class="" data-tags=""><code><a data-doc="9288462660437931993.cloned">  .cloned();</a></code><details>Option&lt;&T&gt; -&gt; Option&lt;T&gt; if T:Clone</details></div><div class="" data-tags=""><code><a data-doc="14666763506234159559.iter">  .iter</a><a data-doc="6394198856654040359.iter_mut"><span>_mut</span>();</a></code><details>Iter with 1 or 0 elements</details></div><hr><hr class="hide"><h6>Retrieve T</h6><div class="" data-tags=""><code><a data-doc="16432270654953061313.unwrap">  .unwrap();</a></code><details>-&gt; T or panic</details></div><div class="" data-tags=""><code><a data-doc="11274258317012853528.expect">  .expect(msg);</a></code><details>-&gt; T or panic(msg)</details></div><div class="" data-tags=""><code><a data-doc="11805277003619008830.unwrap_or">  .unwrap_or(default:T);</a></code><details>-&gt; T</details></div><div class="" data-tags=""><code><a data-doc="1533701075291881512.unwrap_or_default">  .unwrap_or_default();</a></code><details>-&gt; T, if T:Default</details></div><div class="" data-tags=""><code><a data-doc="16689666266530795931.unwrap_or_else">  .unwrap_or_else(|| -&gt; T);</a></code><details>-&gt; T</details></div><div class="" data-tags=""><code><a data-doc="1313084959026557620.take">mutableopt.take();</a></code><details>-&gt; Option&lt;T&gt;, moves T out of mutableopt</details></div><hr><hr class="hide"><h6>Manipulate (map)</h6><div class="" data-tags=""><code><a data-doc="12319667499590152877.map">  .map(|t| -&gt; U);</a></code><details>-> Option&lt;U&gt;</details></div><div class="" data-tags=""><code><a data-doc="8971424463067818034.map_or">  .map_or(default:U, |t| -&gt; U);</a></code><details>-> Option&lt;U&gt;</details></div><div class="" data-tags=""><code><a data-doc="11863433451634880378.map_or_else">  .map_or_else(|| default -&gt; U, |t| -&gt; U);</a></code><details>-> Option&lt;U&gt;</details></div><hr><hr class="hide"><h6>to Result<></h6><div class="" data-tags=""><code><a data-doc="8333859018885568806.ok_or">  .ok_or(err:E);</a></code><details>-> Result&lt;T,E&gt;</details></div><div class="" data-tags=""><code><a data-doc="5114918529540926804.ok_or_else">  .ok_or_else(|| err -&gt; E);</a></code><details>-> Result&lt;T,E&gt;</details></div><hr><hr class="hide"><h6>Boolean Combinations</h6><div class="" data-tags=""><code><a data-doc="1876176474297165977.and"> a.and(b : Option&ltU&gt;);</a></code><details>b if a && b</details></div><div class="" data-tags=""><code><a data-doc="1066401321214794057.and_then"> a.and_then(|| b -&gt; Option&lt;U&gt;);</a></code><details>b if a && b</details></div><div class="" data-tags=""><code><a data-doc="3832898963387606678.or"> a.or(b : Option&ltT&gt;);</a></code><details>a if a else b</details></div><div class="" data-tags=""><code><a data-doc="18116111635374583314.or_else"> a.or_else(|| b -&gt; Option&lt;T&gt;);</a></code><details>a if a else b</details></div><hr><hr class="hide"><h6>Traits</h6><div class="" data-tags=""><code><a data-doc="trait.Hash">Hash</a></code> <code><a data-doc="389856273934873617.hash"><span>+</span></a></code> <code><a data-doc="4574392842334917395.hash_slice"><span>+,</span></a></code> <code><a data-doc="trait.Debug">Debug</a></code> <code><a data-doc="13199671331023959611.fmt"><span>fmt() |</span></a></code> <code><a data-doc="trait.Ord">Ord</a></code> <code><a data-doc="17866902328306906809.cmp"><span>cmp() |</span></a></code> <code><a data-doc="trait.Eq">Eq |</a></code> <code><a data-doc="trait.PartialOrd">PartialOrd</a></code> <code><a data-doc="18296562665875618520.partial_cmp"><span>partial_cmp()</span></a></code> <code><a data-doc="14430656552780856558.lt"><span>lt()</span></a></code> <code><a data-doc="15542999645070279494.le"><span>le()</span></a></code> <code><a data-doc="7219544018863720640.gt"><span>gt()</span></a></code> <code><a data-doc="17725730971198962671.ge"><span>ge() |</span></a></code> <code><a data-doc="trait.PartialEq">PartialEq</a></code> <code><a data-doc="1472516741008242409.eq"><span>eq()</span></a></code> <code><a data-doc="4065647751515692205.ne"><span>ne() |</span></a></code> <code><a data-doc="trait.Copy">Copy |</a></code> <code><a data-doc="trait.Clone">Clone</a></code> <code><a data-doc="10975458318622769309.clone"><span>clone()</span></a></code> <code><a data-doc="2331504072263541851.clone_from"><span>clone_from(src) |</span></a></code> <code><a data-doc="trait.Default">Default</a></code> <code><a data-doc="11680357678959509649.default"><span>default() |</span></a></code> <code><a data-doc="trait.IntoIterator">IntoIterator</a></code> <code><a data-doc="1227242874701021233.into_iter"><span>into_iter() |</span></a></code> <code><a data-doc="trait.FromIterator">FromIterator</a></code> <code><a data-doc="17860051281235821222.from_iter"><span>from_iter()</span></a></code> <code></code></div>
</section>





<section class="next_row">
<header>Rust Cheatsheet</header>
<p>Contribute at <a href="http://github.com/phaiax/rust-cheatsheet">github.com/phaiax/rust-cheatsheet</a></p>
<div><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a>
<details>This work is licensed under a<br> <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-<br>ShareAlike 4.0 International License</a>.</details>
</div>
<div class="clear_right"></div>
</section>

<div id="hiddendocs">
<div class="outerdoc" id="vec.vec"><div class="docblock" id="vec.vec"><p>A contiguous growable array type, written <code>Vec&lt;T&gt;</code> but pronounced 'vector.'</p>

<h1 class="section-header" id="examples"><a href="#examples">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut vec = Vec::new();
vec.push(1);
vec.push(2);

assert_eq!(vec.len(), 2);
assert_eq!(vec[0], 1);

assert_eq!(vec.pop(), Some(2));
assert_eq!(vec.len(), 1);

vec[0] = 7;
assert_eq!(vec[0], 7);

vec.extend([1, 2, 3].iter().cloned());

for x in &amp;vec {
    println!("{}", x);
}
assert_eq!(vec, [7, 1, 2, 3]);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">new</span>();
<span class="ident">vec</span>.<span class="ident">push</span>(<span class="number">1</span>);
<span class="ident">vec</span>.<span class="ident">push</span>(<span class="number">2</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>.<span class="ident">len</span>(), <span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>[<span class="number">0</span>], <span class="number">1</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>.<span class="ident">pop</span>(), <span class="prelude-val">Some</span>(<span class="number">2</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>.<span class="ident">len</span>(), <span class="number">1</span>);

<span class="ident">vec</span>[<span class="number">0</span>] <span class="op">=</span> <span class="number">7</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>[<span class="number">0</span>], <span class="number">7</span>);

<span class="ident">vec</span>.<span class="ident">extend</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="ident">iter</span>().<span class="ident">cloned</span>());

<span class="kw">for</span> <span class="ident">x</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">vec</span> {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">"{}"</span>, <span class="ident">x</span>);
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>, [<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</pre>

<p>The <code>vec!</code> macro is provided to make initialization more convenient:</p>

<span class="rusttest">fn main() {
    let mut vec = vec![1, 2, 3];
vec.push(4);
assert_eq!(vec, [1, 2, 3, 4]);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="ident">vec</span>.<span class="ident">push</span>(<span class="number">4</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</pre>

<p>It can also initialize each element of a <code>Vec&lt;T&gt;</code> with a given value:</p>

<span class="rusttest">fn main() {
    let vec = vec![0; 5];
assert_eq!(vec, [0, 0, 0, 0, 0]);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>; <span class="number">5</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>, [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]);</pre>

<p>Use a <code>Vec&lt;T&gt;</code> as an efficient stack:</p>

<span class="rusttest">fn main() {
    let mut stack = Vec::new();

stack.push(1);
stack.push(2);
stack.push(3);

while let Some(top) = stack.pop() {
    // Prints 3, 2, 1
    println!("{}", top);
}
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">stack</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">new</span>();

<span class="ident">stack</span>.<span class="ident">push</span>(<span class="number">1</span>);
<span class="ident">stack</span>.<span class="ident">push</span>(<span class="number">2</span>);
<span class="ident">stack</span>.<span class="ident">push</span>(<span class="number">3</span>);

<span class="kw">while</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">top</span>) <span class="op">=</span> <span class="ident">stack</span>.<span class="ident">pop</span>() {
    <span class="comment">// Prints 3, 2, 1</span>
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">"{}"</span>, <span class="ident">top</span>);
}</pre>

<h1 class="section-header" id="indexing"><a href="#indexing">Indexing</a></h1>
<p>The Vec type allows to access values by index, because it implements the
<code>Index</code> trait. An example will be more explicit:</p>

<span class="rusttest">fn main() {
    let v = vec!(0, 2, 4, 6);
println!("{}", v[1]); // it will display '2'
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>);
<span class="macro">println</span><span class="macro">!</span>(<span class="string">"{}"</span>, <span class="ident">v</span>[<span class="number">1</span>]); <span class="comment">// it will display '2'</span></pre>

<p>However be careful: if you try to access an index which isn't in the Vec,
your software will panic! You cannot do this:</p>

<span class="rusttest">fn main() {
    let v = vec!(0, 2, 4, 6);
println!("{}", v[6]); // it will panic!
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>);
<span class="macro">println</span><span class="macro">!</span>(<span class="string">"{}"</span>, <span class="ident">v</span>[<span class="number">6</span>]); <span class="comment">// it will panic!</span></pre>

<p>In conclusion: always check if the index you want to get really exists
before doing it.</p>

<h1 class="section-header" id="slicing"><a href="#slicing">Slicing</a></h1>
<p>A Vec can be mutable. Slices, on the other hand, are read-only objects.
To get a slice, use "&amp;". Example:</p>

<span class="rusttest">fn main() {
    fn read_slice(slice: &amp;[usize]) {
    // ...
}

let v = vec!(0, 1);
read_slice(&amp;v);

// ... and that's all!
// you can also do it like this:
let x : &amp;[usize] = &amp;v;
}</span><pre class="rust rust-example-rendered"><span class="kw">fn</span> <span class="ident">read_slice</span>(<span class="ident">slice</span>: <span class="kw-2">&amp;</span>[<span class="ident">usize</span>]) {
    <span class="comment">// ...</span>
}

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>(<span class="number">0</span>, <span class="number">1</span>);
<span class="ident">read_slice</span>(<span class="kw-2">&amp;</span><span class="ident">v</span>);

<span class="comment">// ... and that's all!</span>
<span class="comment">// you can also do it like this:</span>
<span class="kw">let</span> <span class="ident">x</span> : <span class="kw-2">&amp;</span>[<span class="ident">usize</span>] <span class="op">=</span> <span class="kw-2">&amp;</span><span class="ident">v</span>;</pre>

<p>In Rust, it's more common to pass slices as arguments rather than vectors
when you just want to provide a read access. The same goes for String and
&amp;str.</p>

<h1 class="section-header" id="capacity-and-reallocation"><a href="#capacity-and-reallocation">Capacity and reallocation</a></h1>
<p>The capacity of a vector is the amount of space allocated for any future
elements that will be added onto the vector. This is not to be confused with
the <em>length</em> of a vector, which specifies the number of actual elements
within the vector. If a vector's length exceeds its capacity, its capacity
will automatically be increased, but its elements will have to be
reallocated.</p>

<p>For example, a vector with capacity 10 and length 0 would be an empty vector
with space for 10 more elements. Pushing 10 or fewer elements onto the
vector will not change its capacity or cause reallocation to occur. However,
if the vector's length is increased to 11, it will have to reallocate, which
can be slow. For this reason, it is recommended to use <code>Vec::with_capacity</code>
whenever possible to specify how big the vector is expected to get.</p>

<h1 class="section-header" id="guarantees"><a href="#guarantees">Guarantees</a></h1>
<p>Due to its incredibly fundamental nature, Vec makes a lot of guarantees
about its design. This ensures that it's as low-overhead as possible in
the general case, and can be correctly manipulated in primitive ways
by unsafe code. Note that these guarantees refer to an unqualified <code>Vec&lt;T&gt;</code>.
If additional type parameters are added (e.g. to support custom allocators),
overriding their defaults may change the behavior.</p>

<p>Most fundamentally, Vec is and always will be a (pointer, capacity, length)
triplet. No more, no less. The order of these fields is completely
unspecified, and you should use the appropriate methods to modify these.
The pointer will never be null, so this type is null-pointer-optimized.</p>

<p>However, the pointer may not actually point to allocated memory. In particular,
if you construct a Vec with capacity 0 via <code>Vec::new()</code>, <code>vec![]</code>,
<code>Vec::with_capacity(0)</code>, or by calling <code>shrink_to_fit()</code> on an empty Vec, it
will not allocate memory. Similarly, if you store zero-sized types inside
a Vec, it will not allocate space for them. <em>Note that in this case the
Vec may not report a <code>capacity()</code> of 0</em>. Vec will allocate if and only
if <code>mem::size_of::&lt;T&gt;() * capacity() &gt; 0</code>. In general, Vec's allocation
details are subtle enough that it is strongly recommended that you only
free memory allocated by a Vec by creating a new Vec and dropping it.</p>

<p>If a Vec <em>has</em> allocated memory, then the memory it points to is on the heap
(as defined by the allocator Rust is configured to use by default), and its
pointer points to <code>len()</code> initialized elements in order (what you would see
if you coerced it to a slice), followed by <code>capacity() - len()</code> logically
uninitialized elements.</p>

<p>Vec will never perform a "small optimization" where elements are actually
stored on the stack for two reasons:</p>

<ul>
<li><p>It would make it more difficult for unsafe code to correctly manipulate
a Vec. The contents of a Vec wouldn't have a stable address if it were
only moved, and it would be more difficult to determine if a Vec had
actually allocated memory.</p></li>
<li><p>It would penalize the general case, incurring an additional branch
on every access.</p></li>
</ul>

<p>Vec will never automatically shrink itself, even if completely empty. This
ensures no unnecessary allocations or deallocations occur. Emptying a Vec
and then filling it back up to the same <code>len()</code> should incur no calls to
the allocator. If you wish to free up unused memory, use <code>shrink_to_fit</code>.</p>

<p><code>push</code> and <code>insert</code> will never (re)allocate if the reported capacity is
sufficient. <code>push</code> and <code>insert</code> <em>will</em> (re)allocate if <code>len() == capacity()</code>.
That is, the reported capacity is completely accurate, and can be relied on.
It can even be used to manually free the memory allocated by a Vec if
desired. Bulk insertion methods <em>may</em> reallocate, even when not necessary.</p>

<p>Vec does not guarantee any particular growth strategy when reallocating
when full, nor when <code>reserve</code> is called. The current strategy is basic
and it may prove desirable to use a non-constant growth factor. Whatever
strategy is used will of course guarantee <code>O(1)</code> amortized <code>push</code>.</p>

<p><code>vec![x; n]</code>, <code>vec![a, b, c, d]</code>, and <code>Vec::with_capacity(n)</code>, will all
produce a Vec with exactly the requested capacity. If <code>len() == capacity()</code>,
(as is the case for the <code>vec!</code> macro), then a <code>Vec&lt;T&gt;</code> can be converted
to and from a <code>Box&lt;[T]&gt;</code> without reallocating or moving the elements.</p>

<p>Vec will not specifically overwrite any data that is removed from it,
but also won't specifically preserve it. Its uninitialized memory is
scratch space that it may use however it wants. It will generally just do
whatever is most efficient or otherwise easy to implement. Do not rely on
removed data to be erased for security purposes. Even if you drop a Vec, its
buffer may simply be reused by another Vec. Even if you zero a Vec's memory
first, that may not actually happen because the optimizer does not consider
this a side-effect that must be preserved.</p>

<p>Vec does not currently guarantee the order in which elements are dropped
(the order has changed in the past, and may change again).</p>
</div></div><div class="outerdoc" id="14396203256299453512.new"><h4 class="method" id="method.new"><code>fn <a class="fnname" href="#method.new">new</a>() -&gt; <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;</code></h4><div class="docblock"><p>Constructs a new, empty <code>Vec&lt;T&gt;</code>.</p>

<p>The vector will not allocate until elements are pushed onto it.</p>

<h1 class="section-header" id="examples-1"><a href="#examples-1">Examples</a></h1>
<span class="rusttest">fn main() {
    #![allow(unused_mut)]
let mut vec: Vec&lt;i32&gt; = Vec::new();
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">new</span>();</pre>
</div></div><div class="outerdoc" id="13635792900886746473.with_capacity"><h4 class="method" id="method.with_capacity"><code>fn <a class="fnname" href="#method.with_capacity">with_capacity</a>(capacity: <a class="primitive" href="../primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;</code></h4><div class="docblock"><p>Constructs a new, empty <code>Vec&lt;T&gt;</code> with the specified capacity.</p>

<p>The vector will be able to hold exactly <code>capacity</code> elements without
reallocating. If <code>capacity</code> is 0, the vector will not allocate.</p>

<p>It is important to note that this function does not specify the <em>length</em>
of the returned vector, but only the <em>capacity</em>. (For an explanation of
the difference between length and capacity, see the main <code>Vec&lt;T&gt;</code> docs
above, 'Capacity and reallocation'.)</p>

<h1 class="section-header" id="examples-2"><a href="#examples-2">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut vec = Vec::with_capacity(10);

// The vector contains no items, even though it has capacity for more
assert_eq!(vec.len(), 0);

// These are all done without reallocating...
for i in 0..10 {
    vec.push(i);
}

// ...but this may make the vector reallocate
vec.push(11);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">with_capacity</span>(<span class="number">10</span>);

<span class="comment">// The vector contains no items, even though it has capacity for more</span>
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>.<span class="ident">len</span>(), <span class="number">0</span>);

<span class="comment">// These are all done without reallocating...</span>
<span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="number">10</span> {
    <span class="ident">vec</span>.<span class="ident">push</span>(<span class="ident">i</span>);
}

<span class="comment">// ...but this may make the vector reallocate</span>
<span class="ident">vec</span>.<span class="ident">push</span>(<span class="number">11</span>);</pre>
</div></div><div class="outerdoc" id="16558577108772906117.into_vec"><h4 class="method" id="method.into_vec"><code>fn <a class="fnname" href="#method.into_vec">into_vec</a>(self: <a class="struct" href="../../std/boxed/struct.Box.html" title="std::boxed::Box">Box</a>&lt;<a class="primitive" href="../primitive.slice.html">[</a>T<a class="primitive" href="../primitive.slice.html">]</a>&gt;) -&gt; <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;</code></h4><div class="docblock"><p>Converts <code>self</code> into a vector without clones or allocation.</p>
</div></div><div class="outerdoc" id="5271361158459940116.from-1"><h4 class="method" id="method.from-1"><code>fn <a class="fnname" href="../../std/convert/trait.From.html#tymethod.from">from</a>(s: <a class="primitive" href="../primitive.slice.html">&amp;'a [T]</a>) -&gt; <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;</code></h4><div class="docblock"><p>Performs the conversion.</p>
</div></div><div class="outerdoc" id="17754803654512296803.from-2"><h4 class="method" id="method.from-2"><code>fn <a class="fnname" href="../../std/convert/trait.From.html#tymethod.from">from</a>(s: &amp;'a <a class="primitive" href="../primitive.str.html">str</a>) -&gt; <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;<a class="primitive" href="../primitive.u8.html">u8</a>&gt;</code></h4><div class="docblock"><p>Performs the conversion.</p>
</div></div><div class="outerdoc" id="18039240707993713856.from-3"><h4 class="method" id="method.from-3"><code>fn <a class="fnname" href="../../std/convert/trait.From.html#tymethod.from">from</a>(other: <a class="struct" href="../../std/collections/vec_deque/struct.VecDeque.html" title="std::collections::vec_deque::VecDeque">VecDeque</a>&lt;T&gt;) -&gt; <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;</code></h4><div class="docblock"><p>Performs the conversion.</p>
</div></div><div class="outerdoc" id="3406696279324890839.from-4"><h4 class="method" id="method.from-4"><code>fn <a class="fnname" href="../../std/convert/trait.From.html#tymethod.from">from</a>(s: <a class="struct" href="../../std/ffi/struct.CString.html" title="std::ffi::CString">CString</a>) -&gt; <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;<a class="primitive" href="../primitive.u8.html">u8</a>&gt;</code></h4><div class="docblock"><p>Performs the conversion.</p>
</div></div><div class="outerdoc" id="4916098675329940284.clone"><h4 class="method" id="method.clone"><code>fn <a class="fnname" href="../../std/clone/trait.Clone.html#tymethod.clone">clone</a>(&amp;self) -&gt; <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;</code></h4><div class="docblock"><p>Returns a copy of the value. <a href="../../std/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div></div><div class="outerdoc" id="vec.elementaccess"><div class="docblock" id="vec.elementaccess"><h1 class="section-header" id="indexing"><a href="#indexing">Indexing</a></h1><p>The Vec type allows to access values by index, because it implements the
<code>Index</code> trait. An example will be more explicit:</p><span class="rusttest">fn main() {
    let v = vec!(0, 2, 4, 6);
println!("{}", v[1]); // it will display '2'
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>);
<span class="macro">println</span><span class="macro">!</span>(<span class="string">"{}"</span>, <span class="ident">v</span>[<span class="number">1</span>]); <span class="comment">// it will display '2'</span></pre><p>However be careful: if you try to access an index which isn't in the Vec,
your software will panic! You cannot do this:</p><span class="rusttest">fn main() {
    let v = vec!(0, 2, 4, 6);
println!("{}", v[6]); // it will panic!
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>);
<span class="macro">println</span><span class="macro">!</span>(<span class="string">"{}"</span>, <span class="ident">v</span>[<span class="number">6</span>]); <span class="comment">// it will panic!</span></pre><p>In conclusion: always check if the index you want to get really exists
before doing it.</p></div></div><div class="outerdoc" id="14477976740090734325.len"><h4 class="method" id="method.len"><code>fn <a class="fnname" href="#method.len">len</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.usize.html">usize</a></code></h4><div class="docblock"><p>Returns the number of elements in the vector.</p>

<h1 class="section-header" id="examples-19"><a href="#examples-19">Examples</a></h1>
<span class="rusttest">fn main() {
    let a = vec![1, 2, 3];
assert_eq!(a.len(), 3);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">len</span>(), <span class="number">3</span>);</pre>
</div></div><div class="outerdoc" id="6958581899992355658.is_empty"><h4 class="method" id="method.is_empty"><code>fn <a class="fnname" href="#method.is_empty">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h4><div class="docblock"><p>Returns <code>true</code> if the vector contains no elements.</p>

<h1 class="section-header" id="examples-20"><a href="#examples-20">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut v = Vec::new();
assert!(v.is_empty());

v.push(1);
assert!(!v.is_empty());
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">new</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">is_empty</span>());

<span class="ident">v</span>.<span class="ident">push</span>(<span class="number">1</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">v</span>.<span class="ident">is_empty</span>());</pre>
</div></div><div class="outerdoc" id="9679528868003424202.first"><h4 class="method" id="method.first"><code>fn <a class="fnname" href="#method.first">first</a>(&amp;self) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;&amp;T&gt;</code></h4><div class="docblock"><p>Returns the first element of a slice, or <code>None</code> if it is empty.</p>

<h1 class="section-header" id="examples-25"><a href="#examples-25">Examples</a></h1>
<span class="rusttest">fn main() {
    let v = [10, 40, 30];
assert_eq!(Some(&amp;10), v.first());

let w: &amp;[i32] = &amp;[];
assert_eq!(None, w.first());
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">10</span>), <span class="ident">v</span>.<span class="ident">first</span>());

<span class="kw">let</span> <span class="ident">w</span>: <span class="kw-2">&amp;</span>[<span class="ident">i32</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">w</span>.<span class="ident">first</span>());</pre>
</div></div><div class="outerdoc" id="7542742795630198630.first_mut"><h4 class="method" id="method.first_mut"><code>fn <a class="fnname" href="#method.first_mut">first_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;&amp;mut T&gt;</code></h4><div class="docblock"><p>Returns a mutable pointer to the first element of a slice, or <code>None</code> if it is empty</p>
</div></div><div class="outerdoc" id="17691749592827470290.last"><h4 class="method" id="method.last"><code>fn <a class="fnname" href="#method.last">last</a>(&amp;self) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;&amp;T&gt;</code></h4><div class="docblock"><p>Returns the last element of a slice, or <code>None</code> if it is empty.</p>

<h1 class="section-header" id="examples-26"><a href="#examples-26">Examples</a></h1>
<span class="rusttest">fn main() {
    let v = [10, 40, 30];
assert_eq!(Some(&amp;30), v.last());

let w: &amp;[i32] = &amp;[];
assert_eq!(None, w.last());
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">30</span>), <span class="ident">v</span>.<span class="ident">last</span>());

<span class="kw">let</span> <span class="ident">w</span>: <span class="kw-2">&amp;</span>[<span class="ident">i32</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">w</span>.<span class="ident">last</span>());</pre>
</div></div><div class="outerdoc" id="3328591669840875117.last_mut"><h4 class="method" id="method.last_mut"><code>fn <a class="fnname" href="#method.last_mut">last_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;&amp;mut T&gt;</code></h4><div class="docblock"><p>Returns a mutable pointer to the last item in the slice.</p>
</div></div><div class="outerdoc" id="16642943086183077938.get"><h4 class="method" id="method.get"><code>fn <a class="fnname" href="#method.get">get</a>(&amp;self, index: <a class="primitive" href="../primitive.usize.html">usize</a>) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;&amp;T&gt;</code></h4><div class="docblock"><p>Returns the element of a slice at the given index, or <code>None</code> if the
index is out of bounds.</p>

<h1 class="section-header" id="examples-27"><a href="#examples-27">Examples</a></h1>
<span class="rusttest">fn main() {
    let v = [10, 40, 30];
assert_eq!(Some(&amp;40), v.get(1));
assert_eq!(None, v.get(3));
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">40</span>), <span class="ident">v</span>.<span class="ident">get</span>(<span class="number">1</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">v</span>.<span class="ident">get</span>(<span class="number">3</span>));</pre>
</div></div><div class="outerdoc" id="17453327878799257381.get_mut"><h4 class="method" id="method.get_mut"><code>fn <a class="fnname" href="#method.get_mut">get_mut</a>(&amp;mut self, index: <a class="primitive" href="../primitive.usize.html">usize</a>) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;&amp;mut T&gt;</code></h4><div class="docblock"><p>Returns a mutable reference to the element at the given index,
or <code>None</code> if the index is out of bounds</p>
</div></div><div class="outerdoc" id="11285921725179857851.contains"><h4 class="method" id="method.contains"><code>fn <a class="fnname" href="#method.contains">contains</a>(&amp;self, x: &amp;T) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;T&gt;</span></code></h4><div class="docblock"><p>Returns true if the slice contains an element with the given value.</p>

<h1 class="section-header" id="examples-32"><a href="#examples-32">Examples</a></h1>
<span class="rusttest">fn main() {
    let v = [10, 40, 30];
assert!(v.contains(&amp;30));
assert!(!v.contains(&amp;50));
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="number">30</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">v</span>.<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="number">50</span>));</pre>
</div></div><div class="outerdoc" id="3569276480480410680.binary_search"><h4 class="method" id="method.binary_search"><code>fn <a class="fnname" href="#method.binary_search">binary_search</a>(&amp;self, x: &amp;T) -&gt; <a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;<a class="primitive" href="../primitive.usize.html">usize</a>, <a class="primitive" href="../primitive.usize.html">usize</a>&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></h4><div class="docblock"><p>Binary search a sorted slice for a given element.</p>

<p>If the value is found then <code>Ok</code> is returned, containing the
index of the matching element; if the value is not found then
<code>Err</code> is returned, containing the index where a matching
element could be inserted while maintaining sorted order.</p>

<h1 class="section-header" id="example-7"><a href="#example-7">Example</a></h1>
<p>Looks up a series of four elements. The first is found, with a
uniquely determined position; the second and third are not
found; the fourth could match any position in <code>[1,4]</code>.</p>

<span class="rusttest">fn main() {
    let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];

assert_eq!(s.binary_search(&amp;13),  Ok(9));
assert_eq!(s.binary_search(&amp;4),   Err(7));
assert_eq!(s.binary_search(&amp;100), Err(13));
let r = s.binary_search(&amp;1);
assert!(match r { Ok(1...4) =&gt; true, _ =&gt; false, });
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>];

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">binary_search</span>(<span class="kw-2">&amp;</span><span class="number">13</span>),  <span class="prelude-val">Ok</span>(<span class="number">9</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">binary_search</span>(<span class="kw-2">&amp;</span><span class="number">4</span>),   <span class="prelude-val">Err</span>(<span class="number">7</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">binary_search</span>(<span class="kw-2">&amp;</span><span class="number">100</span>), <span class="prelude-val">Err</span>(<span class="number">13</span>));
<span class="kw">let</span> <span class="ident">r</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">binary_search</span>(<span class="kw-2">&amp;</span><span class="number">1</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="kw">match</span> <span class="ident">r</span> { <span class="prelude-val">Ok</span>(<span class="number">1</span>...<span class="number">4</span>) <span class="op">=&gt;</span> <span class="boolvalue">true</span>, _ <span class="op">=&gt;</span> <span class="boolvalue">false</span>, });</pre>
</div></div><div class="outerdoc" id="7276433757046533657.binary_search_by"><h4 class="method" id="method.binary_search_by"><code>fn <a class="fnname" href="#method.binary_search_by">binary_search_by</a>&lt;F&gt;(&amp;self, f: F) -&gt; <a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;<a class="primitive" href="../primitive.usize.html">usize</a>, <a class="primitive" href="../primitive.usize.html">usize</a>&gt; <span class="where">where F: <a class="trait" href="../../std/ops/trait.FnMut.html" title="std::ops::FnMut">FnMut</a>(&amp;T) -&gt; <a class="enum" href="../../std/cmp/enum.Ordering.html" title="std::cmp::Ordering">Ordering</a></span></code></h4><div class="docblock"><p>Binary search a sorted slice with a comparator function.</p>

<p>The comparator function should implement an order consistent
with the sort order of the underlying slice, returning an
order code that indicates whether its argument is <code>Less</code>,
<code>Equal</code> or <code>Greater</code> the desired target.</p>

<p>If a matching value is found then returns <code>Ok</code>, containing
the index for the matched element; if no match is found then
<code>Err</code> is returned, containing the index where a matching
element could be inserted while maintaining sorted order.</p>

<h1 class="section-header" id="example-8"><a href="#example-8">Example</a></h1>
<p>Looks up a series of four elements. The first is found, with a
uniquely determined position; the second and third are not
found; the fourth could match any position in <code>[1,4]</code>.</p>

<span class="rusttest">fn main() {
    let s = [0, 1, 1, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55];

let seek = 13;
assert_eq!(s.binary_search_by(|probe| probe.cmp(&amp;seek)), Ok(9));
let seek = 4;
assert_eq!(s.binary_search_by(|probe| probe.cmp(&amp;seek)), Err(7));
let seek = 100;
assert_eq!(s.binary_search_by(|probe| probe.cmp(&amp;seek)), Err(13));
let seek = 1;
let r = s.binary_search_by(|probe| probe.cmp(&amp;seek));
assert!(match r { Ok(1...4) =&gt; true, _ =&gt; false, });
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> [<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, <span class="number">55</span>];

<span class="kw">let</span> <span class="ident">seek</span> <span class="op">=</span> <span class="number">13</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">binary_search_by</span>(<span class="op">|</span><span class="ident">probe</span><span class="op">|</span> <span class="ident">probe</span>.<span class="ident">cmp</span>(<span class="kw-2">&amp;</span><span class="ident">seek</span>)), <span class="prelude-val">Ok</span>(<span class="number">9</span>));
<span class="kw">let</span> <span class="ident">seek</span> <span class="op">=</span> <span class="number">4</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">binary_search_by</span>(<span class="op">|</span><span class="ident">probe</span><span class="op">|</span> <span class="ident">probe</span>.<span class="ident">cmp</span>(<span class="kw-2">&amp;</span><span class="ident">seek</span>)), <span class="prelude-val">Err</span>(<span class="number">7</span>));
<span class="kw">let</span> <span class="ident">seek</span> <span class="op">=</span> <span class="number">100</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">binary_search_by</span>(<span class="op">|</span><span class="ident">probe</span><span class="op">|</span> <span class="ident">probe</span>.<span class="ident">cmp</span>(<span class="kw-2">&amp;</span><span class="ident">seek</span>)), <span class="prelude-val">Err</span>(<span class="number">13</span>));
<span class="kw">let</span> <span class="ident">seek</span> <span class="op">=</span> <span class="number">1</span>;
<span class="kw">let</span> <span class="ident">r</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">binary_search_by</span>(<span class="op">|</span><span class="ident">probe</span><span class="op">|</span> <span class="ident">probe</span>.<span class="ident">cmp</span>(<span class="kw-2">&amp;</span><span class="ident">seek</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="kw">match</span> <span class="ident">r</span> { <span class="prelude-val">Ok</span>(<span class="number">1</span>...<span class="number">4</span>) <span class="op">=&gt;</span> <span class="boolvalue">true</span>, _ <span class="op">=&gt;</span> <span class="boolvalue">false</span>, });</pre>
</div></div><div class="outerdoc" id="5332595294186435451.binary_search_by_key"><h4 class="method" id="method.binary_search_by_key"><code>fn <a class="fnname" href="#method.binary_search_by_key">binary_search_by_key</a>&lt;B, F&gt;(&amp;self, b: &amp;B, f: F) -&gt; <a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;<a class="primitive" href="../primitive.usize.html">usize</a>, <a class="primitive" href="../primitive.usize.html">usize</a>&gt; <span class="where">where B: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, F: <a class="trait" href="../../std/ops/trait.FnMut.html" title="std::ops::FnMut">FnMut</a>(&amp;T) -&gt; B</span></code><div class="since" title="Stable since Rust version 1.10.0">1.10.0</div></h4><div class="docblock"><p>Binary search a sorted slice with a key extraction function.</p>

<p>Assumes that the slice is sorted by the key, for instance with
<code>sort_by_key</code> using the same key extraction function.</p>

<p>If a matching value is found then returns <code>Ok</code>, containing the
index for the matched element; if no match is found then <code>Err</code>
is returned, containing the index where a matching element could
be inserted while maintaining sorted order.</p>

<h1 class="section-header" id="examples-35"><a href="#examples-35">Examples</a></h1>
<p>Looks up a series of four elements in a slice of pairs sorted by
their second elements. The first is found, with a uniquely
determined position; the second and third are not found; the
fourth could match any position in <code>[1,4]</code>.</p>

<span class="rusttest">fn main() {
    let s = [(0, 0), (2, 1), (4, 1), (5, 1), (3, 1),
         (1, 2), (2, 3), (4, 5), (5, 8), (3, 13),
         (1, 21), (2, 34), (4, 55)];

assert_eq!(s.binary_search_by_key(&amp;13, |&amp;(a,b)| b),  Ok(9));
assert_eq!(s.binary_search_by_key(&amp;4, |&amp;(a,b)| b),   Err(7));
assert_eq!(s.binary_search_by_key(&amp;100, |&amp;(a,b)| b), Err(13));
let r = s.binary_search_by_key(&amp;1, |&amp;(a,b)| b);
assert!(match r { Ok(1...4) =&gt; true, _ =&gt; false, });
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> [(<span class="number">0</span>, <span class="number">0</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">5</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">1</span>),
         (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>), (<span class="number">5</span>, <span class="number">8</span>), (<span class="number">3</span>, <span class="number">13</span>),
         (<span class="number">1</span>, <span class="number">21</span>), (<span class="number">2</span>, <span class="number">34</span>), (<span class="number">4</span>, <span class="number">55</span>)];

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">binary_search_by_key</span>(<span class="kw-2">&amp;</span><span class="number">13</span>, <span class="op">|</span><span class="kw-2">&amp;</span>(<span class="ident">a</span>,<span class="ident">b</span>)<span class="op">|</span> <span class="ident">b</span>),  <span class="prelude-val">Ok</span>(<span class="number">9</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">binary_search_by_key</span>(<span class="kw-2">&amp;</span><span class="number">4</span>, <span class="op">|</span><span class="kw-2">&amp;</span>(<span class="ident">a</span>,<span class="ident">b</span>)<span class="op">|</span> <span class="ident">b</span>),   <span class="prelude-val">Err</span>(<span class="number">7</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">s</span>.<span class="ident">binary_search_by_key</span>(<span class="kw-2">&amp;</span><span class="number">100</span>, <span class="op">|</span><span class="kw-2">&amp;</span>(<span class="ident">a</span>,<span class="ident">b</span>)<span class="op">|</span> <span class="ident">b</span>), <span class="prelude-val">Err</span>(<span class="number">13</span>));
<span class="kw">let</span> <span class="ident">r</span> <span class="op">=</span> <span class="ident">s</span>.<span class="ident">binary_search_by_key</span>(<span class="kw-2">&amp;</span><span class="number">1</span>, <span class="op">|</span><span class="kw-2">&amp;</span>(<span class="ident">a</span>,<span class="ident">b</span>)<span class="op">|</span> <span class="ident">b</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="kw">match</span> <span class="ident">r</span> { <span class="prelude-val">Ok</span>(<span class="number">1</span>...<span class="number">4</span>) <span class="op">=&gt;</span> <span class="boolvalue">true</span>, _ <span class="op">=&gt;</span> <span class="boolvalue">false</span>, });</pre>
</div></div><div class="outerdoc" id="5810522196025675113.ends_with"><h4 class="method" id="method.ends_with"><code>fn <a class="fnname" href="#method.ends_with">ends_with</a>(&amp;self, needle: <a class="primitive" href="../primitive.slice.html">&amp;[T]</a>) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;T&gt;</span></code></h4><div class="docblock"><p>Returns true if <code>needle</code> is a suffix of the slice.</p>

<h1 class="section-header" id="examples-34"><a href="#examples-34">Examples</a></h1>
<span class="rusttest">fn main() {
    let v = [10, 40, 30];
assert!(v.ends_with(&amp;[30]));
assert!(v.ends_with(&amp;[40, 30]));
assert!(!v.ends_with(&amp;[50]));
assert!(!v.ends_with(&amp;[50, 30]));
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">ends_with</span>(<span class="kw-2">&amp;</span>[<span class="number">30</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">ends_with</span>(<span class="kw-2">&amp;</span>[<span class="number">40</span>, <span class="number">30</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">v</span>.<span class="ident">ends_with</span>(<span class="kw-2">&amp;</span>[<span class="number">50</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">v</span>.<span class="ident">ends_with</span>(<span class="kw-2">&amp;</span>[<span class="number">50</span>, <span class="number">30</span>]));</pre>
</div></div><div class="outerdoc" id="8185567739793449126.starts_with"><h4 class="method" id="method.starts_with"><code>fn <a class="fnname" href="#method.starts_with">starts_with</a>(&amp;self, needle: <a class="primitive" href="../primitive.slice.html">&amp;[T]</a>) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;T&gt;</span></code></h4><div class="docblock"><p>Returns true if <code>needle</code> is a prefix of the slice.</p>

<h1 class="section-header" id="examples-33"><a href="#examples-33">Examples</a></h1>
<span class="rusttest">fn main() {
    let v = [10, 40, 30];
assert!(v.starts_with(&amp;[10]));
assert!(v.starts_with(&amp;[10, 40]));
assert!(!v.starts_with(&amp;[50]));
assert!(!v.starts_with(&amp;[10, 50]));
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">starts_with</span>(<span class="kw-2">&amp;</span>[<span class="number">10</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">starts_with</span>(<span class="kw-2">&amp;</span>[<span class="number">10</span>, <span class="number">40</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">v</span>.<span class="ident">starts_with</span>(<span class="kw-2">&amp;</span>[<span class="number">50</span>]));
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">v</span>.<span class="ident">starts_with</span>(<span class="kw-2">&amp;</span>[<span class="number">10</span>, <span class="number">50</span>]));</pre>
</div></div><div class="outerdoc" id="10956568013451006989.push"><h4 class="method" id="method.push"><code>fn <a class="fnname" href="#method.push">push</a>(&amp;mut self, value: T)</code></h4><div class="docblock"><p>Appends an element to the back of a collection.</p>

<h1 class="section-header" id="panics-5"><a href="#panics-5">Panics</a></h1>
<p>Panics if the number of elements in the vector overflows a <code>usize</code>.</p>

<h1 class="section-header" id="examples-14"><a href="#examples-14">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut vec = vec![1, 2];
vec.push(3);
assert_eq!(vec, [1, 2, 3]);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>];
<span class="ident">vec</span>.<span class="ident">push</span>(<span class="number">3</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</pre>
</div></div><div class="outerdoc" id="13726641135499648661.insert"><h4 class="method" id="method.insert"><code>fn <a class="fnname" href="#method.insert">insert</a>(&amp;mut self, index: <a class="primitive" href="../primitive.usize.html">usize</a>, element: T)</code></h4><div class="docblock"><p>Inserts an element at position <code>index</code> within the vector, shifting all
elements after it to the right.</p>

<h1 class="section-header" id="panics-3"><a href="#panics-3">Panics</a></h1>
<p>Panics if <code>index</code> is greater than the vector's length.</p>

<h1 class="section-header" id="examples-11"><a href="#examples-11">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut vec = vec![1, 2, 3];
vec.insert(1, 4);
assert_eq!(vec, [1, 4, 2, 3]);
vec.insert(4, 5);
assert_eq!(vec, [1, 4, 2, 3, 5]);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="ident">vec</span>.<span class="ident">insert</span>(<span class="number">1</span>, <span class="number">4</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>, [<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>]);
<span class="ident">vec</span>.<span class="ident">insert</span>(<span class="number">4</span>, <span class="number">5</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>, [<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>]);</pre>
</div></div><div class="outerdoc" id="15415737837447922280.extend"><h4 class="method" id="method.extend"><code>fn <a class="fnname" href="../../std/iter/trait.Extend.html#tymethod.extend">extend</a>&lt;I&gt;(&amp;mut self, iter: I) <span class="where">where I: <a class="trait" href="../../std/iter/trait.IntoIterator.html" title="std::iter::IntoIterator">IntoIterator</a>&lt;Item=T&gt;</span></code></h4><div class="docblock"><p>Extends a collection with the contents of an iterator. <a href="../../std/iter/trait.Extend.html#tymethod.extend">Read more</a></p>
</div></div><div class="outerdoc" id="7794087902711693302.extend_from_slice"><h4 class="method" id="method.extend_from_slice"><code>fn <a class="fnname" href="#method.extend_from_slice">extend_from_slice</a>(&amp;mut self, other: <a class="primitive" href="../primitive.slice.html">&amp;[T]</a>)</code><div class="since" title="Stable since Rust version 1.6.0">1.6.0</div></h4><div class="docblock"><p>Appends all elements in a slice to the <code>Vec</code>.</p>

<p>Iterates over the slice <code>other</code>, clones each element, and then appends
it to this <code>Vec</code>. The <code>other</code> vector is traversed in-order.</p>

<p>Note that this function is same as <code>extend</code> except that it is
specialized to work with slices instead. If and when Rust gets
specialization this function will likely be deprecated (but still
available).</p>

<h1 class="section-header" id="examples-23"><a href="#examples-23">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut vec = vec![1];
vec.extend_from_slice(&amp;[2, 3, 4]);
assert_eq!(vec, [1, 2, 3, 4]);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>];
<span class="ident">vec</span>.<span class="ident">extend_from_slice</span>(<span class="kw-2">&amp;</span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</pre>
</div></div><div class="outerdoc" id="7827139835161839906.append"><h4 class="method" id="method.append"><code>fn <a class="fnname" href="#method.append">append</a>(&amp;mut self, other: &amp;mut <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;)</code><div class="since" title="Stable since Rust version 1.4.0">1.4.0</div></h4><div class="docblock"><p>Moves all the elements of <code>other</code> into <code>Self</code>, leaving <code>other</code> empty.</p>

<h1 class="section-header" id="panics-6"><a href="#panics-6">Panics</a></h1>
<p>Panics if the number of elements in the vector overflows a <code>usize</code>.</p>

<h1 class="section-header" id="examples-16"><a href="#examples-16">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut vec = vec![1, 2, 3];
let mut vec2 = vec![4, 5, 6];
vec.append(&amp;mut vec2);
assert_eq!(vec, [1, 2, 3, 4, 5, 6]);
assert_eq!(vec2, []);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec2</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];
<span class="ident">vec</span>.<span class="ident">append</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">vec2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec2</span>, []);</pre>
</div></div><div class="outerdoc" id="14098237708920005647.clone_from"><h4 class="method" id="method.clone_from"><code>fn <a class="fnname" href="../../std/clone/trait.Clone.html#method.clone_from">clone_from</a>(&amp;mut self, other: &amp;<a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;)</code></h4><div class="docblock"><p>Performs copy-assignment from <code>source</code>. <a href="../../std/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div><div class="outerdoc" id="13843048056517825852.clone_from_slice"><h4 class="method" id="method.clone_from_slice"><code>fn <a class="fnname" href="#method.clone_from_slice">clone_from_slice</a>(&amp;mut self, src: <a class="primitive" href="../primitive.slice.html">&amp;[T]</a>) <span class="where">where T: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code><div class="since" title="Stable since Rust version 1.7.0">1.7.0</div></h4><div class="docblock"><p>Copies the elements from <code>src</code> into <code>self</code>.</p>

<p>The length of this slice must be the same as the slice passed in.</p>

<h1 class="section-header" id="panics-15"><a href="#panics-15">Panics</a></h1>
<p>This function will panic if the two slices have different lengths.</p>

<h1 class="section-header" id="example-9"><a href="#example-9">Example</a></h1>
<span class="rusttest">fn main() {
    let mut dst = [0, 0, 0];
let src = [1, 2, 3];

dst.clone_from_slice(&amp;src);
assert!(dst == [1, 2, 3]);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dst</span> <span class="op">=</span> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="ident">dst</span>.<span class="ident">clone_from_slice</span>(<span class="kw-2">&amp;</span><span class="ident">src</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">dst</span> <span class="op">==</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</pre>
</div></div><div class="outerdoc" id="7825918616491699784.copy_from_slice"><h4 class="method" id="method.copy_from_slice"><code>fn <a class="fnname" href="#method.copy_from_slice">copy_from_slice</a>(&amp;mut self, src: <a class="primitive" href="../primitive.slice.html">&amp;[T]</a>) <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code><div class="since" title="Stable since Rust version 1.9.0">1.9.0</div></h4><div class="docblock"><p>Copies all elements from <code>src</code> into <code>self</code>, using a memcpy.</p>

<p>The length of <code>src</code> must be the same as <code>self</code>.</p>

<h1 class="section-header" id="panics-16"><a href="#panics-16">Panics</a></h1>
<p>This function will panic if the two slices have different lengths.</p>

<h1 class="section-header" id="example-10"><a href="#example-10">Example</a></h1>
<span class="rusttest">fn main() {
    let mut dst = [0, 0, 0];
let src = [1, 2, 3];

dst.copy_from_slice(&amp;src);
assert_eq!(src, dst);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">dst</span> <span class="op">=</span> [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>];
<span class="kw">let</span> <span class="ident">src</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="ident">dst</span>.<span class="ident">copy_from_slice</span>(<span class="kw-2">&amp;</span><span class="ident">src</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">src</span>, <span class="ident">dst</span>);</pre>
</div></div><div class="outerdoc" id="15429091652959684945.pop"><h4 class="method" id="method.pop"><code>fn <a class="fnname" href="#method.pop">pop</a>(&amp;mut self) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt;</code></h4><div class="docblock"><p>Removes the last element from a vector and returns it, or <code>None</code> if it
is empty.</p>

<h1 class="section-header" id="examples-15"><a href="#examples-15">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut vec = vec![1, 2, 3];
assert_eq!(vec.pop(), Some(3));
assert_eq!(vec, [1, 2]);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>.<span class="ident">pop</span>(), <span class="prelude-val">Some</span>(<span class="number">3</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>, [<span class="number">1</span>, <span class="number">2</span>]);</pre>
</div></div><div class="outerdoc" id="16199108253719120662.remove"><h4 class="method" id="method.remove"><code>fn <a class="fnname" href="#method.remove">remove</a>(&amp;mut self, index: <a class="primitive" href="../primitive.usize.html">usize</a>) -&gt; T</code></h4><div class="docblock"><p>Removes and returns the element at position <code>index</code> within the vector,
shifting all elements after it to the left.</p>

<h1 class="section-header" id="panics-4"><a href="#panics-4">Panics</a></h1>
<p>Panics if <code>index</code> is out of bounds.</p>

<h1 class="section-header" id="examples-12"><a href="#examples-12">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut v = vec![1, 2, 3];
assert_eq!(v.remove(1), 2);
assert_eq!(v, [1, 3]);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">remove</span>(<span class="number">1</span>), <span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="number">1</span>, <span class="number">3</span>]);</pre>
</div></div><div class="outerdoc" id="12642351548164574140.swap_remove"><h4 class="method" id="method.swap_remove"><code>fn <a class="fnname" href="#method.swap_remove">swap_remove</a>(&amp;mut self, index: <a class="primitive" href="../primitive.usize.html">usize</a>) -&gt; T</code></h4><div class="docblock"><p>Removes an element from anywhere in the vector and return it, replacing
it with the last element.</p>

<p>This does not preserve ordering, but is O(1).</p>

<h1 class="section-header" id="panics-2"><a href="#panics-2">Panics</a></h1>
<p>Panics if <code>index</code> is out of bounds.</p>

<h1 class="section-header" id="examples-10"><a href="#examples-10">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut v = vec!["foo", "bar", "baz", "qux"];

assert_eq!(v.swap_remove(1), "bar");
assert_eq!(v, ["foo", "qux", "baz"]);

assert_eq!(v.swap_remove(0), "foo");
assert_eq!(v, ["baz", "qux"]);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>, <span class="string">"qux"</span>];

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">swap_remove</span>(<span class="number">1</span>), <span class="string">"bar"</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">"foo"</span>, <span class="string">"qux"</span>, <span class="string">"baz"</span>]);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">swap_remove</span>(<span class="number">0</span>), <span class="string">"foo"</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">"baz"</span>, <span class="string">"qux"</span>]);</pre>
</div></div><div class="outerdoc" id="6849249452995298128.truncate"><h4 class="method" id="method.truncate"><code>fn <a class="fnname" href="#method.truncate">truncate</a>(&amp;mut self, len: <a class="primitive" href="../primitive.usize.html">usize</a>)</code></h4><div class="docblock"><p>Shorten a vector to be <code>len</code> elements long, dropping excess elements.</p>

<p>If <code>len</code> is greater than the vector's current length, this has no
effect.</p>

<h1 class="section-header" id="examples-8"><a href="#examples-8">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut vec = vec![1, 2, 3, 4, 5];
vec.truncate(2);
assert_eq!(vec, [1, 2]);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="ident">vec</span>.<span class="ident">truncate</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>, [<span class="number">1</span>, <span class="number">2</span>]);</pre>
</div></div><div class="outerdoc" id="1290646562429518351.drain"><h4 class="method" id="method.drain"><code>fn <a class="fnname" href="#method.drain">drain</a>&lt;R&gt;(&amp;mut self, range: R) -&gt; <a class="struct" href="../../std/vec/struct.Drain.html" title="std::vec::Drain">Drain</a>&lt;T&gt; <span class="where">where R: <a class="trait" href="../../collections/range/trait.RangeArgument.html" title="collections::range::RangeArgument">RangeArgument</a>&lt;<a class="primitive" href="../primitive.usize.html">usize</a>&gt;</span></code><div class="since" title="Stable since Rust version 1.6.0">1.6.0</div></h4><div class="docblock"><p>Create a draining iterator that removes the specified range in the vector
and yields the removed items.</p>

<p>Note 1: The element range is removed even if the iterator is not
consumed until the end.</p>

<p>Note 2: It is unspecified how many elements are removed from the vector,
if the <code>Drain</code> value is leaked.</p>

<h1 class="section-header" id="panics-7"><a href="#panics-7">Panics</a></h1>
<p>Panics if the starting point is greater than the end point or if
the end point is greater than the length of the vector.</p>

<h1 class="section-header" id="examples-17"><a href="#examples-17">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut v = vec![1, 2, 3];
let u: Vec&lt;_&gt; = v.drain(1..).collect();
assert_eq!(v, &amp;[1]);
assert_eq!(u, &amp;[2, 3]);

// A full range clears the vector
v.drain(..);
assert_eq!(v, &amp;[]);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="kw">let</span> <span class="ident">u</span>: <span class="ident">Vec</span><span class="op">&lt;</span>_<span class="op">&gt;</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">drain</span>(<span class="number">1</span>..).<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, <span class="kw-2">&amp;</span>[<span class="number">1</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">u</span>, <span class="kw-2">&amp;</span>[<span class="number">2</span>, <span class="number">3</span>]);

<span class="comment">// A full range clears the vector</span>
<span class="ident">v</span>.<span class="ident">drain</span>(..);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, <span class="kw-2">&amp;</span>[]);</pre>
</div></div><div class="outerdoc" id="11329643013703854319.clear"><h4 class="method" id="method.clear"><code>fn <a class="fnname" href="#method.clear">clear</a>(&amp;mut self)</code></h4><div class="docblock"><p>Clears the vector, removing all values.</p>

<h1 class="section-header" id="examples-18"><a href="#examples-18">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut v = vec![1, 2, 3];

v.clear();

assert!(v.is_empty());
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="ident">v</span>.<span class="ident">clear</span>();

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">is_empty</span>());</pre>
</div></div><div class="outerdoc" id="2666466861577946537.retain"><h4 class="method" id="method.retain"><code>fn <a class="fnname" href="#method.retain">retain</a>&lt;F&gt;(&amp;mut self, f: F) <span class="where">where F: <a class="trait" href="../../std/ops/trait.FnMut.html" title="std::ops::FnMut">FnMut</a>(&amp;T) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></span></code></h4><div class="docblock"><p>Retains only the elements specified by the predicate.</p>

<p>In other words, remove all elements <code>e</code> such that <code>f(&amp;e)</code> returns false.
This method operates in place and preserves the order of the retained
elements.</p>

<h1 class="section-header" id="examples-13"><a href="#examples-13">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut vec = vec![1, 2, 3, 4];
vec.retain(|&amp;x| x%2 == 0);
assert_eq!(vec, [2, 4]);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];
<span class="ident">vec</span>.<span class="ident">retain</span>(<span class="op">|</span><span class="kw-2">&amp;</span><span class="ident">x</span><span class="op">|</span> <span class="ident">x</span><span class="op">%</span><span class="number">2</span> <span class="op">==</span> <span class="number">0</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>, [<span class="number">2</span>, <span class="number">4</span>]);</pre>
</div></div><div class="outerdoc" id="18117690145947997800.dedup"><h4 class="method" id="method.dedup"><code>fn <a class="fnname" href="#method.dedup">dedup</a>(&amp;mut self)</code></h4><div class="docblock"><p>Removes consecutive repeated elements in the vector.</p>

<p>If the vector is sorted, this removes all duplicates.</p>

<h1 class="section-header" id="examples-24"><a href="#examples-24">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut vec = vec![1, 2, 2, 3, 2];

vec.dedup();

assert_eq!(vec, [1, 2, 3, 2]);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>];

<span class="ident">vec</span>.<span class="ident">dedup</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>]);</pre>
</div></div><div class="outerdoc" id="2612716563489981875.sort"><h4 class="method" id="method.sort"><code>fn <a class="fnname" href="#method.sort">sort</a>(&amp;mut self) <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></h4><div class="docblock"><p>This is equivalent to <code>self.sort_by(|a, b| a.cmp(b))</code>.</p>

<p>This sort is stable and <code>O(n log n)</code> worst-case but allocates
approximately <code>2 * n</code> where <code>n</code> is the length of <code>self</code>.</p>

<h1 class="section-header" id="examples-36"><a href="#examples-36">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut v = [-5, 4, 1, -3, 2];

v.sort();
assert!(v == [-5, -3, 1, 2, 4]);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> [<span class="op">-</span><span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="op">-</span><span class="number">3</span>, <span class="number">2</span>];

<span class="ident">v</span>.<span class="ident">sort</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span> <span class="op">==</span> [<span class="op">-</span><span class="number">5</span>, <span class="op">-</span><span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]);</pre>
</div></div><div class="outerdoc" id="14823960042327570666.sort_by"><h4 class="method" id="method.sort_by"><code>fn <a class="fnname" href="#method.sort_by">sort_by</a>&lt;F&gt;(&amp;mut self, compare: F) <span class="where">where F: <a class="trait" href="../../std/ops/trait.FnMut.html" title="std::ops::FnMut">FnMut</a>(&amp;T, &amp;T) -&gt; <a class="enum" href="../../std/cmp/enum.Ordering.html" title="std::cmp::Ordering">Ordering</a></span></code></h4><div class="docblock"><p>Sorts the slice, in place, using <code>compare</code> to compare
elements.</p>

<p>This sort is stable and <code>O(n log n)</code> worst-case but allocates
approximately <code>2 * n</code>, where <code>n</code> is the length of <code>self</code>.</p>

<h1 class="section-header" id="examples-38"><a href="#examples-38">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut v = [5, 4, 1, 3, 2];
v.sort_by(|a, b| a.cmp(b));
assert!(v == [1, 2, 3, 4, 5]);

// reverse sorting
v.sort_by(|a, b| b.cmp(a));
assert!(v == [5, 4, 3, 2, 1]);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>];
<span class="ident">v</span>.<span class="ident">sort_by</span>(<span class="op">|</span><span class="ident">a</span>, <span class="ident">b</span><span class="op">|</span> <span class="ident">a</span>.<span class="ident">cmp</span>(<span class="ident">b</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span> <span class="op">==</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);

<span class="comment">// reverse sorting</span>
<span class="ident">v</span>.<span class="ident">sort_by</span>(<span class="op">|</span><span class="ident">a</span>, <span class="ident">b</span><span class="op">|</span> <span class="ident">b</span>.<span class="ident">cmp</span>(<span class="ident">a</span>));
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span> <span class="op">==</span> [<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]);</pre>
</div></div><div class="outerdoc" id="4540047688751664783.sort_by_key"><h4 class="method" id="method.sort_by_key"><code>fn <a class="fnname" href="#method.sort_by_key">sort_by_key</a>&lt;B, F&gt;(&amp;mut self, f: F) <span class="where">where B: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, F: <a class="trait" href="../../std/ops/trait.FnMut.html" title="std::ops::FnMut">FnMut</a>(&amp;T) -&gt; B</span></code><div class="since" title="Stable since Rust version 1.7.0">1.7.0</div></h4><div class="docblock"><p>Sorts the slice, in place, using <code>key</code> to extract a key by which to
order the sort by.</p>

<p>This sort is stable and <code>O(n log n)</code> worst-case but allocates
approximately <code>2 * n</code>, where <code>n</code> is the length of <code>self</code>.</p>

<h1 class="section-header" id="examples-37"><a href="#examples-37">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut v = [-5i32, 4, 1, -3, 2];

v.sort_by_key(|k| k.abs());
assert!(v == [1, 2, -3, 4, -5]);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> [<span class="op">-</span><span class="number">5i32</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="op">-</span><span class="number">3</span>, <span class="number">2</span>];

<span class="ident">v</span>.<span class="ident">sort_by_key</span>(<span class="op">|</span><span class="ident">k</span><span class="op">|</span> <span class="ident">k</span>.<span class="ident">abs</span>());
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span> <span class="op">==</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="op">-</span><span class="number">3</span>, <span class="number">4</span>, <span class="op">-</span><span class="number">5</span>]);</pre>
</div></div><div class="outerdoc" id="15615508082375761141.reverse"><h4 class="method" id="method.reverse"><code>fn <a class="fnname" href="#method.reverse">reverse</a>(&amp;mut self)</code></h4><div class="docblock"><p>Reverse the order of elements in a slice, in place.</p>

<h1 class="section-header" id="example-3"><a href="#example-3">Example</a></h1>
<span class="rusttest">fn main() {
    let mut v = [1, 2, 3];
v.reverse();
assert!(v == [3, 2, 1]);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="ident">v</span>.<span class="ident">reverse</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span> <span class="op">==</span> [<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]);</pre>
</div></div><div class="outerdoc" id="4258543473833407574.swap"><h4 class="method" id="method.swap"><code>fn <a class="fnname" href="#method.swap">swap</a>(&amp;mut self, a: <a class="primitive" href="../primitive.usize.html">usize</a>, b: <a class="primitive" href="../primitive.usize.html">usize</a>)</code></h4><div class="docblock"><p>Swaps two elements in a slice.</p>

<h1 class="section-header" id="arguments"><a href="#arguments">Arguments</a></h1>
<ul>
<li>a - The index of the first element</li>
<li>b - The index of the second element</li>
</ul>

<h1 class="section-header" id="panics-9"><a href="#panics-9">Panics</a></h1>
<p>Panics if <code>a</code> or <code>b</code> are out of bounds.</p>

<h1 class="section-header" id="example-2"><a href="#example-2">Example</a></h1>
<span class="rusttest">fn main() {
    let mut v = ["a", "b", "c", "d"];
v.swap(1, 3);
assert!(v == ["a", "d", "c", "b"]);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>];
<span class="ident">v</span>.<span class="ident">swap</span>(<span class="number">1</span>, <span class="number">3</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span> <span class="op">==</span> [<span class="string">"a"</span>, <span class="string">"d"</span>, <span class="string">"c"</span>, <span class="string">"b"</span>]);</pre>
</div></div><div class="outerdoc" id="9077499134010481492.iter"><h4 class="method" id="method.iter"><code>fn <a class="fnname" href="#method.iter">iter</a>(&amp;self) -&gt; <a class="struct" href="../../std/slice/struct.Iter.html" title="std::slice::Iter">Iter</a>&lt;T&gt;</code></h4><div class="docblock"><p>Returns an iterator over the slice.</p>
</div></div><div class="outerdoc" id="1560957081480711333.iter_mut"><h4 class="method" id="method.iter_mut"><code>fn <a class="fnname" href="#method.iter_mut">iter_mut</a>(&amp;mut self) -&gt; <a class="struct" href="../../std/slice/struct.IterMut.html" title="std::slice::IterMut">IterMut</a>&lt;T&gt;</code></h4><div class="docblock"><p>Returns an iterator that allows modifying each value</p>
</div></div><div class="outerdoc" id="8015232293810357360.into_iter"><h4 class="method" id="method.into_iter"><code>fn <a class="fnname" href="../../std/iter/trait.IntoIterator.html#tymethod.into_iter">into_iter</a>(self) -&gt; <a class="struct" href="../../std/vec/struct.IntoIter.html" title="std::vec::IntoIter">IntoIter</a>&lt;T&gt;</code></h4><div class="docblock"><p>Creates a consuming iterator, that is, one that moves each value out of
the vector (from start to end). The vector cannot be used after calling
this.</p>

<h1 class="section-header" id="examples-39"><a href="#examples-39">Examples</a></h1>
<span class="rusttest">fn main() {
    let v = vec!["a".to_string(), "b".to_string()];
for s in v.into_iter() {
    // s has type String, not &amp;String
    println!("{}", s);
}
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="string">"a"</span>.<span class="ident">to_string</span>(), <span class="string">"b"</span>.<span class="ident">to_string</span>()];
<span class="kw">for</span> <span class="ident">s</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">into_iter</span>() {
    <span class="comment">// s has type String, not &amp;String</span>
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">"{}"</span>, <span class="ident">s</span>);
}</pre>
</div></div><div class="outerdoc" id="8115425010145621174.chunks"><h4 class="method" id="method.chunks"><code>fn <a class="fnname" href="#method.chunks">chunks</a>(&amp;self, size: <a class="primitive" href="../primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../std/slice/struct.Chunks.html" title="std::slice::Chunks">Chunks</a>&lt;T&gt;</code></h4><div class="docblock"><p>Returns an iterator over <code>size</code> elements of the slice at a
time. The chunks are slices and do not overlap. If <code>size</code> does not divide the
length of the slice, then the last chunk will not have length
<code>size</code>.</p>

<h1 class="section-header" id="panics-11"><a href="#panics-11">Panics</a></h1>
<p>Panics if <code>size</code> is 0.</p>

<h1 class="section-header" id="example-5"><a href="#example-5">Example</a></h1>
<p>Print the slice two elements at a time (i.e. <code>[1,2]</code>,
<code>[3,4]</code>, <code>[5]</code>):</p>

<span class="rusttest">fn main() {
    let v = &amp;[1, 2, 3, 4, 5];
for chunk in v.chunks(2) {
    println!("{:?}", chunk);
}
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];
<span class="kw">for</span> <span class="ident">chunk</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">chunks</span>(<span class="number">2</span>) {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">"{:?}"</span>, <span class="ident">chunk</span>);
}</pre>
</div></div><div class="outerdoc" id="17233738390443499846.chunks_mut"><h4 class="method" id="method.chunks_mut"><code>fn <a class="fnname" href="#method.chunks_mut">chunks_mut</a>(&amp;mut self, chunk_size: <a class="primitive" href="../primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../std/slice/struct.ChunksMut.html" title="std::slice::ChunksMut">ChunksMut</a>&lt;T&gt;</code></h4><div class="docblock"><p>Returns an iterator over <code>chunk_size</code> elements of the slice at a time.
The chunks are mutable slices, and do not overlap. If <code>chunk_size</code> does
not divide the length of the slice, then the last chunk will not
have length <code>chunk_size</code>.</p>

<h1 class="section-header" id="panics-12"><a href="#panics-12">Panics</a></h1>
<p>Panics if <code>chunk_size</code> is 0.</p>
</div></div><div class="outerdoc" id="16694599000034917756.windows"><h4 class="method" id="method.windows"><code>fn <a class="fnname" href="#method.windows">windows</a>(&amp;self, size: <a class="primitive" href="../primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../std/slice/struct.Windows.html" title="std::slice::Windows">Windows</a>&lt;T&gt;</code></h4><div class="docblock"><p>Returns an iterator over all contiguous windows of length
<code>size</code>. The windows overlap. If the slice is shorter than
<code>size</code>, the iterator returns no values.</p>

<h1 class="section-header" id="panics-10"><a href="#panics-10">Panics</a></h1>
<p>Panics if <code>size</code> is 0.</p>

<h1 class="section-header" id="example-4"><a href="#example-4">Example</a></h1>
<p>Print the adjacent pairs of a slice (i.e. <code>[1,2]</code>, <code>[2,3]</code>,
<code>[3,4]</code>):</p>

<span class="rusttest">fn main() {
    let v = &amp;[1, 2, 3, 4];
for win in v.windows(2) {
    println!("{:?}", win);
}
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];
<span class="kw">for</span> <span class="ident">win</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">windows</span>(<span class="number">2</span>) {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">"{:?}"</span>, <span class="ident">win</span>);
}</pre>
</div></div><div class="outerdoc" id="17652544619175377718.into_boxed_slice"><h4 class="method" id="method.into_boxed_slice"><code>fn <a class="fnname" href="#method.into_boxed_slice">into_boxed_slice</a>(self) -&gt; <a class="struct" href="../../std/boxed/struct.Box.html" title="std::boxed::Box">Box</a>&lt;<a class="primitive" href="../primitive.slice.html">[</a>T<a class="primitive" href="../primitive.slice.html">]</a>&gt;</code></h4><div class="docblock"><p>Converts the vector into Box&lt;[T]&gt;.</p>

<p>Note that this will drop any excess capacity. Calling this and
converting back to a vector with <code>into_vec()</code> is equivalent to calling
<code>shrink_to_fit()</code>.</p>
</div></div><div class="outerdoc" id="18221082805249619336.as_ref"><h4 class="method" id="method.as_ref"><code>fn <a class="fnname" href="../../std/convert/trait.AsRef.html#tymethod.as_ref">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;</code></h4><div class="docblock"><p>Performs the conversion.</p>
</div></div><div class="outerdoc" id="15246699235484841356.to_vec"><h4 class="method" id="method.to_vec"><code>fn <a class="fnname" href="#method.to_vec">to_vec</a>(&amp;self) -&gt; <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></h4><div class="docblock"><p>Copies <code>self</code> into a new <code>Vec</code>.</p>
</div></div><div class="outerdoc" id="5875694794780053927.as_slice"><h4 class="method" id="method.as_slice"><code>fn <a class="fnname" href="#method.as_slice">as_slice</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.slice.html">&amp;[T]</a></code><div class="since" title="Stable since Rust version 1.7.0">1.7.0</div></h4><div class="docblock"><p>Extracts a slice containing the entire vector.</p>

<p>Equivalent to <code>&amp;s[..]</code>.</p>
</div></div><div class="outerdoc" id="15816123490174700281.as_mut_slice"><h4 class="method" id="method.as_mut_slice"><code>fn <a class="fnname" href="#method.as_mut_slice">as_mut_slice</a>(&amp;mut self) -&gt; <a class="primitive" href="../primitive.slice.html">&amp;mut [T]</a></code><div class="since" title="Stable since Rust version 1.7.0">1.7.0</div></h4><div class="docblock"><p>Extracts a mutable slice of the entire vector.</p>

<p>Equivalent to <code>&amp;mut s[..]</code>.</p>
</div></div><div class="outerdoc" id="3574687539512420533.capacity"><h4 class="method" id="method.capacity"><code>fn <a class="fnname" href="#method.capacity">capacity</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.usize.html">usize</a></code></h4><div class="docblock"><p>Returns the number of elements the vector can hold without
reallocating.</p>

<h1 class="section-header" id="examples-4"><a href="#examples-4">Examples</a></h1>
<span class="rusttest">fn main() {
    let vec: Vec&lt;i32&gt; = Vec::with_capacity(10);
assert_eq!(vec.capacity(), 10);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">vec</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">with_capacity</span>(<span class="number">10</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>.<span class="ident">capacity</span>(), <span class="number">10</span>);</pre>
</div></div><div class="outerdoc" id="6792948386881586322.reserve"><h4 class="method" id="method.reserve"><code>fn <a class="fnname" href="#method.reserve">reserve</a>(&amp;mut self, additional: <a class="primitive" href="../primitive.usize.html">usize</a>)</code></h4><div class="docblock"><p>Reserves capacity for at least <code>additional</code> more elements to be inserted
in the given <code>Vec&lt;T&gt;</code>. The collection may reserve more space to avoid
frequent reallocations.</p>

<h1 class="section-header" id="panics"><a href="#panics">Panics</a></h1>
<p>Panics if the new capacity overflows <code>usize</code>.</p>

<h1 class="section-header" id="examples-5"><a href="#examples-5">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut vec = vec![1];
vec.reserve(10);
assert!(vec.capacity() &gt;= 11);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>];
<span class="ident">vec</span>.<span class="ident">reserve</span>(<span class="number">10</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">vec</span>.<span class="ident">capacity</span>() <span class="op">&gt;=</span> <span class="number">11</span>);</pre>
</div></div><div class="outerdoc" id="6468945894452751972.reserve_exact"><h4 class="method" id="method.reserve_exact"><code>fn <a class="fnname" href="#method.reserve_exact">reserve_exact</a>(&amp;mut self, additional: <a class="primitive" href="../primitive.usize.html">usize</a>)</code></h4><div class="docblock"><p>Reserves the minimum capacity for exactly <code>additional</code> more elements to
be inserted in the given <code>Vec&lt;T&gt;</code>. Does nothing if the capacity is already
sufficient.</p>

<p>Note that the allocator may give the collection more space than it
requests. Therefore capacity can not be relied upon to be precisely
minimal. Prefer <code>reserve</code> if future insertions are expected.</p>

<h1 class="section-header" id="panics-1"><a href="#panics-1">Panics</a></h1>
<p>Panics if the new capacity overflows <code>usize</code>.</p>

<h1 class="section-header" id="examples-6"><a href="#examples-6">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut vec = vec![1];
vec.reserve_exact(10);
assert!(vec.capacity() &gt;= 11);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>];
<span class="ident">vec</span>.<span class="ident">reserve_exact</span>(<span class="number">10</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">vec</span>.<span class="ident">capacity</span>() <span class="op">&gt;=</span> <span class="number">11</span>);</pre>
</div></div><div class="outerdoc" id="9271989778793293846.shrink_to_fit"><h4 class="method" id="method.shrink_to_fit"><code>fn <a class="fnname" href="#method.shrink_to_fit">shrink_to_fit</a>(&amp;mut self)</code></h4><div class="docblock"><p>Shrinks the capacity of the vector as much as possible.</p>

<p>It will drop down as close as possible to the length but the allocator
may still inform the vector that there is space for a few more elements.</p>

<h1 class="section-header" id="examples-7"><a href="#examples-7">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut vec = Vec::with_capacity(10);
vec.extend([1, 2, 3].iter().cloned());
assert_eq!(vec.capacity(), 10);
vec.shrink_to_fit();
assert!(vec.capacity() &gt;= 3);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">with_capacity</span>(<span class="number">10</span>);
<span class="ident">vec</span>.<span class="ident">extend</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="ident">iter</span>().<span class="ident">cloned</span>());
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>.<span class="ident">capacity</span>(), <span class="number">10</span>);
<span class="ident">vec</span>.<span class="ident">shrink_to_fit</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">vec</span>.<span class="ident">capacity</span>() <span class="op">&gt;=</span> <span class="number">3</span>);</pre>
</div></div><div class="outerdoc" id="5254410224583798498.split_at"><h4 class="method" id="method.split_at"><code>fn <a class="fnname" href="#method.split_at">split_at</a>(&amp;self, mid: <a class="primitive" href="../primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="../primitive.tuple.html">(</a><a class="primitive" href="../primitive.slice.html">&amp;[T]</a>, <a class="primitive" href="../primitive.slice.html">&amp;[T]</a><a class="primitive" href="../primitive.tuple.html">)</a></code></h4><div class="docblock"><p>Divides one slice into two at an index.</p>

<p>The first will contain all indices from <code>[0, mid)</code> (excluding
the index <code>mid</code> itself) and the second will contain all
indices from <code>[mid, len)</code> (excluding the index <code>len</code> itself).</p>

<h1 class="section-header" id="panics-13"><a href="#panics-13">Panics</a></h1>
<p>Panics if <code>mid &gt; len</code>.</p>

<h1 class="section-header" id="examples-28"><a href="#examples-28">Examples</a></h1>
<span class="rusttest">fn main() {
    let v = [10, 40, 30, 20, 50];
let (v1, v2) = v.split_at(2);
assert_eq!([10, 40], v1);
assert_eq!([30, 20, 50], v2);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">50</span>];
<span class="kw">let</span> (<span class="ident">v1</span>, <span class="ident">v2</span>) <span class="op">=</span> <span class="ident">v</span>.<span class="ident">split_at</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>([<span class="number">10</span>, <span class="number">40</span>], <span class="ident">v1</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>([<span class="number">30</span>, <span class="number">20</span>, <span class="number">50</span>], <span class="ident">v2</span>);</pre>
</div></div><div class="outerdoc" id="8923742918456910262.split_at_mut"><h4 class="method" id="method.split_at_mut"><code>fn <a class="fnname" href="#method.split_at_mut">split_at_mut</a>(&amp;mut self, mid: <a class="primitive" href="../primitive.usize.html">usize</a>) -&gt; <a class="primitive" href="../primitive.tuple.html">(</a><a class="primitive" href="../primitive.slice.html">&amp;mut [T]</a>, <a class="primitive" href="../primitive.slice.html">&amp;mut [T]</a><a class="primitive" href="../primitive.tuple.html">)</a></code></h4><div class="docblock"><p>Divides one <code>&amp;mut</code> into two at an index.</p>

<p>The first will contain all indices from <code>[0, mid)</code> (excluding
the index <code>mid</code> itself) and the second will contain all
indices from <code>[mid, len)</code> (excluding the index <code>len</code> itself).</p>

<h1 class="section-header" id="panics-14"><a href="#panics-14">Panics</a></h1>
<p>Panics if <code>mid &gt; len</code>.</p>

<h1 class="section-header" id="example-6"><a href="#example-6">Example</a></h1>
<span class="rusttest">fn main() {
    let mut v = [1, 2, 3, 4, 5, 6];

// scoped to restrict the lifetime of the borrows
{
   let (left, right) = v.split_at_mut(0);
   assert!(left == []);
   assert!(right == [1, 2, 3, 4, 5, 6]);
}

{
    let (left, right) = v.split_at_mut(2);
    assert!(left == [1, 2]);
    assert!(right == [3, 4, 5, 6]);
}

{
    let (left, right) = v.split_at_mut(6);
    assert!(left == [1, 2, 3, 4, 5, 6]);
    assert!(right == []);
}
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];

<span class="comment">// scoped to restrict the lifetime of the borrows</span>
{
   <span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">v</span>.<span class="ident">split_at_mut</span>(<span class="number">0</span>);
   <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">left</span> <span class="op">==</span> []);
   <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">right</span> <span class="op">==</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);
}

{
    <span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">v</span>.<span class="ident">split_at_mut</span>(<span class="number">2</span>);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">left</span> <span class="op">==</span> [<span class="number">1</span>, <span class="number">2</span>]);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">right</span> <span class="op">==</span> [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);
}

{
    <span class="kw">let</span> (<span class="ident">left</span>, <span class="ident">right</span>) <span class="op">=</span> <span class="ident">v</span>.<span class="ident">split_at_mut</span>(<span class="number">6</span>);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">left</span> <span class="op">==</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">right</span> <span class="op">==</span> []);
}</pre>
</div></div><div class="outerdoc" id="5012101341679388727.split"><h4 class="method" id="method.split"><code>fn <a class="fnname" href="#method.split">split</a>&lt;F&gt;(&amp;self, pred: F) -&gt; <a class="struct" href="../../std/slice/struct.Split.html" title="std::slice::Split">Split</a>&lt;T, F&gt; <span class="where">where F: <a class="trait" href="../../std/ops/trait.FnMut.html" title="std::ops::FnMut">FnMut</a>(&amp;T) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></span></code></h4><div class="docblock"><p>Returns an iterator over subslices separated by elements that match
<code>pred</code>.  The matched element is not contained in the subslices.</p>

<h1 class="section-header" id="examples-29"><a href="#examples-29">Examples</a></h1>
<p>Print the slice split by numbers divisible by 3 (i.e. <code>[10, 40]</code>,
<code>[20]</code>, <code>[50]</code>):</p>

<span class="rusttest">fn main() {
    let v = [10, 40, 30, 20, 60, 50];
for group in v.split(|num| *num % 3 == 0) {
    println!("{:?}", group);
}
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">50</span>];
<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">split</span>(<span class="op">|</span><span class="ident">num</span><span class="op">|</span> <span class="op">*</span><span class="ident">num</span> <span class="op">%</span> <span class="number">3</span> <span class="op">==</span> <span class="number">0</span>) {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">"{:?}"</span>, <span class="ident">group</span>);
}</pre>
</div></div><div class="outerdoc" id="163049453469992221.split_mut"><h4 class="method" id="method.split_mut"><code>fn <a class="fnname" href="#method.split_mut">split_mut</a>&lt;F&gt;(&amp;mut self, pred: F) -&gt; <a class="struct" href="../../std/slice/struct.SplitMut.html" title="std::slice::SplitMut">SplitMut</a>&lt;T, F&gt; <span class="where">where F: <a class="trait" href="../../std/ops/trait.FnMut.html" title="std::ops::FnMut">FnMut</a>(&amp;T) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></span></code></h4><div class="docblock"><p>Returns an iterator over mutable subslices separated by elements that
match <code>pred</code>.  The matched element is not contained in the subslices.</p>
</div></div><div class="outerdoc" id="2196267873978673785.splitn"><h4 class="method" id="method.splitn"><code>fn <a class="fnname" href="#method.splitn">splitn</a>&lt;F&gt;(&amp;self, n: <a class="primitive" href="../primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="../../std/slice/struct.SplitN.html" title="std::slice::SplitN">SplitN</a>&lt;T, F&gt; <span class="where">where F: <a class="trait" href="../../std/ops/trait.FnMut.html" title="std::ops::FnMut">FnMut</a>(&amp;T) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></span></code></h4><div class="docblock"><p>Returns an iterator over subslices separated by elements that match
<code>pred</code>, limited to returning at most <code>n</code> items.  The matched element is
not contained in the subslices.</p>

<p>The last element returned, if any, will contain the remainder of the
slice.</p>

<h1 class="section-header" id="examples-30"><a href="#examples-30">Examples</a></h1>
<p>Print the slice split once by numbers divisible by 3 (i.e. <code>[10, 40]</code>,
<code>[20, 60, 50]</code>):</p>

<span class="rusttest">fn main() {
    let v = [10, 40, 30, 20, 60, 50];
for group in v.splitn(2, |num| *num % 3 == 0) {
    println!("{:?}", group);
}
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">50</span>];
<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">splitn</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">num</span><span class="op">|</span> <span class="op">*</span><span class="ident">num</span> <span class="op">%</span> <span class="number">3</span> <span class="op">==</span> <span class="number">0</span>) {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">"{:?}"</span>, <span class="ident">group</span>);
}</pre>
</div></div><div class="outerdoc" id="4387684880198014871.splitn_mut"><h4 class="method" id="method.splitn_mut"><code>fn <a class="fnname" href="#method.splitn_mut">splitn_mut</a>&lt;F&gt;(&amp;mut self, n: <a class="primitive" href="../primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="../../std/slice/struct.SplitNMut.html" title="std::slice::SplitNMut">SplitNMut</a>&lt;T, F&gt; <span class="where">where F: <a class="trait" href="../../std/ops/trait.FnMut.html" title="std::ops::FnMut">FnMut</a>(&amp;T) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></span></code></h4><div class="docblock"><p>Returns an iterator over subslices separated by elements that match
<code>pred</code>, limited to returning at most <code>n</code> items.  The matched element is
not contained in the subslices.</p>

<p>The last element returned, if any, will contain the remainder of the
slice.</p>
</div></div><div class="outerdoc" id="1686165125513176542.rsplitn"><h4 class="method" id="method.rsplitn"><code>fn <a class="fnname" href="#method.rsplitn">rsplitn</a>&lt;F&gt;(&amp;self, n: <a class="primitive" href="../primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="../../std/slice/struct.RSplitN.html" title="std::slice::RSplitN">RSplitN</a>&lt;T, F&gt; <span class="where">where F: <a class="trait" href="../../std/ops/trait.FnMut.html" title="std::ops::FnMut">FnMut</a>(&amp;T) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></span></code></h4><div class="docblock"><p>Returns an iterator over subslices separated by elements that match
<code>pred</code> limited to returning at most <code>n</code> items. This starts at the end of
the slice and works backwards.  The matched element is not contained in
the subslices.</p>

<p>The last element returned, if any, will contain the remainder of the
slice.</p>

<h1 class="section-header" id="examples-31"><a href="#examples-31">Examples</a></h1>
<p>Print the slice split once, starting from the end, by numbers divisible
by 3 (i.e. <code>[50]</code>, <code>[10, 40, 30, 20]</code>):</p>

<span class="rusttest">fn main() {
    let v = [10, 40, 30, 20, 60, 50];
for group in v.rsplitn(2, |num| *num % 3 == 0) {
    println!("{:?}", group);
}
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">50</span>];
<span class="kw">for</span> <span class="ident">group</span> <span class="kw">in</span> <span class="ident">v</span>.<span class="ident">rsplitn</span>(<span class="number">2</span>, <span class="op">|</span><span class="ident">num</span><span class="op">|</span> <span class="op">*</span><span class="ident">num</span> <span class="op">%</span> <span class="number">3</span> <span class="op">==</span> <span class="number">0</span>) {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">"{:?}"</span>, <span class="ident">group</span>);
}</pre>
</div></div><div class="outerdoc" id="737863001668677903.rsplitn_mut"><h4 class="method" id="method.rsplitn_mut"><code>fn <a class="fnname" href="#method.rsplitn_mut">rsplitn_mut</a>&lt;F&gt;(&amp;mut self, n: <a class="primitive" href="../primitive.usize.html">usize</a>, pred: F) -&gt; <a class="struct" href="../../std/slice/struct.RSplitNMut.html" title="std::slice::RSplitNMut">RSplitNMut</a>&lt;T, F&gt; <span class="where">where F: <a class="trait" href="../../std/ops/trait.FnMut.html" title="std::ops::FnMut">FnMut</a>(&amp;T) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></span></code></h4><div class="docblock"><p>Returns an iterator over subslices separated by elements that match
<code>pred</code> limited to returning at most <code>n</code> items. This starts at the end of
the slice and works backwards.  The matched element is not contained in
the subslices.</p>

<p>The last element returned, if any, will contain the remainder of the
slice.</p>
</div></div><div class="outerdoc" id="9854561338622172329.split_off"><h4 class="method" id="method.split_off"><code>fn <a class="fnname" href="#method.split_off">split_off</a>(&amp;mut self, at: <a class="primitive" href="../primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;</code><div class="since" title="Stable since Rust version 1.4.0">1.4.0</div></h4><div class="docblock"><p>Splits the collection into two at the given index.</p>

<p>Returns a newly allocated <code>Self</code>. <code>self</code> contains elements <code>[0, at)</code>,
and the returned <code>Self</code> contains elements <code>[at, len)</code>.</p>

<p>Note that the capacity of <code>self</code> does not change.</p>

<h1 class="section-header" id="panics-8"><a href="#panics-8">Panics</a></h1>
<p>Panics if <code>at &gt; len</code>.</p>

<h1 class="section-header" id="examples-21"><a href="#examples-21">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut vec = vec![1,2,3];
let vec2 = vec.split_off(1);
assert_eq!(vec, [1]);
assert_eq!(vec2, [2, 3]);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];
<span class="kw">let</span> <span class="ident">vec2</span> <span class="op">=</span> <span class="ident">vec</span>.<span class="ident">split_off</span>(<span class="number">1</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>, [<span class="number">1</span>]);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec2</span>, [<span class="number">2</span>, <span class="number">3</span>]);</pre>
</div></div><div class="outerdoc" id="7689720323666250363.cmp"><h4 class="method" id="method.cmp"><code>fn <a class="fnname" href="../../std/cmp/trait.Ord.html#tymethod.cmp">cmp</a>(&amp;self, other: &amp;<a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;) -&gt; <a class="enum" href="../../std/cmp/enum.Ordering.html" title="std::cmp::Ordering">Ordering</a></code></h4><div class="docblock"><p>This method returns an <code>Ordering</code> between <code>self</code> and <code>other</code>. <a href="../../std/cmp/trait.Ord.html#tymethod.cmp">Read more</a></p>
</div></div><div class="outerdoc" id="6793276335168028715.eq"><h4 class="method" id="method.eq"><code>fn <a class="fnname" href="../../std/cmp/trait.PartialEq.html#tymethod.eq">eq</a>(&amp;self, other: &amp;<a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;B&gt;) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h4><div class="docblock"><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../../std/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></div><div class="outerdoc" id="4690548007565962405.ne"><h4 class="method" id="method.ne"><code>fn <a class="fnname" href="../../std/cmp/trait.PartialEq.html#method.ne">ne</a>(&amp;self, other: &amp;<a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;B&gt;) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h4><div class="docblock"><p>This method tests for <code>!=</code>.</p>
</div></div><div class="outerdoc" id="2323966808312194852.lt"><h4 class="method" id="method.lt"><code>fn <a class="fnname" href="../../std/cmp/trait.PartialOrd.html#method.lt">lt</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h4><div class="docblock"><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../../std/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div></div><div class="outerdoc" id="13372276364791705833.le"><h4 class="method" id="method.le"><code>fn <a class="fnname" href="../../std/cmp/trait.PartialOrd.html#method.le">le</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h4><div class="docblock"><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="../../std/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div></div><div class="outerdoc" id="14921762095830485457.gt"><h4 class="method" id="method.gt"><code>fn <a class="fnname" href="../../std/cmp/trait.PartialOrd.html#method.gt">gt</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h4><div class="docblock"><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../../std/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div></div><div class="outerdoc" id="14789473908241452967.ge"><h4 class="method" id="method.ge"><code>fn <a class="fnname" href="../../std/cmp/trait.PartialOrd.html#method.ge">ge</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h4><div class="docblock"><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="../../std/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></div><div class="outerdoc" id="1757235193742138506.hash"><h4 class="method" id="method.hash"><code>fn <a class="fnname" href="../../std/hash/trait.Hash.html#tymethod.hash">hash</a>&lt;H&gt;(&amp;self, state: &amp;mut H) <span class="where">where H: <a class="trait" href="../../std/hash/trait.Hasher.html" title="std::hash::Hasher">Hasher</a></span></code></h4><div class="docblock"><p>Feeds this value into the state given, updating the hasher as necessary.</p>
</div></div><div class="outerdoc" id="15125398731714025335.from"><h4 class="method" id="method.from"><code>fn <a class="fnname" href="../../std/convert/trait.From.html#tymethod.from">from</a>(heap: <a class="struct" href="../../std/collections/binary_heap/struct.BinaryHeap.html" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt;) -&gt; <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;</code></h4><div class="docblock"><p>Performs the conversion.</p>
</div></div><div class="outerdoc" id="12446077907838790974.borrow"><h4 class="method" id="method.borrow"><code>fn <a class="fnname" href="../../std/borrow/trait.Borrow.html#tymethod.borrow">borrow</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.slice.html">&amp;[T]</a></code></h4><div class="docblock"><p>Immutably borrows from an owned value. <a href="../../std/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div><div class="outerdoc" id="10588675754266479615.borrow_mut"><h4 class="method" id="method.borrow_mut"><code>fn <a class="fnname" href="../../std/borrow/trait.BorrowMut.html#tymethod.borrow_mut">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="../primitive.slice.html">&amp;mut [T]</a></code></h4><div class="docblock"><p>Mutably borrows from an owned value. <a href="../../std/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div><div class="outerdoc" id="1244055280893109355.clone"><h4 class="method" id="method.clone"><code>fn <a class="fnname" href="../../std/clone/trait.Clone.html#tymethod.clone">clone</a>(&amp;self) -&gt; <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;</code></h4><div class="docblock"><p>Returns a copy of the value. <a href="../../std/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div></div><div class="outerdoc" id="13278721116970488004.clone_from"><h4 class="method" id="method.clone_from"><code>fn <a class="fnname" href="../../std/clone/trait.Clone.html#method.clone_from">clone_from</a>(&amp;mut self, other: &amp;<a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;)</code></h4><div class="docblock"><p>Performs copy-assignment from <code>source</code>. <a href="../../std/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div><div class="outerdoc" id="7669110113239414778.hash"><h4 class="method" id="method.hash"><code>fn <a class="fnname" href="../../std/hash/trait.Hash.html#tymethod.hash">hash</a>&lt;H&gt;(&amp;self, state: &amp;mut H) <span class="where">where H: <a class="trait" href="../../std/hash/trait.Hasher.html" title="std::hash::Hasher">Hasher</a></span></code></h4><div class="docblock"><p>Feeds this value into the state given, updating the hasher as necessary.</p>
</div></div><div class="outerdoc" id="13166171292110904739.hash_slice"><h4 class="method" id="method.hash_slice"><code>fn <a class="fnname" href="../../std/hash/trait.Hash.html#method.hash_slice">hash_slice</a>&lt;H&gt;(data: <a class="primitive" href="../primitive.slice.html">&amp;[Self]</a>, state: &amp;mut H) <span class="where">where H: <a class="trait" href="../../std/hash/trait.Hasher.html" title="std::hash::Hasher">Hasher</a></span></code><div class="since" title="Stable since Rust version 1.3.0">1.3.0</div></h4><div class="docblock"><p>Feeds a slice of this type into the state provided.</p>
</div></div><div class="outerdoc" id="1609730540576136982.index"><h4 class="method" id="method.index"><code>fn <a class="fnname" href="../../std/ops/trait.Index.html#tymethod.index">index</a>(&amp;self, index: <a class="primitive" href="../primitive.usize.html">usize</a>) -&gt; &amp;T</code></h4><div class="docblock"><p>The method for the indexing (<code>Foo[Bar]</code>) operation</p>
</div></div><div class="outerdoc" id="5108033519051641611.index_mut"><h4 class="method" id="method.index_mut"><code>fn <a class="fnname" href="../../std/ops/trait.IndexMut.html#tymethod.index_mut">index_mut</a>(&amp;mut self, index: <a class="primitive" href="../primitive.usize.html">usize</a>) -&gt; &amp;mut T</code></h4><div class="docblock"><p>The method for the indexing (<code>Foo[Bar]</code>) operation</p>
</div></div><div class="outerdoc" id="17781849772444641952.deref"><h4 class="method" id="method.deref"><code>fn <a class="fnname" href="../../std/ops/trait.Deref.html#tymethod.deref">deref</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.slice.html">&amp;[T]</a></code></h4><div class="docblock"><p>The method called to dereference a value</p>
</div></div><div class="outerdoc" id="15275472375867915505.deref_mut"><h4 class="method" id="method.deref_mut"><code>fn <a class="fnname" href="../../std/ops/trait.DerefMut.html#tymethod.deref_mut">deref_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="../primitive.slice.html">&amp;mut [T]</a></code></h4><div class="docblock"><p>The method called to mutably dereference a value</p>
</div></div><div class="outerdoc" id="12925779201927661930.extend"><h4 class="method" id="method.extend"><code>fn <a class="fnname" href="../../std/iter/trait.Extend.html#tymethod.extend">extend</a>&lt;I&gt;(&amp;mut self, iter: I) <span class="where">where I: <a class="trait" href="../../std/iter/trait.IntoIterator.html" title="std::iter::IntoIterator">IntoIterator</a>&lt;Item=T&gt;</span></code></h4><div class="docblock"><p>Extends a collection with the contents of an iterator. <a href="../../std/iter/trait.Extend.html#tymethod.extend">Read more</a></p>
</div></div><div class="outerdoc" id="9968238619283657671.drop"><h4 class="method" id="method.drop"><code>fn <a class="fnname" href="../../std/ops/trait.Drop.html#tymethod.drop">drop</a>(&amp;mut self)</code></h4><div class="docblock"><p>A method called when the value goes out of scope. <a href="../../std/ops/trait.Drop.html#tymethod.drop">Read more</a></p>
</div></div><div class="outerdoc" id="11544729834252856644.default"><h4 class="method" id="method.default"><code>fn <a class="fnname" href="../../std/default/trait.Default.html#tymethod.default">default</a>() -&gt; <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;</code></h4><div class="docblock"><p>Returns the "default value" for a type. <a href="../../std/default/trait.Default.html#tymethod.default">Read more</a></p>
</div></div><div class="outerdoc" id="4150813030140686537.fmt"><h4 class="method" id="method.fmt"><code>fn <a class="fnname" href="../../std/fmt/trait.Debug.html#tymethod.fmt">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../../std/fmt/struct.Formatter.html" title="std::fmt::Formatter">Formatter</a>) -&gt; <a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;<a class="primitive" href="../primitive.tuple.html">()</a>, <a class="struct" href="../../std/fmt/struct.Error.html" title="std::fmt::Error">Error</a>&gt;</code></h4><div class="docblock"><p>Formats the value using the given formatter.</p>
</div></div><div class="outerdoc" id="12223557033592547113.as_ref"><h4 class="method" id="method.as_ref"><code>fn <a class="fnname" href="../../std/convert/trait.AsRef.html#tymethod.as_ref">as_ref</a>(&amp;self) -&gt; &amp;<a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;</code></h4><div class="docblock"><p>Performs the conversion.</p>
</div></div><div class="outerdoc" id="11746288218305119104.as_mut"><h4 class="method" id="method.as_mut"><code>fn <a class="fnname" href="../../std/convert/trait.AsMut.html#tymethod.as_mut">as_mut</a>(&amp;mut self) -&gt; &amp;mut <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;</code></h4><div class="docblock"><p>Performs the conversion.</p>
</div></div><div class="outerdoc" id="1657108870591022558.from-1"><h4 class="method" id="method.from-1"><code>fn <a class="fnname" href="../../std/convert/trait.From.html#tymethod.from">from</a>(s: <a class="primitive" href="../primitive.slice.html">&amp;'a [T]</a>) -&gt; <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;</code></h4><div class="docblock"><p>Performs the conversion.</p>
</div></div><div class="outerdoc" id="vec.initmacro"><div class="docblock" id="vec.initmacro">
<h1 class="fqn"><span class="in-band"><a href="index.html">std</a>::<wbr><a class="macro" href="">vec!</a></span><span class="out-of-band"><span id="render-detail">
                   <a href="javascript:void(0)" id="toggle-all-docs" title="collapse all docs">
                       [<span class="inner"></span>]
                   </a>
               </span></span></h1>
<pre class="rust macro"><span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">vec</span> {
    ( $ <span class="ident">elem</span> : <span class="ident">expr</span> ; $ <span class="ident">n</span> : <span class="ident">expr</span> ) <span class="op">=&gt;</span> { ... };
    ( $ ( $ <span class="ident">x</span> : <span class="ident">expr</span> ) , <span class="op">*</span> ) <span class="op">=&gt;</span> { ... };
    ( $ ( $ <span class="ident">x</span> : <span class="ident">expr</span> , ) <span class="op">*</span> ) <span class="op">=&gt;</span> { ... };
}</pre>
<div class="docblock"><p>Creates a <code>Vec</code> containing the arguments.</p>

<p><code>vec!</code> allows <code>Vec</code>s to be defined with the same syntax as array expressions.
There are two forms of this macro:</p>

<ul>
<li>Create a <code>Vec</code> containing a given list of elements:</li>
</ul>

<span class="rusttest">fn main() {
    let v = vec![1, 2, 3];
assert_eq!(v[0], 1);
assert_eq!(v[1], 2);
assert_eq!(v[2], 3);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>[<span class="number">0</span>], <span class="number">1</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>[<span class="number">1</span>], <span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>[<span class="number">2</span>], <span class="number">3</span>);</pre>

<ul>
<li>Create a <code>Vec</code> from a given element and size:</li>
</ul>

<span class="rusttest">fn main() {
    let v = vec![1; 3];
assert_eq!(v, [1, 1, 1]);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>; <span class="number">3</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);</pre>

<p>Note that unlike array expressions this syntax supports all elements
which implement <code>Clone</code> and the number of elements doesn't have to be
a constant.</p>

<p>This will use <code>clone()</code> to duplicate an expression, so one should be careful
using this with types having a nonstandard <code>Clone</code> implementation. For
example, <code>vec![Rc::new(1); 5]</code> will create a vector of five references
to the same boxed integer value, not five references pointing to independently
boxed integers.</p>
</div></div></div><div class="outerdoc" id="trait.IntoIterator"><div class="docblock" id="trait.IntoIterator">
<h1 class="fqn"><span class="in-band">Trait <a href="../">std</a>::<wbr><a href="index.html">iter</a>::<wbr><a class="trait" href="">IntoIterator</a></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><span id="render-detail">
                   <a href="javascript:void(0)" id="toggle-all-docs" title="collapse all docs">
                       [<span class="inner"></span>]
                   </a>
               </span><a class="srclink" href="../../core/iter/traits/trait.IntoIterator.html?gotosrc=31714" id="src-31714" title="goto source code">[src]</a></span></h1>
<pre class="rust trait">pub trait IntoIterator <span class="where">where Self::<a class="trait" href="../../std/iter/trait.IntoIterator.html" title="std::iter::IntoIterator">IntoIter</a>::<a class="trait" href="../../std/iter/trait.Iterator.html" title="std::iter::Iterator">Item</a> == Self::<a class="trait" href="../../std/iter/trait.IntoIterator.html" title="std::iter::IntoIterator">Item</a></span> {
    type <a class="type" href="#associatedtype.Item">Item</a>;
    type <a class="type" href="#associatedtype.IntoIter">IntoIter</a>: <a class="trait" href="../../std/iter/trait.Iterator.html" title="std::iter::Iterator">Iterator</a>;
    fn <a class="fnname" href="#tymethod.into_iter">into_iter</a>(self) -&gt; Self::<a class="trait" href="../../std/iter/trait.IntoIterator.html" title="std::iter::IntoIterator">IntoIter</a>;
}</pre><div class="docblock"><p>Conversion into an <code>Iterator</code>.</p>

<p>By implementing <code>IntoIterator</code> for a type, you define how it will be
converted to an iterator. This is common for types which describe a
collection of some kind.</p>

<p>One benefit of implementing <code>IntoIterator</code> is that your type will <a href="index.html#for-loops-and-intoiterator">work
with Rust's <code>for</code> loop syntax</a>.</p>

<p>See also: <a href="trait.FromIterator.html"><code>FromIterator</code></a>.</p>

<h1 class="section-header" id="examples"><a href="#examples">Examples</a></h1>
<p>Basic usage:</p>

<span class="rusttest">fn main() {
    let v = vec![1, 2, 3];

let mut iter = v.into_iter();

let n = iter.next();
assert_eq!(Some(1), n);

let n = iter.next();
assert_eq!(Some(2), n);

let n = iter.next();
assert_eq!(Some(3), n);

let n = iter.next();
assert_eq!(None, n);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">into_iter</span>();

<span class="kw">let</span> <span class="ident">n</span> <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>), <span class="ident">n</span>);

<span class="kw">let</span> <span class="ident">n</span> <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">2</span>), <span class="ident">n</span>);

<span class="kw">let</span> <span class="ident">n</span> <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">3</span>), <span class="ident">n</span>);

<span class="kw">let</span> <span class="ident">n</span> <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">n</span>);</pre>

<p>Implementing <code>IntoIterator</code> for your type:</p>

<span class="rusttest">fn main() {
    // A sample collection, that's just a wrapper over Vec&lt;T&gt;
#[derive(Debug)]
struct MyCollection(Vec&lt;i32&gt;);

// Let's give it some methods so we can create one and add things
// to it.
impl MyCollection {
    fn new() -&gt; MyCollection {
        MyCollection(Vec::new())
    }

    fn add(&amp;mut self, elem: i32) {
        self.0.push(elem);
    }
}

// and we'll implement IntoIterator
impl IntoIterator for MyCollection {
    type Item = i32;
    type IntoIter = ::std::vec::IntoIter&lt;i32&gt;;

    fn into_iter(self) -&gt; Self::IntoIter {
        self.0.into_iter()
    }
}

// Now we can make a new collection...
let mut c = MyCollection::new();

// ... add some stuff to it ...
c.add(0);
c.add(1);
c.add(2);

// ... and then turn it into an Iterator:
for (i, n) in c.into_iter().enumerate() {
    assert_eq!(i as i32, n);
}
}</span><pre class="rust rust-example-rendered"><span class="comment">// A sample collection, that's just a wrapper over Vec&lt;T&gt;</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyCollection</span>(<span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>);

<span class="comment">// Let's give it some methods so we can create one and add things</span>
<span class="comment">// to it.</span>
<span class="kw">impl</span> <span class="ident">MyCollection</span> {
    <span class="kw">fn</span> <span class="ident">new</span>() <span class="op">-&gt;</span> <span class="ident">MyCollection</span> {
        <span class="ident">MyCollection</span>(<span class="ident">Vec</span>::<span class="ident">new</span>())
    }

    <span class="kw">fn</span> <span class="ident">add</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">elem</span>: <span class="ident">i32</span>) {
        <span class="self">self</span>.<span class="number">0</span>.<span class="ident">push</span>(<span class="ident">elem</span>);
    }
}

<span class="comment">// and we'll implement IntoIterator</span>
<span class="kw">impl</span> <span class="ident">IntoIterator</span> <span class="kw">for</span> <span class="ident">MyCollection</span> {
    <span class="kw">type</span> <span class="ident">Item</span> <span class="op">=</span> <span class="ident">i32</span>;
    <span class="kw">type</span> <span class="ident">IntoIter</span> <span class="op">=</span> ::<span class="ident">std</span>::<span class="ident">vec</span>::<span class="ident">IntoIter</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>;

    <span class="kw">fn</span> <span class="ident">into_iter</span>(<span class="self">self</span>) <span class="op">-&gt;</span> <span class="self">Self</span>::<span class="ident">IntoIter</span> {
        <span class="self">self</span>.<span class="number">0</span>.<span class="ident">into_iter</span>()
    }
}

<span class="comment">// Now we can make a new collection...</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">MyCollection</span>::<span class="ident">new</span>();

<span class="comment">// ... add some stuff to it ...</span>
<span class="ident">c</span>.<span class="ident">add</span>(<span class="number">0</span>);
<span class="ident">c</span>.<span class="ident">add</span>(<span class="number">1</span>);
<span class="ident">c</span>.<span class="ident">add</span>(<span class="number">2</span>);

<span class="comment">// ... and then turn it into an Iterator:</span>
<span class="kw">for</span> (<span class="ident">i</span>, <span class="ident">n</span>) <span class="kw">in</span> <span class="ident">c</span>.<span class="ident">into_iter</span>().<span class="ident">enumerate</span>() {
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">i</span> <span class="kw">as</span> <span class="ident">i32</span>, <span class="ident">n</span>);
}</pre>
</div>
            <h2 id="associated-types">Associated Types</h2>
            <div class="methods">
        <h3 class="method stab " id="associatedtype.Item"><code>type <a class="type" href="#associatedtype.Item">Item</a></code></h3><div class="docblock"><p>The type of the elements being iterated over.</p>
</div><h3 class="method stab " id="associatedtype.IntoIter"><code>type <a class="type" href="#associatedtype.IntoIter">IntoIter</a>: <a class="trait" href="../../std/iter/trait.Iterator.html" title="std::iter::Iterator">Iterator</a></code></h3><div class="docblock"><p>Which kind of iterator are we turning this into?</p>
</div></div>
            <h2 id="required-methods">Required Methods</h2>
            <div class="methods">
        <h3 class="method stab " id="tymethod.into_iter"><code>fn <a class="fnname" href="#tymethod.into_iter">into_iter</a>(self) -&gt; Self::<a class="trait" href="../../std/iter/trait.IntoIterator.html" title="std::iter::IntoIterator">IntoIter</a></code></h3><div class="docblock"><p>Creates an iterator from a value.</p>

<p>See the <a href="trait.IntoIterator.html">module-level documentation</a> for more.</p>

<h1 class="section-header" id="examples-1"><a href="#examples-1">Examples</a></h1>
<p>Basic usage:</p>

<span class="rusttest">fn main() {
    let v = vec![1, 2, 3];

let mut iter = v.into_iter();

let n = iter.next();
assert_eq!(Some(1), n);

let n = iter.next();
assert_eq!(Some(2), n);

let n = iter.next();
assert_eq!(Some(3), n);

let n = iter.next();
assert_eq!(None, n);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">iter</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">into_iter</span>();

<span class="kw">let</span> <span class="ident">n</span> <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">1</span>), <span class="ident">n</span>);

<span class="kw">let</span> <span class="ident">n</span> <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">2</span>), <span class="ident">n</span>);

<span class="kw">let</span> <span class="ident">n</span> <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">3</span>), <span class="ident">n</span>);

<span class="kw">let</span> <span class="ident">n</span> <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">next</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">n</span>);</pre>
</div></div>
        <h2 id="implementors">Implementors</h2>
        <ul class="item-list" id="implementors-list">
    <li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 0]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 0]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 1]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 1]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 2]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 2]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 3]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 3]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 4]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 4]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 5]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 5]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 6]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 6]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 7]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 7]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 8]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 8]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 9]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 9]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 10]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 10]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 11]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 11]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 12]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 12]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 13]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 13]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 14]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 14]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 15]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 15]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 16]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 16]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 17]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 17]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 18]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 18]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 19]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 19]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 20]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 20]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 21]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 21]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 22]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 22]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 23]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 23]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 24]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 24]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 25]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 25]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 26]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 26]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 27]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 27]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 28]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 28]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 29]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 29]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 30]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 30]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 31]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 31]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 32]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 32]</a></code></li>
<li><code>impl&lt;I&gt; IntoIterator for I <span class="where">where I: <a class="trait" href="../../std/iter/trait.Iterator.html" title="std::iter::Iterator">Iterator</a></span></code></li>
<li><code>impl&lt;T&gt; IntoIterator for <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt;</code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt;</code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt;</code></li>
<li><code>impl&lt;T, E&gt; IntoIterator for <a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;T, E&gt;</code></li>
<li><code>impl&lt;'a, T, E&gt; IntoIterator for &amp;'a <a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;T, E&gt;</code></li>
<li><code>impl&lt;'a, T, E&gt; IntoIterator for &amp;'a mut <a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;T, E&gt;</code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for <a class="primitive" href="../primitive.slice.html">&amp;'a [T]</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for <a class="primitive" href="../primitive.slice.html">&amp;'a mut [T]</a></code></li>
<li><code>impl&lt;T&gt; IntoIterator for <a class="struct" href="../../std/collections/binary_heap/struct.BinaryHeap.html" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="struct" href="../../std/collections/binary_heap/struct.BinaryHeap.html" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;'a, K, V&gt; IntoIterator for &amp;'a <a class="struct" href="../../std/collections/btree_map/struct.BTreeMap.html" title="std::collections::btree_map::BTreeMap">BTreeMap</a>&lt;K, V&gt; <span class="where">where K: 'a, V: 'a</span></code></li>
<li><code>impl&lt;'a, K, V&gt; IntoIterator for &amp;'a mut <a class="struct" href="../../std/collections/btree_map/struct.BTreeMap.html" title="std::collections::btree_map::BTreeMap">BTreeMap</a>&lt;K, V&gt; <span class="where">where K: 'a, V: 'a</span></code></li>
<li><code>impl&lt;K, V&gt; IntoIterator for <a class="struct" href="../../std/collections/btree_map/struct.BTreeMap.html" title="std::collections::btree_map::BTreeMap">BTreeMap</a>&lt;K, V&gt;</code></li>
<li><code>impl&lt;T&gt; IntoIterator for <a class="struct" href="../../std/collections/btree_set/struct.BTreeSet.html" title="std::collections::btree_set::BTreeSet">BTreeSet</a>&lt;T&gt;</code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="struct" href="../../std/collections/btree_set/struct.BTreeSet.html" title="std::collections::btree_set::BTreeSet">BTreeSet</a>&lt;T&gt;</code></li>
<li><code>impl&lt;'a, E&gt; IntoIterator for &amp;'a <a class="struct" href="../../collections/enum_set/struct.EnumSet.html" title="collections::enum_set::EnumSet">EnumSet</a>&lt;E&gt; <span class="where">where E: <a class="trait" href="../../collections/enum_set/trait.CLike.html" title="collections::enum_set::CLike">CLike</a></span></code></li>
<li><code>impl&lt;T&gt; IntoIterator for <a class="struct" href="../../std/collections/linked_list/struct.LinkedList.html" title="std::collections::linked_list::LinkedList">LinkedList</a>&lt;T&gt;</code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="struct" href="../../std/collections/linked_list/struct.LinkedList.html" title="std::collections::linked_list::LinkedList">LinkedList</a>&lt;T&gt;</code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="struct" href="../../std/collections/linked_list/struct.LinkedList.html" title="std::collections::linked_list::LinkedList">LinkedList</a>&lt;T&gt;</code></li>
<li><code>impl&lt;T&gt; IntoIterator for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;</code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;</code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;</code></li>
<li><code>impl&lt;T&gt; IntoIterator for <a class="struct" href="../../std/collections/vec_deque/struct.VecDeque.html" title="std::collections::vec_deque::VecDeque">VecDeque</a>&lt;T&gt;</code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="struct" href="../../std/collections/vec_deque/struct.VecDeque.html" title="std::collections::vec_deque::VecDeque">VecDeque</a>&lt;T&gt;</code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a mut <a class="struct" href="../../std/collections/vec_deque/struct.VecDeque.html" title="std::collections::vec_deque::VecDeque">VecDeque</a>&lt;T&gt;</code></li>
<li><code>impl&lt;'a, K, V, S&gt; IntoIterator for &amp;'a <a class="struct" href="../../std/collections/struct.HashMap.html" title="std::collections::HashMap">HashMap</a>&lt;K, V, S&gt; <span class="where">where K: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a> + <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, S: <a class="trait" href="../../std/hash/trait.BuildHasher.html" title="std::hash::BuildHasher">BuildHasher</a></span></code></li>
<li><code>impl&lt;'a, K, V, S&gt; IntoIterator for &amp;'a mut <a class="struct" href="../../std/collections/struct.HashMap.html" title="std::collections::HashMap">HashMap</a>&lt;K, V, S&gt; <span class="where">where K: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a> + <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, S: <a class="trait" href="../../std/hash/trait.BuildHasher.html" title="std::hash::BuildHasher">BuildHasher</a></span></code></li>
<li><code>impl&lt;K, V, S&gt; IntoIterator for <a class="struct" href="../../std/collections/struct.HashMap.html" title="std::collections::HashMap">HashMap</a>&lt;K, V, S&gt; <span class="where">where K: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a> + <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, S: <a class="trait" href="../../std/hash/trait.BuildHasher.html" title="std::hash::BuildHasher">BuildHasher</a></span></code></li>
<li><code>impl&lt;'a, T, S&gt; IntoIterator for &amp;'a <a class="struct" href="../../std/collections/struct.HashSet.html" title="std::collections::HashSet">HashSet</a>&lt;T, S&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a> + <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, S: <a class="trait" href="../../std/hash/trait.BuildHasher.html" title="std::hash::BuildHasher">BuildHasher</a></span></code></li>
<li><code>impl&lt;T, S&gt; IntoIterator for <a class="struct" href="../../std/collections/struct.HashSet.html" title="std::collections::HashSet">HashSet</a>&lt;T, S&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a> + <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, S: <a class="trait" href="../../std/hash/trait.BuildHasher.html" title="std::hash::BuildHasher">BuildHasher</a></span></code></li>
<li><code>impl&lt;'a&gt; IntoIterator for &amp;'a <a class="struct" href="../../std/os/unix/net/struct.UnixListener.html" title="std::os::unix::net::UnixListener">UnixListener</a></code></li>
<li><code>impl&lt;'a&gt; IntoIterator for &amp;'a <a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a></code></li>
<li><code>impl&lt;'a&gt; IntoIterator for &amp;'a <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, T&gt; IntoIterator for &amp;'a <a class="struct" href="../../std/sync/mpsc/struct.Receiver.html" title="std::sync::mpsc::Receiver">Receiver</a>&lt;T&gt;</code></li>
<li><code>impl&lt;T&gt; IntoIterator for <a class="struct" href="../../std/sync/mpsc/struct.Receiver.html" title="std::sync::mpsc::Receiver">Receiver</a>&lt;T&gt;</code></li>
</ul><script src="../../implementors/core/iter/traits/trait.IntoIterator.js" async="" type="text/javascript">
                 </script></div></div><div class="outerdoc" id="trait.FromIterator"><div class="docblock" id="trait.FromIterator">
<h1 class="fqn"><span class="in-band">Trait <a href="../">std</a>::<wbr><a href="index.html">iter</a>::<wbr><a class="trait" href="">FromIterator</a></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><span id="render-detail">
                   <a href="javascript:void(0)" id="toggle-all-docs" title="collapse all docs">
                       [<span class="inner"></span>]
                   </a>
               </span><a class="srclink" href="../../core/iter/traits/trait.FromIterator.html?gotosrc=31709" id="src-31709" title="goto source code">[src]</a></span></h1>
<pre class="rust trait">pub trait FromIterator&lt;A&gt; {
    fn <a class="fnname" href="#tymethod.from_iter">from_iter</a>&lt;T&gt;(iter: T) -&gt; Self <span class="where">where T: <a class="trait" href="../../std/iter/trait.IntoIterator.html" title="std::iter::IntoIterator">IntoIterator</a>&lt;Item=A&gt;</span>;
}</pre><div class="docblock"><p>Conversion from an <code>Iterator</code>.</p>

<p>By implementing <code>FromIterator</code> for a type, you define how it will be
created from an iterator. This is common for types which describe a
collection of some kind.</p>

<p><code>FromIterator</code>'s <a href="#tymethod.from_iter"><code>from_iter()</code></a> is rarely called explicitly, and is instead
used through <a href="trait.Iterator.html"><code>Iterator</code></a>'s <a href="trait.Iterator.html#method.collect"><code>collect()</code></a> method. See <a href="trait.Iterator.html#method.collect"><code>collect()</code></a>'s
documentation for more examples.</p>

<p>See also: <a href="trait.IntoIterator.html"><code>IntoIterator</code></a>.</p>

<h1 class="section-header" id="examples"><a href="#examples">Examples</a></h1>
<p>Basic usage:</p>

<span class="rusttest">fn main() {
    use std::iter::FromIterator;

let five_fives = std::iter::repeat(5).take(5);

let v = Vec::from_iter(five_fives);

assert_eq!(v, vec![5, 5, 5, 5, 5]);
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">iter</span>::<span class="ident">FromIterator</span>;

<span class="kw">let</span> <span class="ident">five_fives</span> <span class="op">=</span> <span class="ident">std</span>::<span class="ident">iter</span>::<span class="ident">repeat</span>(<span class="number">5</span>).<span class="ident">take</span>(<span class="number">5</span>);

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">from_iter</span>(<span class="ident">five_fives</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]);</pre>

<p>Using <a href="trait.Iterator.html#method.collect"><code>collect()</code></a> to implicitly use <code>FromIterator</code>:</p>

<span class="rusttest">fn main() {
    let five_fives = std::iter::repeat(5).take(5);

let v: Vec&lt;i32&gt; = five_fives.collect();

assert_eq!(v, vec![5, 5, 5, 5, 5]);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">five_fives</span> <span class="op">=</span> <span class="ident">std</span>::<span class="ident">iter</span>::<span class="ident">repeat</span>(<span class="number">5</span>).<span class="ident">take</span>(<span class="number">5</span>);

<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">five_fives</span>.<span class="ident">collect</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]);</pre>

<p>Implementing <code>FromIterator</code> for your type:</p>

<span class="rusttest">fn main() {
    use std::iter::FromIterator;

// A sample collection, that's just a wrapper over Vec&lt;T&gt;
#[derive(Debug)]
struct MyCollection(Vec&lt;i32&gt;);

// Let's give it some methods so we can create one and add things
// to it.
impl MyCollection {
    fn new() -&gt; MyCollection {
        MyCollection(Vec::new())
    }

    fn add(&amp;mut self, elem: i32) {
        self.0.push(elem);
    }
}

// and we'll implement FromIterator
impl FromIterator&lt;i32&gt; for MyCollection {
    fn from_iter&lt;I: IntoIterator&lt;Item=i32&gt;&gt;(iter: I) -&gt; Self {
        let mut c = MyCollection::new();

        for i in iter {
            c.add(i);
        }

        c
    }
}

// Now we can make a new iterator...
let iter = (0..5).into_iter();

// ... and make a MyCollection out of it
let c = MyCollection::from_iter(iter);

assert_eq!(c.0, vec![0, 1, 2, 3, 4]);

// collect works too!

let iter = (0..5).into_iter();
let c: MyCollection = iter.collect();

assert_eq!(c.0, vec![0, 1, 2, 3, 4]);
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">iter</span>::<span class="ident">FromIterator</span>;

<span class="comment">// A sample collection, that's just a wrapper over Vec&lt;T&gt;</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyCollection</span>(<span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span>);

<span class="comment">// Let's give it some methods so we can create one and add things</span>
<span class="comment">// to it.</span>
<span class="kw">impl</span> <span class="ident">MyCollection</span> {
    <span class="kw">fn</span> <span class="ident">new</span>() <span class="op">-&gt;</span> <span class="ident">MyCollection</span> {
        <span class="ident">MyCollection</span>(<span class="ident">Vec</span>::<span class="ident">new</span>())
    }

    <span class="kw">fn</span> <span class="ident">add</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="self">self</span>, <span class="ident">elem</span>: <span class="ident">i32</span>) {
        <span class="self">self</span>.<span class="number">0</span>.<span class="ident">push</span>(<span class="ident">elem</span>);
    }
}

<span class="comment">// and we'll implement FromIterator</span>
<span class="kw">impl</span> <span class="ident">FromIterator</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">MyCollection</span> {
    <span class="kw">fn</span> <span class="ident">from_iter</span><span class="op">&lt;</span><span class="ident">I</span>: <span class="ident">IntoIterator</span><span class="op">&lt;</span><span class="ident">Item</span><span class="op">=</span><span class="ident">i32</span><span class="op">&gt;&gt;</span>(<span class="ident">iter</span>: <span class="ident">I</span>) <span class="op">-&gt;</span> <span class="self">Self</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">MyCollection</span>::<span class="ident">new</span>();

        <span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="ident">iter</span> {
            <span class="ident">c</span>.<span class="ident">add</span>(<span class="ident">i</span>);
        }

        <span class="ident">c</span>
    }
}

<span class="comment">// Now we can make a new iterator...</span>
<span class="kw">let</span> <span class="ident">iter</span> <span class="op">=</span> (<span class="number">0</span>..<span class="number">5</span>).<span class="ident">into_iter</span>();

<span class="comment">// ... and make a MyCollection out of it</span>
<span class="kw">let</span> <span class="ident">c</span> <span class="op">=</span> <span class="ident">MyCollection</span>::<span class="ident">from_iter</span>(<span class="ident">iter</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">c</span>.<span class="number">0</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);

<span class="comment">// collect works too!</span>

<span class="kw">let</span> <span class="ident">iter</span> <span class="op">=</span> (<span class="number">0</span>..<span class="number">5</span>).<span class="ident">into_iter</span>();
<span class="kw">let</span> <span class="ident">c</span>: <span class="ident">MyCollection</span> <span class="op">=</span> <span class="ident">iter</span>.<span class="ident">collect</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">c</span>.<span class="number">0</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</pre>
</div>
            <h2 id="required-methods">Required Methods</h2>
            <div class="methods">
        <h3 class="method stab " id="tymethod.from_iter"><code>fn <a class="fnname" href="#tymethod.from_iter">from_iter</a>&lt;T&gt;(iter: T) -&gt; Self <span class="where">where T: <a class="trait" href="../../std/iter/trait.IntoIterator.html" title="std::iter::IntoIterator">IntoIterator</a>&lt;Item=A&gt;</span></code></h3><div class="docblock"><p>Creates a value from an iterator.</p>

<p>See the <a href="trait.FromIterator.html">module-level documentation</a> for more.</p>

<h1 class="section-header" id="examples-1"><a href="#examples-1">Examples</a></h1>
<p>Basic usage:</p>

<span class="rusttest">fn main() {
    use std::iter::FromIterator;

let five_fives = std::iter::repeat(5).take(5);

let v = Vec::from_iter(five_fives);

assert_eq!(v, vec![5, 5, 5, 5, 5]);
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">iter</span>::<span class="ident">FromIterator</span>;

<span class="kw">let</span> <span class="ident">five_fives</span> <span class="op">=</span> <span class="ident">std</span>::<span class="ident">iter</span>::<span class="ident">repeat</span>(<span class="number">5</span>).<span class="ident">take</span>(<span class="number">5</span>);

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">from_iter</span>(<span class="ident">five_fives</span>);

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, <span class="macro">vec</span><span class="macro">!</span>[<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>]);</pre>
</div></div>
        <h2 id="implementors">Implementors</h2>
        <ul class="item-list" id="implementors-list">
    <li><code>impl&lt;A, V&gt; FromIterator&lt;<a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;A&gt;&gt; for <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;V&gt; <span class="where">where V: <a class="trait" href="../../std/iter/trait.FromIterator.html" title="std::iter::FromIterator">FromIterator</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;A, E, V&gt; FromIterator&lt;<a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;A, E&gt;&gt; for <a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;V, E&gt; <span class="where">where V: <a class="trait" href="../../std/iter/trait.FromIterator.html" title="std::iter::FromIterator">FromIterator</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;T&gt; FromIterator&lt;T&gt; for <a class="struct" href="../../std/collections/binary_heap/struct.BinaryHeap.html" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;K, V&gt; FromIterator&lt;<a class="primitive" href="../primitive.tuple.html">(</a>K, V<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="struct" href="../../std/collections/btree_map/struct.BTreeMap.html" title="std::collections::btree_map::BTreeMap">BTreeMap</a>&lt;K, V&gt; <span class="where">where K: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; FromIterator&lt;T&gt; for <a class="struct" href="../../std/collections/btree_set/struct.BTreeSet.html" title="std::collections::btree_set::BTreeSet">BTreeSet</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;E&gt; FromIterator&lt;E&gt; for <a class="struct" href="../../collections/enum_set/struct.EnumSet.html" title="collections::enum_set::EnumSet">EnumSet</a>&lt;E&gt; <span class="where">where E: <a class="trait" href="../../collections/enum_set/trait.CLike.html" title="collections::enum_set::CLike">CLike</a></span></code></li>
<li><code>impl&lt;A&gt; FromIterator&lt;A&gt; for <a class="struct" href="../../std/collections/linked_list/struct.LinkedList.html" title="std::collections::linked_list::LinkedList">LinkedList</a>&lt;A&gt;</code></li>
<li><code>impl FromIterator&lt;<a class="primitive" href="../primitive.char.html">char</a>&gt; for <a class="struct" href="../../std/string/struct.String.html" title="std::string::String">String</a></code></li>
<li><code>impl&lt;'a&gt; FromIterator&lt;&amp;'a <a class="primitive" href="../primitive.str.html">str</a>&gt; for <a class="struct" href="../../std/string/struct.String.html" title="std::string::String">String</a></code></li>
<li><code>impl FromIterator&lt;<a class="struct" href="../../std/string/struct.String.html" title="std::string::String">String</a>&gt; for <a class="struct" href="../../std/string/struct.String.html" title="std::string::String">String</a></code></li>
<li><code>impl&lt;T&gt; FromIterator&lt;T&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;</code></li>
<li><code>impl&lt;'a, T&gt; FromIterator&lt;T&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.slice.html">[</a>T<a class="primitive" href="../primitive.slice.html">]</a>&gt; <span class="where">where T: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;A&gt; FromIterator&lt;A&gt; for <a class="struct" href="../../std/collections/vec_deque/struct.VecDeque.html" title="std::collections::vec_deque::VecDeque">VecDeque</a>&lt;A&gt;</code></li>
<li><code>impl&lt;K, V, S&gt; FromIterator&lt;<a class="primitive" href="../primitive.tuple.html">(</a>K, V<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="struct" href="../../std/collections/struct.HashMap.html" title="std::collections::HashMap">HashMap</a>&lt;K, V, S&gt; <span class="where">where K: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a> + <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, S: <a class="trait" href="../../std/hash/trait.BuildHasher.html" title="std::hash::BuildHasher">BuildHasher</a> + <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T, S&gt; FromIterator&lt;T&gt; for <a class="struct" href="../../std/collections/struct.HashSet.html" title="std::collections::HashSet">HashSet</a>&lt;T, S&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a> + <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, S: <a class="trait" href="../../std/hash/trait.BuildHasher.html" title="std::hash::BuildHasher">BuildHasher</a> + <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;P: <a class="trait" href="../../std/convert/trait.AsRef.html" title="std::convert::AsRef">AsRef</a>&lt;<a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;&gt; FromIterator&lt;P&gt; for <a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a></code></li>
</ul><script src="../../implementors/core/iter/traits/trait.FromIterator.js" async="" type="text/javascript">
                 </script></div></div><div class="outerdoc" id="trait.PartialEq"><div class="docblock" id="trait.PartialEq">
<h1 class="fqn"><span class="in-band">Trait <a href="../">std</a>::<wbr><a href="index.html">cmp</a>::<wbr><a class="trait" href="">PartialEq</a></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><span id="render-detail">
                   <a href="javascript:void(0)" id="toggle-all-docs" title="collapse all docs">
                       [<span class="inner"></span>]
                   </a>
               </span><a class="srclink" href="../../core/cmp/trait.PartialEq.html?gotosrc=22474" id="src-22474" title="goto source code">[src]</a></span></h1>
<pre class="rust trait">pub trait PartialEq&lt;Rhs = Self&gt; <span class="where">where Rhs: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span> {
    fn <a class="fnname" href="#tymethod.eq">eq</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a>;

    fn <a class="fnname" href="#method.ne">ne</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a> { ... }
}</pre><div class="docblock"><p>Trait for equality comparisons which are <a href="http://en.wikipedia.org/wiki/Partial_equivalence_relation">partial equivalence
relations</a>.</p>

<p>This trait allows for partial equality, for types that do not have a full
equivalence relation.  For example, in floating point numbers <code>NaN != NaN</code>,
so floating point types implement <code>PartialEq</code> but not <code>Eq</code>.</p>

<p>Formally, the equality must be (for all <code>a</code>, <code>b</code> and <code>c</code>):</p>

<ul>
<li>symmetric: <code>a == b</code> implies <code>b == a</code>; and</li>
<li>transitive: <code>a == b</code> and <code>b == c</code> implies <code>a == c</code>.</li>
</ul>

<p>Note that these requirements mean that the trait itself must be implemented
symmetrically and transitively: if <code>T: PartialEq&lt;U&gt;</code> and <code>U: PartialEq&lt;V&gt;</code>
then <code>U: PartialEq&lt;T&gt;</code> and <code>T: PartialEq&lt;V&gt;</code>.</p>

<p>PartialEq only requires the <code>eq</code> method to be implemented; <code>ne</code> is defined
in terms of it by default. Any manual implementation of <code>ne</code> <em>must</em> respect
the rule that <code>eq</code> is a strict inverse of <code>ne</code>; that is, <code>!(a == b)</code> if and
only if <code>a != b</code>.</p>

<p>This trait can be used with <code>#[derive]</code>.</p>

<h1 class="section-header" id="examples"><a href="#examples">Examples</a></h1>
<span class="rusttest">fn main() {
    let x: u32 = 0;
let y: u32 = 1;

assert_eq!(x == y, false);
assert_eq!(x.eq(&amp;y), false);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">x</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="number">0</span>;
<span class="kw">let</span> <span class="ident">y</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="number">1</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span> <span class="op">==</span> <span class="ident">y</span>, <span class="boolvalue">false</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">eq</span>(<span class="kw-2">&amp;</span><span class="ident">y</span>), <span class="boolvalue">false</span>);</pre>
</div>
            <h2 id="required-methods">Required Methods</h2>
            <div class="methods">
        <h3 class="method stab " id="tymethod.eq"><code>fn <a class="fnname" href="#tymethod.eq">eq</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h3><div class="docblock"><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used
by <code>==</code>.</p>
</div></div>
            <h2 id="provided-methods">Provided Methods</h2>
            <div class="methods">
        <h3 class="method stab " id="method.ne"><code>fn <a class="fnname" href="#method.ne">ne</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h3><div class="docblock"><p>This method tests for <code>!=</code>.</p>
</div></div>
        <h2 id="implementors">Implementors</h2>
        <ul class="item-list" id="implementors-list">
    <li><code>impl&lt;T&gt; PartialEq&lt;<a class="struct" href="../../std/num/struct.Wrapping.html" title="std::num::Wrapping">Wrapping</a>&lt;T&gt;&gt; for <a class="struct" href="../../std/num/struct.Wrapping.html" title="std::num::Wrapping">Wrapping</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;T&gt;</span></code></li>
<li><code>impl PartialEq&lt;<a class="struct" href="../../std/num/struct.ParseFloatError.html" title="std::num::ParseFloatError">ParseFloatError</a>&gt; for <a class="struct" href="../../std/num/struct.ParseFloatError.html" title="std::num::ParseFloatError">ParseFloatError</a></code></li>
<li><code>impl PartialEq&lt;<a class="enum" href="../../std/num/enum.FpCategory.html" title="std::num::FpCategory">FpCategory</a>&gt; for <a class="enum" href="../../std/num/enum.FpCategory.html" title="std::num::FpCategory">FpCategory</a></code></li>
<li><code>impl PartialEq&lt;<a class="struct" href="../../std/num/struct.ParseIntError.html" title="std::num::ParseIntError">ParseIntError</a>&gt; for <a class="struct" href="../../std/num/struct.ParseIntError.html" title="std::num::ParseIntError">ParseIntError</a></code></li>
<li><code>impl&lt;T&gt; PartialEq&lt;<a class="struct" href="../../core/nonzero/struct.NonZero.html" title="core::nonzero::NonZero">NonZero</a>&lt;T&gt;&gt; for <a class="struct" href="../../core/nonzero/struct.NonZero.html" title="core::nonzero::NonZero">NonZero</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../core/nonzero/trait.Zeroable.html" title="core::nonzero::Zeroable">Zeroable</a> + <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialEq&lt;<a class="primitive" href="../primitive.pointer.html">*const T</a>&gt; for <a class="primitive" href="../primitive.pointer.html">*const T</a> <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; PartialEq&lt;<a class="primitive" href="../primitive.pointer.html">*mut T</a>&gt; for <a class="primitive" href="../primitive.pointer.html">*mut T</a> <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;Ret&gt; PartialEq&lt;fn() -&gt; Ret&gt; for fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret&gt; PartialEq&lt;extern fn() -&gt; Ret&gt; for extern fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret&gt; PartialEq&lt;unsafe fn() -&gt; Ret&gt; for unsafe fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret&gt; PartialEq&lt;unsafe extern fn() -&gt; Ret&gt; for unsafe extern fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A&gt; PartialEq&lt;fn(A) -&gt; Ret&gt; for fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A&gt; PartialEq&lt;extern fn(A) -&gt; Ret&gt; for extern fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A&gt; PartialEq&lt;unsafe fn(A) -&gt; Ret&gt; for unsafe fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A&gt; PartialEq&lt;unsafe extern fn(A) -&gt; Ret&gt; for unsafe extern fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B&gt; PartialEq&lt;fn(A, B) -&gt; Ret&gt; for fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B&gt; PartialEq&lt;extern fn(A, B) -&gt; Ret&gt; for extern fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B&gt; PartialEq&lt;unsafe fn(A, B) -&gt; Ret&gt; for unsafe fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B&gt; PartialEq&lt;unsafe extern fn(A, B) -&gt; Ret&gt; for unsafe extern fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C&gt; PartialEq&lt;fn(A, B, C) -&gt; Ret&gt; for fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C&gt; PartialEq&lt;extern fn(A, B, C) -&gt; Ret&gt; for extern fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C&gt; PartialEq&lt;unsafe fn(A, B, C) -&gt; Ret&gt; for unsafe fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C&gt; PartialEq&lt;unsafe extern fn(A, B, C) -&gt; Ret&gt; for unsafe extern fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D&gt; PartialEq&lt;fn(A, B, C, D) -&gt; Ret&gt; for fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D&gt; PartialEq&lt;extern fn(A, B, C, D) -&gt; Ret&gt; for extern fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D&gt; PartialEq&lt;unsafe fn(A, B, C, D) -&gt; Ret&gt; for unsafe fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D&gt; PartialEq&lt;unsafe extern fn(A, B, C, D) -&gt; Ret&gt; for unsafe extern fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E&gt; PartialEq&lt;fn(A, B, C, D, E) -&gt; Ret&gt; for fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E&gt; PartialEq&lt;extern fn(A, B, C, D, E) -&gt; Ret&gt; for extern fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E&gt; PartialEq&lt;unsafe fn(A, B, C, D, E) -&gt; Ret&gt; for unsafe fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E&gt; PartialEq&lt;unsafe extern fn(A, B, C, D, E) -&gt; Ret&gt; for unsafe extern fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F&gt; PartialEq&lt;fn(A, B, C, D, E, F) -&gt; Ret&gt; for fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F&gt; PartialEq&lt;extern fn(A, B, C, D, E, F) -&gt; Ret&gt; for extern fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F&gt; PartialEq&lt;unsafe fn(A, B, C, D, E, F) -&gt; Ret&gt; for unsafe fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F&gt; PartialEq&lt;unsafe extern fn(A, B, C, D, E, F) -&gt; Ret&gt; for unsafe extern fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G&gt; PartialEq&lt;fn(A, B, C, D, E, F, G) -&gt; Ret&gt; for fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G&gt; PartialEq&lt;extern fn(A, B, C, D, E, F, G) -&gt; Ret&gt; for extern fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G&gt; PartialEq&lt;unsafe fn(A, B, C, D, E, F, G) -&gt; Ret&gt; for unsafe fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G&gt; PartialEq&lt;unsafe extern fn(A, B, C, D, E, F, G) -&gt; Ret&gt; for unsafe extern fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H&gt; PartialEq&lt;fn(A, B, C, D, E, F, G, H) -&gt; Ret&gt; for fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H&gt; PartialEq&lt;extern fn(A, B, C, D, E, F, G, H) -&gt; Ret&gt; for extern fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H&gt; PartialEq&lt;unsafe fn(A, B, C, D, E, F, G, H) -&gt; Ret&gt; for unsafe fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H&gt; PartialEq&lt;unsafe extern fn(A, B, C, D, E, F, G, H) -&gt; Ret&gt; for unsafe extern fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I&gt; PartialEq&lt;fn(A, B, C, D, E, F, G, H, I) -&gt; Ret&gt; for fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I&gt; PartialEq&lt;extern fn(A, B, C, D, E, F, G, H, I) -&gt; Ret&gt; for extern fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I&gt; PartialEq&lt;unsafe fn(A, B, C, D, E, F, G, H, I) -&gt; Ret&gt; for unsafe fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I&gt; PartialEq&lt;unsafe extern fn(A, B, C, D, E, F, G, H, I) -&gt; Ret&gt; for unsafe extern fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J&gt; PartialEq&lt;fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret&gt; for fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J&gt; PartialEq&lt;extern fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret&gt; for extern fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J&gt; PartialEq&lt;unsafe fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret&gt; for unsafe fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J&gt; PartialEq&lt;unsafe extern fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret&gt; for unsafe extern fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K&gt; PartialEq&lt;fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret&gt; for fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K&gt; PartialEq&lt;extern fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret&gt; for extern fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K&gt; PartialEq&lt;unsafe fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret&gt; for unsafe fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K&gt; PartialEq&lt;unsafe extern fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret&gt; for unsafe extern fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K, L&gt; PartialEq&lt;fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret&gt; for fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K, L&gt; PartialEq&lt;extern fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret&gt; for extern fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K, L&gt; PartialEq&lt;unsafe fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret&gt; for unsafe fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K, L&gt; PartialEq&lt;unsafe extern fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret&gt; for unsafe extern fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;T&gt; PartialEq&lt;<a class="struct" href="../../std/marker/struct.PhantomData.html" title="std::marker::PhantomData">PhantomData</a>&lt;T&gt;&gt; for <a class="struct" href="../../std/marker/struct.PhantomData.html" title="std::marker::PhantomData">PhantomData</a>&lt;T&gt; <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl PartialEq&lt;<a class="struct" href="../../std/ops/struct.RangeFull.html" title="std::ops::RangeFull">RangeFull</a>&gt; for <a class="struct" href="../../std/ops/struct.RangeFull.html" title="std::ops::RangeFull">RangeFull</a></code></li>
<li><code>impl&lt;Idx&gt; PartialEq&lt;<a class="struct" href="../../std/ops/struct.Range.html" title="std::ops::Range">Range</a>&lt;Idx&gt;&gt; for <a class="struct" href="../../std/ops/struct.Range.html" title="std::ops::Range">Range</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;Idx&gt;</span></code></li>
<li><code>impl&lt;Idx&gt; PartialEq&lt;<a class="struct" href="../../std/ops/struct.RangeFrom.html" title="std::ops::RangeFrom">RangeFrom</a>&lt;Idx&gt;&gt; for <a class="struct" href="../../std/ops/struct.RangeFrom.html" title="std::ops::RangeFrom">RangeFrom</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;Idx&gt;</span></code></li>
<li><code>impl&lt;Idx&gt; PartialEq&lt;<a class="struct" href="../../std/ops/struct.RangeTo.html" title="std::ops::RangeTo">RangeTo</a>&lt;Idx&gt;&gt; for <a class="struct" href="../../std/ops/struct.RangeTo.html" title="std::ops::RangeTo">RangeTo</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;Idx&gt;</span></code></li>
<li><code>impl&lt;Idx&gt; PartialEq&lt;<a class="enum" href="../../std/ops/enum.RangeInclusive.html" title="std::ops::RangeInclusive">RangeInclusive</a>&lt;Idx&gt;&gt; for <a class="enum" href="../../std/ops/enum.RangeInclusive.html" title="std::ops::RangeInclusive">RangeInclusive</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;Idx&gt;</span></code></li>
<li><code>impl&lt;Idx&gt; PartialEq&lt;<a class="struct" href="../../std/ops/struct.RangeToInclusive.html" title="std::ops::RangeToInclusive">RangeToInclusive</a>&lt;Idx&gt;&gt; for <a class="struct" href="../../std/ops/struct.RangeToInclusive.html" title="std::ops::RangeToInclusive">RangeToInclusive</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;Idx&gt;</span></code></li>
<li><code>impl PartialEq&lt;<a class="enum" href="../../std/cmp/enum.Ordering.html" title="std::cmp::Ordering">Ordering</a>&gt; for <a class="enum" href="../../std/cmp/enum.Ordering.html" title="std::cmp::Ordering">Ordering</a></code></li>
<li><code>impl PartialEq&lt;<a class="primitive" href="../primitive.tuple.html">()</a>&gt; for <a class="primitive" href="../primitive.tuple.html">()</a></code></li>
<li><code>impl PartialEq&lt;<a class="primitive" href="../primitive.bool.html">bool</a>&gt; for <a class="primitive" href="../primitive.bool.html">bool</a></code></li>
<li><code>impl PartialEq&lt;<a class="primitive" href="../primitive.char.html">char</a>&gt; for <a class="primitive" href="../primitive.char.html">char</a></code></li>
<li><code>impl PartialEq&lt;<a class="primitive" href="../primitive.usize.html">usize</a>&gt; for <a class="primitive" href="../primitive.usize.html">usize</a></code></li>
<li><code>impl PartialEq&lt;<a class="primitive" href="../primitive.u8.html">u8</a>&gt; for <a class="primitive" href="../primitive.u8.html">u8</a></code></li>
<li><code>impl PartialEq&lt;<a class="primitive" href="../primitive.u16.html">u16</a>&gt; for <a class="primitive" href="../primitive.u16.html">u16</a></code></li>
<li><code>impl PartialEq&lt;<a class="primitive" href="../primitive.u32.html">u32</a>&gt; for <a class="primitive" href="../primitive.u32.html">u32</a></code></li>
<li><code>impl PartialEq&lt;<a class="primitive" href="../primitive.u64.html">u64</a>&gt; for <a class="primitive" href="../primitive.u64.html">u64</a></code></li>
<li><code>impl PartialEq&lt;<a class="primitive" href="../primitive.isize.html">isize</a>&gt; for <a class="primitive" href="../primitive.isize.html">isize</a></code></li>
<li><code>impl PartialEq&lt;<a class="primitive" href="../primitive.i8.html">i8</a>&gt; for <a class="primitive" href="../primitive.i8.html">i8</a></code></li>
<li><code>impl PartialEq&lt;<a class="primitive" href="../primitive.i16.html">i16</a>&gt; for <a class="primitive" href="../primitive.i16.html">i16</a></code></li>
<li><code>impl PartialEq&lt;<a class="primitive" href="../primitive.i32.html">i32</a>&gt; for <a class="primitive" href="../primitive.i32.html">i32</a></code></li>
<li><code>impl PartialEq&lt;<a class="primitive" href="../primitive.i64.html">i64</a>&gt; for <a class="primitive" href="../primitive.i64.html">i64</a></code></li>
<li><code>impl PartialEq&lt;<a class="primitive" href="../primitive.f32.html">f32</a>&gt; for <a class="primitive" href="../primitive.f32.html">f32</a></code></li>
<li><code>impl PartialEq&lt;<a class="primitive" href="../primitive.f64.html">f64</a>&gt; for <a class="primitive" href="../primitive.f64.html">f64</a></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b B&gt; for &amp;'a A <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt; + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a>, B: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b mut B&gt; for &amp;'a mut A <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt; + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a>, B: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b mut B&gt; for &amp;'a A <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt; + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a>, B: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b B&gt; for &amp;'a mut A <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt; + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a>, B: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl PartialEq&lt;<a class="struct" href="../../std/any/struct.TypeId.html" title="std::any::TypeId">TypeId</a>&gt; for <a class="struct" href="../../std/any/struct.TypeId.html" title="std::any::TypeId">TypeId</a></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 0]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 0]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 0]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 0]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 0]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 0]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 0]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 0]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 1]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 1]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 1]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 1]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 1]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 1]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 1]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 1]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 2]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 2]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 2]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 2]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 2]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 2]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 2]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 2]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 3]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 3]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 3]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 3]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 3]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 3]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 3]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 3]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 4]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 4]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 4]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 4]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 4]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 4]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 4]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 4]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 5]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 5]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 5]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 5]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 5]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 5]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 5]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 5]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 6]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 6]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 6]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 6]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 6]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 6]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 6]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 6]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 7]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 7]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 7]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 7]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 7]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 7]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 7]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 7]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 8]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 8]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 8]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 8]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 8]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 8]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 8]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 8]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 9]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 9]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 9]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 9]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 9]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 9]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 9]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 9]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 10]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 10]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 10]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 10]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 10]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 10]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 10]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 10]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 11]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 11]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 11]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 11]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 11]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 11]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 11]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 11]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 12]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 12]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 12]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 12]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 12]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 12]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 12]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 12]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 13]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 13]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 13]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 13]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 13]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 13]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 13]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 13]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 14]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 14]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 14]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 14]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 14]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 14]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 14]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 14]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 15]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 15]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 15]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 15]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 15]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 15]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 15]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 15]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 16]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 16]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 16]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 16]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 16]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 16]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 16]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 16]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 17]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 17]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 17]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 17]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 17]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 17]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 17]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 17]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 18]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 18]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 18]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 18]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 18]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 18]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 18]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 18]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 19]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 19]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 19]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 19]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 19]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 19]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 19]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 19]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 20]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 20]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 20]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 20]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 20]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 20]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 20]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 20]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 21]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 21]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 21]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 21]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 21]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 21]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 21]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 21]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 22]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 22]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 22]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 22]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 22]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 22]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 22]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 22]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 23]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 23]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 23]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 23]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 23]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 23]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 23]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 23]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 24]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 24]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 24]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 24]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 24]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 24]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 24]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 24]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 25]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 25]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 25]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 25]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 25]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 25]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 25]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 25]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 26]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 26]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 26]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 26]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 26]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 26]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 26]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 26]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 27]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 27]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 27]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 27]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 27]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 27]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 27]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 27]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 28]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 28]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 28]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 28]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 28]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 28]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 28]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 28]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 29]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 29]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 29]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 29]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 29]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 29]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 29]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 29]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 30]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 30]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 30]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 30]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 30]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 30]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 30]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 30]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 31]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 31]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 31]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 31]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 31]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 31]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 31]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 31]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 32]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 32]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 32]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 32]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 32]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 32]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 32]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>A<a class="primitive" href="../primitive.array.html">; 32]</a>&gt; for <a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a> <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialEq&lt;<a class="struct" href="../../std/cell/struct.Cell.html" title="std::cell::Cell">Cell</a>&lt;T&gt;&gt; for <a class="struct" href="../../std/cell/struct.Cell.html" title="std::cell::Cell">Cell</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a> + <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;T&gt;</span></code></li>
<li><code>impl PartialEq&lt;<a class="enum" href="../../std/cell/enum.BorrowState.html" title="std::cell::BorrowState">BorrowState</a>&gt; for <a class="enum" href="../../std/cell/enum.BorrowState.html" title="std::cell::BorrowState">BorrowState</a></code></li>
<li><code>impl&lt;T&gt; PartialEq&lt;<a class="struct" href="../../std/cell/struct.RefCell.html" title="std::cell::RefCell">RefCell</a>&lt;T&gt;&gt; for <a class="struct" href="../../std/cell/struct.RefCell.html" title="std::cell::RefCell">RefCell</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;T&gt; + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; PartialEq&lt;<a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt;&gt; for <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T, E&gt; PartialEq&lt;<a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;T, E&gt;&gt; for <a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;T, E&gt; <span class="where">where E: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;E&gt;, T: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">[</a>B<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>A<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl PartialEq&lt;<a class="enum" href="../../std/str/pattern/enum.SearchStep.html" title="std::str::pattern::SearchStep">SearchStep</a>&gt; for <a class="enum" href="../../std/str/pattern/enum.SearchStep.html" title="std::str::pattern::SearchStep">SearchStep</a></code></li>
<li><code>impl PartialEq&lt;<a class="struct" href="../../std/str/struct.ParseBoolError.html" title="std::str::ParseBoolError">ParseBoolError</a>&gt; for <a class="struct" href="../../std/str/struct.ParseBoolError.html" title="std::str::ParseBoolError">ParseBoolError</a></code></li>
<li><code>impl PartialEq&lt;<a class="struct" href="../../std/str/struct.Utf8Error.html" title="std::str::Utf8Error">Utf8Error</a>&gt; for <a class="struct" href="../../std/str/struct.Utf8Error.html" title="std::str::Utf8Error">Utf8Error</a></code></li>
<li><code>impl PartialEq&lt;<a class="primitive" href="../primitive.str.html">str</a>&gt; for <a class="primitive" href="../primitive.str.html">str</a></code></li>
<li><code>impl PartialEq&lt;<a class="struct" href="../../std/fmt/struct.Error.html" title="std::fmt::Error">Error</a>&gt; for <a class="struct" href="../../std/fmt/struct.Error.html" title="std::fmt::Error">Error</a></code></li>
<li><code>impl&lt;A&gt; PartialEq&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A,<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A,<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A, B<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A, B<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;, B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;A, B, C&gt; PartialEq&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A, B, C<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;, B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;, C: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;C&gt;</span></code></li>
<li><code>impl&lt;A, B, C, D&gt; PartialEq&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;, B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;, C: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;C&gt;, D: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;D&gt;</span></code></li>
<li><code>impl&lt;A, B, C, D, E&gt; PartialEq&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;, B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;, C: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;C&gt;, D: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;D&gt;, E: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;E&gt;</span></code></li>
<li><code>impl&lt;A, B, C, D, E, F&gt; PartialEq&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;, B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;, C: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;C&gt;, D: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;D&gt;, E: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;E&gt;, F: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;F&gt;</span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G&gt; PartialEq&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;, B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;, C: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;C&gt;, D: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;D&gt;, E: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;E&gt;, F: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;F&gt;, G: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;G&gt;</span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G, H&gt; PartialEq&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;, B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;, C: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;C&gt;, D: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;D&gt;, E: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;E&gt;, F: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;F&gt;, G: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;G&gt;, H: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;H&gt;</span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G, H, I&gt; PartialEq&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;, B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;, C: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;C&gt;, D: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;D&gt;, E: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;E&gt;, F: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;F&gt;, G: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;G&gt;, H: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;H&gt;, I: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;I&gt;</span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G, H, I, J&gt; PartialEq&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;, B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;, C: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;C&gt;, D: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;D&gt;, E: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;E&gt;, F: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;F&gt;, G: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;G&gt;, H: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;H&gt;, I: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;I&gt;, J: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;J&gt;</span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G, H, I, J, K&gt; PartialEq&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J, K<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J, K<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;, B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;, C: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;C&gt;, D: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;D&gt;, E: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;E&gt;, F: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;F&gt;, G: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;G&gt;, H: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;H&gt;, I: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;I&gt;, J: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;J&gt;, K: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;K&gt;</span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G, H, I, J, K, L&gt; PartialEq&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J, K, L<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J, K, L<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;, B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;, C: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;C&gt;, D: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;D&gt;, E: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;E&gt;, F: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;F&gt;, G: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;G&gt;, H: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;H&gt;, I: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;I&gt;, J: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;J&gt;, K: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;K&gt;, L: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;L&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialEq&lt;<a class="struct" href="../../std/boxed/struct.Box.html" title="std::boxed::Box">Box</a>&lt;T&gt;&gt; for <a class="struct" href="../../std/boxed/struct.Box.html" title="std::boxed::Box">Box</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;T&gt; + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; PartialEq&lt;<a class="struct" href="../../std/sync/struct.Arc.html" title="std::sync::Arc">Arc</a>&lt;T&gt;&gt; for <a class="struct" href="../../std/sync/struct.Arc.html" title="std::sync::Arc">Arc</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;T&gt; + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; PartialEq&lt;<a class="struct" href="../../std/rc/struct.Rc.html" title="std::rc::Rc">Rc</a>&lt;T&gt;&gt; for <a class="struct" href="../../std/rc/struct.Rc.html" title="std::rc::Rc">Rc</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;T&gt; + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;K, V&gt; PartialEq&lt;<a class="struct" href="../../std/collections/btree_map/struct.BTreeMap.html" title="std::collections::btree_map::BTreeMap">BTreeMap</a>&lt;K, V&gt;&gt; for <a class="struct" href="../../std/collections/btree_map/struct.BTreeMap.html" title="std::collections::btree_map::BTreeMap">BTreeMap</a>&lt;K, V&gt; <span class="where">where K: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;K&gt;, V: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;V&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialEq&lt;<a class="struct" href="../../std/collections/btree_set/struct.BTreeSet.html" title="std::collections::btree_set::BTreeSet">BTreeSet</a>&lt;T&gt;&gt; for <a class="struct" href="../../std/collections/btree_set/struct.BTreeSet.html" title="std::collections::btree_set::BTreeSet">BTreeSet</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, B, C&gt; PartialEq&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'b, C&gt;&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, B&gt; <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;C&gt; + <a class="trait" href="../../std/borrow/trait.ToOwned.html" title="std::borrow::ToOwned">ToOwned</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a>, C: <a class="trait" href="../../std/borrow/trait.ToOwned.html" title="std::borrow::ToOwned">ToOwned</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;E&gt; PartialEq&lt;<a class="struct" href="../../collections/enum_set/struct.EnumSet.html" title="collections::enum_set::EnumSet">EnumSet</a>&lt;E&gt;&gt; for <a class="struct" href="../../collections/enum_set/struct.EnumSet.html" title="collections::enum_set::EnumSet">EnumSet</a>&lt;E&gt; <span class="where">where E: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;E&gt;</span></code></li>
<li><code>impl&lt;A&gt; PartialEq&lt;<a class="struct" href="../../std/collections/linked_list/struct.LinkedList.html" title="std::collections::linked_list::LinkedList">LinkedList</a>&lt;A&gt;&gt; for <a class="struct" href="../../std/collections/linked_list/struct.LinkedList.html" title="std::collections::linked_list::LinkedList">LinkedList</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl PartialEq&lt;<a class="struct" href="../../std/string/struct.String.html" title="std::string::String">String</a>&gt; for <a class="struct" href="../../std/string/struct.String.html" title="std::string::String">String</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="primitive" href="../primitive.str.html">str</a>&gt; for <a class="struct" href="../../std/string/struct.String.html" title="std::string::String">String</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/string/struct.String.html" title="std::string::String">String</a>&gt; for <a class="primitive" href="../primitive.str.html">str</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;&amp;'a <a class="primitive" href="../primitive.str.html">str</a>&gt; for <a class="struct" href="../../std/string/struct.String.html" title="std::string::String">String</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/string/struct.String.html" title="std::string::String">String</a>&gt; for &amp;'a <a class="primitive" href="../primitive.str.html">str</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="primitive" href="../primitive.str.html">str</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str.html">str</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str.html">str</a>&gt;&gt; for <a class="primitive" href="../primitive.str.html">str</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.str.html">str</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str.html">str</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str.html">str</a>&gt;&gt; for &amp;'b <a class="primitive" href="../primitive.str.html">str</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/string/struct.String.html" title="std::string::String">String</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str.html">str</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.str.html">str</a>&gt;&gt; for <a class="struct" href="../../std/string/struct.String.html" title="std::string::String">String</a></code></li>
<li><code>impl PartialEq&lt;<a class="enum" href="../../std/string/enum.ParseError.html" title="std::string::ParseError">ParseError</a>&gt; for <a class="enum" href="../../std/string/enum.ParseError.html" title="std::string::ParseError">ParseError</a></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;B&gt;&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b [B]</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.slice.html">[</a>A<a class="primitive" href="../primitive.slice.html">]</a>&gt; <span class="where">where A: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a> + <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.slice.html">&amp;'b mut [B]</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.slice.html">[</a>A<a class="primitive" href="../primitive.slice.html">]</a>&gt; <span class="where">where A: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a> + <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;B&gt;&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="primitive" href="../primitive.slice.html">[</a>A<a class="primitive" href="../primitive.slice.html">]</a>&gt; <span class="where">where A: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a> + <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 0]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 0]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 1]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 1]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 2]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 2]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 3]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 3]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 4]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 4]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 5]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 5]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 6]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 6]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 7]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 7]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 8]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 8]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 9]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 9]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 10]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 10]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 11]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 11]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 12]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 12]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 13]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 13]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 14]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 14]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 15]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 15]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 16]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 16]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 17]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 17]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 18]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 18]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 19]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 19]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 20]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 20]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 21]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 21]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 22]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 22]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 23]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 23]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 24]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 24]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 25]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 25]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 26]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 26]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 27]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 27]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 28]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 28]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 29]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 29]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 30]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 30]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 31]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 31]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;<a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 32]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialEq&lt;&amp;'b <a class="primitive" href="../primitive.array.html">[</a>B<a class="primitive" href="../primitive.array.html">; 32]</a>&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;A&gt; PartialEq&lt;<a class="struct" href="../../std/collections/vec_deque/struct.VecDeque.html" title="std::collections::vec_deque::VecDeque">VecDeque</a>&lt;A&gt;&gt; for <a class="struct" href="../../std/collections/vec_deque/struct.VecDeque.html" title="std::collections::vec_deque::VecDeque">VecDeque</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialEq&lt;<a class="enum" href="../../std/collections/enum.Bound.html" title="std::collections::Bound">Bound</a>&lt;T&gt;&gt; for <a class="enum" href="../../std/collections/enum.Bound.html" title="std::collections::Bound">Bound</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;T&gt;</span></code></li>
<li><code>impl PartialEq&lt;<a class="struct" href="../../std/char/struct.DecodeUtf16Error.html" title="std::char::DecodeUtf16Error">DecodeUtf16Error</a>&gt; for <a class="struct" href="../../std/char/struct.DecodeUtf16Error.html" title="std::char::DecodeUtf16Error">DecodeUtf16Error</a></code></li>
<li><code>impl PartialEq for <a class="enum" href="../../std/thread/enum.LocalKeyState.html" title="std::thread::LocalKeyState">LocalKeyState</a></code></li>
<li><code>impl&lt;K, V, S&gt; PartialEq for <a class="struct" href="../../std/collections/struct.HashMap.html" title="std::collections::HashMap">HashMap</a>&lt;K, V, S&gt; <span class="where">where K: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a> + <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, V: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>, S: <a class="trait" href="../../std/hash/trait.BuildHasher.html" title="std::hash::BuildHasher">BuildHasher</a></span></code></li>
<li><code>impl&lt;T, S&gt; PartialEq for <a class="struct" href="../../std/collections/struct.HashSet.html" title="std::collections::HashSet">HashSet</a>&lt;T, S&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a> + <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, S: <a class="trait" href="../../std/hash/trait.BuildHasher.html" title="std::hash::BuildHasher">BuildHasher</a></span></code></li>
<li><code>impl PartialEq for <a class="enum" href="../../std/env/enum.VarError.html" title="std::env::VarError">VarError</a></code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/ffi/struct.CString.html" title="std::ffi::CString">CString</a></code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/ffi/struct.NulError.html" title="std::ffi::NulError">NulError</a></code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/ffi/struct.FromBytesWithNulError.html" title="std::ffi::FromBytesWithNulError">FromBytesWithNulError</a></code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/ffi/struct.IntoStringError.html" title="std::ffi::IntoStringError">IntoStringError</a></code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/ffi/struct.CStr.html" title="std::ffi::CStr">CStr</a></code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl PartialEq&lt;<a class="primitive" href="../primitive.str.html">str</a>&gt; for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl PartialEq&lt;<a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a>&gt; for <a class="primitive" href="../primitive.str.html">str</a></code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl PartialEq&lt;<a class="primitive" href="../primitive.str.html">str</a>&gt; for <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl PartialEq&lt;<a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="primitive" href="../primitive.str.html">str</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a>&gt; for <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;&amp;'a <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a>&gt; for &amp;'a <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;&gt; for <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;&amp;'b <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;&gt; for &amp;'b <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;&gt; for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/fs/struct.Permissions.html" title="std::fs::Permissions">Permissions</a></code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/fs/struct.FileType.html" title="std::fs::FileType">FileType</a></code></li>
<li><code>impl PartialEq for <a class="enum" href="../../std/io/enum.ErrorKind.html" title="std::io::ErrorKind">ErrorKind</a></code></li>
<li><code>impl PartialEq for <a class="enum" href="../../std/io/enum.SeekFrom.html" title="std::io::SeekFrom">SeekFrom</a></code></li>
<li><code>impl PartialEq for <a class="enum" href="../../std/net/enum.IpAddr.html" title="std::net::IpAddr">IpAddr</a></code></li>
<li><code>impl PartialEq for <a class="enum" href="../../std/net/enum.Ipv6MulticastScope.html" title="std::net::Ipv6MulticastScope">Ipv6MulticastScope</a></code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/net/struct.Ipv4Addr.html" title="std::net::Ipv4Addr">Ipv4Addr</a></code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/net/struct.Ipv6Addr.html" title="std::net::Ipv6Addr">Ipv6Addr</a></code></li>
<li><code>impl PartialEq for <a class="enum" href="../../std/net/enum.SocketAddr.html" title="std::net::SocketAddr">SocketAddr</a></code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/net/struct.SocketAddrV4.html" title="std::net::SocketAddrV4">SocketAddrV4</a></code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/net/struct.SocketAddrV6.html" title="std::net::SocketAddrV6">SocketAddrV6</a></code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/net/struct.AddrParseError.html" title="std::net::AddrParseError">AddrParseError</a></code></li>
<li><code>impl PartialEq for <a class="enum" href="../../std/net/enum.Shutdown.html" title="std::net::Shutdown">Shutdown</a></code></li>
<li><code>impl&lt;'a&gt; PartialEq for <a class="enum" href="../../std/path/enum.Prefix.html" title="std::path::Prefix">Prefix</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; PartialEq for <a class="struct" href="../../std/path/struct.PrefixComponent.html" title="std::path::PrefixComponent">PrefixComponent</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; PartialEq for <a class="enum" href="../../std/path/enum.Component.html" title="std::path::Component">Component</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; PartialEq for <a class="struct" href="../../std/path/struct.Components.html" title="std::path::Components">Components</a>&lt;'a&gt;</code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a></code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/path/struct.StripPrefixError.html" title="std::path::StripPrefixError">StripPrefixError</a></code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt; for <a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a>&gt; for <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;&amp;'a <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt; for <a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a>&gt; for &amp;'a <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;&gt; for <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;&amp;'b <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;&gt; for &amp;'b <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;&gt; for <a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a>&gt; for <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;&amp;'a <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a>&gt; for &amp;'a <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;&gt; for <a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a>&gt; for <a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a>&gt; for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt; for <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;&amp;'a <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt; for &amp;'a <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;&gt; for <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a>&gt; for <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt; for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt; for &amp;'a <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;&amp;'a <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt; for <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'b, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;&gt; for &amp;'a <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;&amp;'a <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'b, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a>&gt; for &amp;'a <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;&amp;'a <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt; for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;&gt; for <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;&amp;'b <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;&gt; for &amp;'b <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialEq&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;&gt; for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/process/struct.Output.html" title="std::process::Output">Output</a></code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/process/struct.ExitStatus.html" title="std::process::ExitStatus">ExitStatus</a></code></li>
<li><code>impl&lt;T: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&gt; PartialEq for <a class="struct" href="../../std/sync/mpsc/struct.SendError.html" title="std::sync::mpsc::SendError">SendError</a>&lt;T&gt;</code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/sync/mpsc/struct.RecvError.html" title="std::sync::mpsc::RecvError">RecvError</a></code></li>
<li><code>impl PartialEq for <a class="enum" href="../../std/sync/mpsc/enum.TryRecvError.html" title="std::sync::mpsc::TryRecvError">TryRecvError</a></code></li>
<li><code>impl&lt;T: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&gt; PartialEq for <a class="enum" href="../../std/sync/mpsc/enum.TrySendError.html" title="std::sync::mpsc::TrySendError">TrySendError</a>&lt;T&gt;</code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/sync/struct.WaitTimeoutResult.html" title="std::sync::WaitTimeoutResult">WaitTimeoutResult</a></code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/time/struct.Duration.html" title="std::time::Duration">Duration</a></code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/time/struct.Instant.html" title="std::time::Instant">Instant</a></code></li>
<li><code>impl PartialEq for <a class="struct" href="../../std/time/struct.SystemTime.html" title="std::time::SystemTime">SystemTime</a></code></li>
</ul><script src="../../implementors/core/cmp/trait.PartialEq.js" async="" type="text/javascript">
                 </script></div></div><div class="outerdoc" id="trait.PartialOrd"><div class="docblock" id="trait.PartialOrd">
<h1 class="fqn"><span class="in-band">Trait <a href="../">std</a>::<wbr><a href="index.html">cmp</a>::<wbr><a class="trait" href="">PartialOrd</a></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><span id="render-detail">
                   <a href="javascript:void(0)" id="toggle-all-docs" title="collapse all docs">
                       [<span class="inner"></span>]
                   </a>
               </span><a class="srclink" href="../../core/cmp/trait.PartialOrd.html?gotosrc=22533" id="src-22533" title="goto source code">[src]</a></span></h1>
<pre class="rust trait">pub trait PartialOrd&lt;Rhs = Self&gt;: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;Rhs&gt; <span class="where">where Rhs: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span> {
    fn <a class="fnname" href="#tymethod.partial_cmp">partial_cmp</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;<a class="enum" href="../../std/cmp/enum.Ordering.html" title="std::cmp::Ordering">Ordering</a>&gt;;

    fn <a class="fnname" href="#method.lt">lt</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a> { ... }
    fn <a class="fnname" href="#method.le">le</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a> { ... }
    fn <a class="fnname" href="#method.gt">gt</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a> { ... }
    fn <a class="fnname" href="#method.ge">ge</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a> { ... }
}</pre><div class="docblock"><p>Trait for values that can be compared for a sort-order.</p>

<p>The comparison must satisfy, for all <code>a</code>, <code>b</code> and <code>c</code>:</p>

<ul>
<li>antisymmetry: if <code>a &lt; b</code> then <code>!(a &gt; b)</code>, as well as <code>a &gt; b</code> implying <code>!(a &lt; b)</code>; and</li>
<li>transitivity: <code>a &lt; b</code> and <code>b &lt; c</code> implies <code>a &lt; c</code>. The same must hold for both <code>==</code> and <code>&gt;</code>.</li>
</ul>

<p>Note that these requirements mean that the trait itself must be implemented symmetrically and
transitively: if <code>T: PartialOrd&lt;U&gt;</code> and <code>U: PartialOrd&lt;V&gt;</code> then <code>U: PartialOrd&lt;T&gt;</code> and <code>T: PartialOrd&lt;V&gt;</code>.</p>

<p>PartialOrd only requires implementation of the <code>partial_cmp</code> method, with the others generated
from default implementations.</p>

<p>However it remains possible to implement the others separately for types which do not have a
total order. For example, for floating point numbers, <code>NaN &lt; 0 == false</code> and <code>NaN &gt;= 0 == false</code> (cf. IEEE 754-2008 section 5.11).</p>

<p>This trait can be used with <code>#[derive]</code>. When <code>derive</code>d, it will produce an ordering
based on the top-to-bottom declaration order of the struct's members.</p>

<h1 class="section-header" id="examples"><a href="#examples">Examples</a></h1>
<span class="rusttest">fn main() {
    let x : u32 = 0;
let y : u32 = 1;

assert_eq!(x &lt; y, true);
assert_eq!(x.lt(&amp;y), true);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">x</span> : <span class="ident">u32</span> <span class="op">=</span> <span class="number">0</span>;
<span class="kw">let</span> <span class="ident">y</span> : <span class="ident">u32</span> <span class="op">=</span> <span class="number">1</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span> <span class="op">&lt;</span> <span class="ident">y</span>, <span class="boolvalue">true</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">lt</span>(<span class="kw-2">&amp;</span><span class="ident">y</span>), <span class="boolvalue">true</span>);</pre>
</div>
            <h2 id="required-methods">Required Methods</h2>
            <div class="methods">
        <h3 class="method stab " id="tymethod.partial_cmp"><code>fn <a class="fnname" href="#tymethod.partial_cmp">partial_cmp</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;<a class="enum" href="../../std/cmp/enum.Ordering.html" title="std::cmp::Ordering">Ordering</a>&gt;</code></h3><div class="docblock"><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists.</p>

<h1 class="section-header" id="examples-1"><a href="#examples-1">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::cmp::Ordering;

let result = 1.0.partial_cmp(&amp;2.0);
assert_eq!(result, Some(Ordering::Less));

let result = 1.0.partial_cmp(&amp;1.0);
assert_eq!(result, Some(Ordering::Equal));

let result = 2.0.partial_cmp(&amp;1.0);
assert_eq!(result, Some(Ordering::Greater));
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">cmp</span>::<span class="ident">Ordering</span>;

<span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="number">1.0</span>.<span class="ident">partial_cmp</span>(<span class="kw-2">&amp;</span><span class="number">2.0</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">result</span>, <span class="prelude-val">Some</span>(<span class="ident">Ordering</span>::<span class="ident">Less</span>));

<span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="number">1.0</span>.<span class="ident">partial_cmp</span>(<span class="kw-2">&amp;</span><span class="number">1.0</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">result</span>, <span class="prelude-val">Some</span>(<span class="ident">Ordering</span>::<span class="ident">Equal</span>));

<span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="number">2.0</span>.<span class="ident">partial_cmp</span>(<span class="kw-2">&amp;</span><span class="number">1.0</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">result</span>, <span class="prelude-val">Some</span>(<span class="ident">Ordering</span>::<span class="ident">Greater</span>));</pre>

<p>When comparison is impossible:</p>

<span class="rusttest">fn main() {
    let result = std::f64::NAN.partial_cmp(&amp;1.0);
assert_eq!(result, None);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="ident">std</span>::<span class="ident">f64</span>::<span class="ident">NAN</span>.<span class="ident">partial_cmp</span>(<span class="kw-2">&amp;</span><span class="number">1.0</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">result</span>, <span class="prelude-val">None</span>);</pre>
</div></div>
            <h2 id="provided-methods">Provided Methods</h2>
            <div class="methods">
        <h3 class="method stab " id="method.lt"><code>fn <a class="fnname" href="#method.lt">lt</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h3><div class="docblock"><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator.</p>

<h1 class="section-header" id="examples-2"><a href="#examples-2">Examples</a></h1>
<span class="rusttest">fn main() {
    let result = 1.0 &lt; 2.0;
assert_eq!(result, true);

let result = 2.0 &lt; 1.0;
assert_eq!(result, false);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="number">1.0</span> <span class="op">&lt;</span> <span class="number">2.0</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">result</span>, <span class="boolvalue">true</span>);

<span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="number">2.0</span> <span class="op">&lt;</span> <span class="number">1.0</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">result</span>, <span class="boolvalue">false</span>);</pre>
</div><h3 class="method stab " id="method.le"><code>fn <a class="fnname" href="#method.le">le</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h3><div class="docblock"><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code>
operator.</p>

<h1 class="section-header" id="examples-3"><a href="#examples-3">Examples</a></h1>
<span class="rusttest">fn main() {
    let result = 1.0 &lt;= 2.0;
assert_eq!(result, true);

let result = 2.0 &lt;= 2.0;
assert_eq!(result, true);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="number">1.0</span> <span class="op">&lt;=</span> <span class="number">2.0</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">result</span>, <span class="boolvalue">true</span>);

<span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="number">2.0</span> <span class="op">&lt;=</span> <span class="number">2.0</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">result</span>, <span class="boolvalue">true</span>);</pre>
</div><h3 class="method stab " id="method.gt"><code>fn <a class="fnname" href="#method.gt">gt</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h3><div class="docblock"><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator.</p>

<h1 class="section-header" id="examples-4"><a href="#examples-4">Examples</a></h1>
<span class="rusttest">fn main() {
    let result = 1.0 &gt; 2.0;
assert_eq!(result, false);

let result = 2.0 &gt; 2.0;
assert_eq!(result, false);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="number">1.0</span> <span class="op">&gt;</span> <span class="number">2.0</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">result</span>, <span class="boolvalue">false</span>);

<span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="number">2.0</span> <span class="op">&gt;</span> <span class="number">2.0</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">result</span>, <span class="boolvalue">false</span>);</pre>
</div><h3 class="method stab " id="method.ge"><code>fn <a class="fnname" href="#method.ge">ge</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h3><div class="docblock"><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code>
operator.</p>

<h1 class="section-header" id="examples-5"><a href="#examples-5">Examples</a></h1>
<span class="rusttest">fn main() {
    let result = 2.0 &gt;= 1.0;
assert_eq!(result, true);

let result = 2.0 &gt;= 2.0;
assert_eq!(result, true);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="number">2.0</span> <span class="op">&gt;=</span> <span class="number">1.0</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">result</span>, <span class="boolvalue">true</span>);

<span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="number">2.0</span> <span class="op">&gt;=</span> <span class="number">2.0</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">result</span>, <span class="boolvalue">true</span>);</pre>
</div></div>
        <h2 id="implementors">Implementors</h2>
        <ul class="item-list" id="implementors-list">
    <li><code>impl&lt;T&gt; PartialOrd&lt;<a class="struct" href="../../std/num/struct.Wrapping.html" title="std::num::Wrapping">Wrapping</a>&lt;T&gt;&gt; for <a class="struct" href="../../std/num/struct.Wrapping.html" title="std::num::Wrapping">Wrapping</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="struct" href="../../core/nonzero/struct.NonZero.html" title="core::nonzero::NonZero">NonZero</a>&lt;T&gt;&gt; for <a class="struct" href="../../core/nonzero/struct.NonZero.html" title="core::nonzero::NonZero">NonZero</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../core/nonzero/trait.Zeroable.html" title="core::nonzero::Zeroable">Zeroable</a> + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;Ret&gt; PartialOrd&lt;fn() -&gt; Ret&gt; for fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret&gt; PartialOrd&lt;extern fn() -&gt; Ret&gt; for extern fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret&gt; PartialOrd&lt;unsafe fn() -&gt; Ret&gt; for unsafe fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret&gt; PartialOrd&lt;unsafe extern fn() -&gt; Ret&gt; for unsafe extern fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A&gt; PartialOrd&lt;fn(A) -&gt; Ret&gt; for fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A&gt; PartialOrd&lt;extern fn(A) -&gt; Ret&gt; for extern fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A&gt; PartialOrd&lt;unsafe fn(A) -&gt; Ret&gt; for unsafe fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A&gt; PartialOrd&lt;unsafe extern fn(A) -&gt; Ret&gt; for unsafe extern fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B&gt; PartialOrd&lt;fn(A, B) -&gt; Ret&gt; for fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B&gt; PartialOrd&lt;extern fn(A, B) -&gt; Ret&gt; for extern fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B&gt; PartialOrd&lt;unsafe fn(A, B) -&gt; Ret&gt; for unsafe fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B&gt; PartialOrd&lt;unsafe extern fn(A, B) -&gt; Ret&gt; for unsafe extern fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C&gt; PartialOrd&lt;fn(A, B, C) -&gt; Ret&gt; for fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C&gt; PartialOrd&lt;extern fn(A, B, C) -&gt; Ret&gt; for extern fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C&gt; PartialOrd&lt;unsafe fn(A, B, C) -&gt; Ret&gt; for unsafe fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C&gt; PartialOrd&lt;unsafe extern fn(A, B, C) -&gt; Ret&gt; for unsafe extern fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D&gt; PartialOrd&lt;fn(A, B, C, D) -&gt; Ret&gt; for fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D&gt; PartialOrd&lt;extern fn(A, B, C, D) -&gt; Ret&gt; for extern fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D&gt; PartialOrd&lt;unsafe fn(A, B, C, D) -&gt; Ret&gt; for unsafe fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D&gt; PartialOrd&lt;unsafe extern fn(A, B, C, D) -&gt; Ret&gt; for unsafe extern fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E&gt; PartialOrd&lt;fn(A, B, C, D, E) -&gt; Ret&gt; for fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E&gt; PartialOrd&lt;extern fn(A, B, C, D, E) -&gt; Ret&gt; for extern fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E&gt; PartialOrd&lt;unsafe fn(A, B, C, D, E) -&gt; Ret&gt; for unsafe fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E&gt; PartialOrd&lt;unsafe extern fn(A, B, C, D, E) -&gt; Ret&gt; for unsafe extern fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F&gt; PartialOrd&lt;fn(A, B, C, D, E, F) -&gt; Ret&gt; for fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F&gt; PartialOrd&lt;extern fn(A, B, C, D, E, F) -&gt; Ret&gt; for extern fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F&gt; PartialOrd&lt;unsafe fn(A, B, C, D, E, F) -&gt; Ret&gt; for unsafe fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F&gt; PartialOrd&lt;unsafe extern fn(A, B, C, D, E, F) -&gt; Ret&gt; for unsafe extern fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G&gt; PartialOrd&lt;fn(A, B, C, D, E, F, G) -&gt; Ret&gt; for fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G&gt; PartialOrd&lt;extern fn(A, B, C, D, E, F, G) -&gt; Ret&gt; for extern fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G&gt; PartialOrd&lt;unsafe fn(A, B, C, D, E, F, G) -&gt; Ret&gt; for unsafe fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G&gt; PartialOrd&lt;unsafe extern fn(A, B, C, D, E, F, G) -&gt; Ret&gt; for unsafe extern fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H&gt; PartialOrd&lt;fn(A, B, C, D, E, F, G, H) -&gt; Ret&gt; for fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H&gt; PartialOrd&lt;extern fn(A, B, C, D, E, F, G, H) -&gt; Ret&gt; for extern fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H&gt; PartialOrd&lt;unsafe fn(A, B, C, D, E, F, G, H) -&gt; Ret&gt; for unsafe fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H&gt; PartialOrd&lt;unsafe extern fn(A, B, C, D, E, F, G, H) -&gt; Ret&gt; for unsafe extern fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I&gt; PartialOrd&lt;fn(A, B, C, D, E, F, G, H, I) -&gt; Ret&gt; for fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I&gt; PartialOrd&lt;extern fn(A, B, C, D, E, F, G, H, I) -&gt; Ret&gt; for extern fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I&gt; PartialOrd&lt;unsafe fn(A, B, C, D, E, F, G, H, I) -&gt; Ret&gt; for unsafe fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I&gt; PartialOrd&lt;unsafe extern fn(A, B, C, D, E, F, G, H, I) -&gt; Ret&gt; for unsafe extern fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J&gt; PartialOrd&lt;fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret&gt; for fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J&gt; PartialOrd&lt;extern fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret&gt; for extern fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J&gt; PartialOrd&lt;unsafe fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret&gt; for unsafe fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J&gt; PartialOrd&lt;unsafe extern fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret&gt; for unsafe extern fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K&gt; PartialOrd&lt;fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret&gt; for fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K&gt; PartialOrd&lt;extern fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret&gt; for extern fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K&gt; PartialOrd&lt;unsafe fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret&gt; for unsafe fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K&gt; PartialOrd&lt;unsafe extern fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret&gt; for unsafe extern fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K, L&gt; PartialOrd&lt;fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret&gt; for fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K, L&gt; PartialOrd&lt;extern fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret&gt; for extern fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K, L&gt; PartialOrd&lt;unsafe fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret&gt; for unsafe fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K, L&gt; PartialOrd&lt;unsafe extern fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret&gt; for unsafe extern fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.pointer.html">*const T</a>&gt; for <a class="primitive" href="../primitive.pointer.html">*const T</a> <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.pointer.html">*mut T</a>&gt; for <a class="primitive" href="../primitive.pointer.html">*mut T</a> <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="struct" href="../../std/marker/struct.PhantomData.html" title="std::marker::PhantomData">PhantomData</a>&lt;T&gt;&gt; for <a class="struct" href="../../std/marker/struct.PhantomData.html" title="std::marker::PhantomData">PhantomData</a>&lt;T&gt; <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl PartialOrd&lt;<a class="enum" href="../../std/cmp/enum.Ordering.html" title="std::cmp::Ordering">Ordering</a>&gt; for <a class="enum" href="../../std/cmp/enum.Ordering.html" title="std::cmp::Ordering">Ordering</a></code></li>
<li><code>impl PartialOrd&lt;<a class="primitive" href="../primitive.tuple.html">()</a>&gt; for <a class="primitive" href="../primitive.tuple.html">()</a></code></li>
<li><code>impl PartialOrd&lt;<a class="primitive" href="../primitive.bool.html">bool</a>&gt; for <a class="primitive" href="../primitive.bool.html">bool</a></code></li>
<li><code>impl PartialOrd&lt;<a class="primitive" href="../primitive.f32.html">f32</a>&gt; for <a class="primitive" href="../primitive.f32.html">f32</a></code></li>
<li><code>impl PartialOrd&lt;<a class="primitive" href="../primitive.f64.html">f64</a>&gt; for <a class="primitive" href="../primitive.f64.html">f64</a></code></li>
<li><code>impl PartialOrd&lt;<a class="primitive" href="../primitive.char.html">char</a>&gt; for <a class="primitive" href="../primitive.char.html">char</a></code></li>
<li><code>impl PartialOrd&lt;<a class="primitive" href="../primitive.usize.html">usize</a>&gt; for <a class="primitive" href="../primitive.usize.html">usize</a></code></li>
<li><code>impl PartialOrd&lt;<a class="primitive" href="../primitive.u8.html">u8</a>&gt; for <a class="primitive" href="../primitive.u8.html">u8</a></code></li>
<li><code>impl PartialOrd&lt;<a class="primitive" href="../primitive.u16.html">u16</a>&gt; for <a class="primitive" href="../primitive.u16.html">u16</a></code></li>
<li><code>impl PartialOrd&lt;<a class="primitive" href="../primitive.u32.html">u32</a>&gt; for <a class="primitive" href="../primitive.u32.html">u32</a></code></li>
<li><code>impl PartialOrd&lt;<a class="primitive" href="../primitive.u64.html">u64</a>&gt; for <a class="primitive" href="../primitive.u64.html">u64</a></code></li>
<li><code>impl PartialOrd&lt;<a class="primitive" href="../primitive.isize.html">isize</a>&gt; for <a class="primitive" href="../primitive.isize.html">isize</a></code></li>
<li><code>impl PartialOrd&lt;<a class="primitive" href="../primitive.i8.html">i8</a>&gt; for <a class="primitive" href="../primitive.i8.html">i8</a></code></li>
<li><code>impl PartialOrd&lt;<a class="primitive" href="../primitive.i16.html">i16</a>&gt; for <a class="primitive" href="../primitive.i16.html">i16</a></code></li>
<li><code>impl PartialOrd&lt;<a class="primitive" href="../primitive.i32.html">i32</a>&gt; for <a class="primitive" href="../primitive.i32.html">i32</a></code></li>
<li><code>impl PartialOrd&lt;<a class="primitive" href="../primitive.i64.html">i64</a>&gt; for <a class="primitive" href="../primitive.i64.html">i64</a></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialOrd&lt;&amp;'b B&gt; for &amp;'a A <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;B&gt; + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a>, B: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;'a, 'b, A, B&gt; PartialOrd&lt;&amp;'b mut B&gt; for &amp;'a mut A <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;B&gt; + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a>, B: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 0]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 0]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 1]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 1]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 2]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 2]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 3]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 3]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 4]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 4]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 5]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 5]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 6]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 6]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 7]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 7]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 8]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 8]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 9]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 9]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 10]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 10]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 11]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 11]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 12]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 12]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 13]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 13]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 14]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 14]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 15]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 15]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 16]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 16]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 17]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 17]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 18]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 18]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 19]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 19]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 20]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 20]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 21]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 21]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 22]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 22]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 23]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 23]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 24]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 24]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 25]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 25]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 26]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 26]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 27]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 27]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 28]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 28]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 29]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 29]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 30]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 30]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 31]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 31]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 32]</a>&gt; for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 32]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="struct" href="../../std/cell/struct.Cell.html" title="std::cell::Cell">Cell</a>&lt;T&gt;&gt; for <a class="struct" href="../../std/cell/struct.Cell.html" title="std::cell::Cell">Cell</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a> + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="struct" href="../../std/cell/struct.RefCell.html" title="std::cell::RefCell">RefCell</a>&lt;T&gt;&gt; for <a class="struct" href="../../std/cell/struct.RefCell.html" title="std::cell::RefCell">RefCell</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt; + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt;&gt; for <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T, E&gt; PartialOrd&lt;<a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;T, E&gt;&gt; for <a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;T, E&gt; <span class="where">where E: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;E&gt;, T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="primitive" href="../primitive.slice.html">[</a>T<a class="primitive" href="../primitive.slice.html">]</a>&gt; for <a class="primitive" href="../primitive.slice.html">[</a>T<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl PartialOrd&lt;<a class="primitive" href="../primitive.str.html">str</a>&gt; for <a class="primitive" href="../primitive.str.html">str</a></code></li>
<li><code>impl PartialOrd&lt;<a class="struct" href="../../std/fmt/struct.Error.html" title="std::fmt::Error">Error</a>&gt; for <a class="struct" href="../../std/fmt/struct.Error.html" title="std::fmt::Error">Error</a></code></li>
<li><code>impl&lt;A&gt; PartialOrd&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A,<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A,<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;A&gt;</span></code></li>
<li><code>impl&lt;A, B&gt; PartialOrd&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A, B<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A, B<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;A&gt;, B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;B&gt;</span></code></li>
<li><code>impl&lt;A, B, C&gt; PartialOrd&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A, B, C<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;A&gt;, B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;B&gt;, C: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;C&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;C&gt;</span></code></li>
<li><code>impl&lt;A, B, C, D&gt; PartialOrd&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;A&gt;, B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;B&gt;, C: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;C&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;C&gt;, D: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;D&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;D&gt;</span></code></li>
<li><code>impl&lt;A, B, C, D, E&gt; PartialOrd&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;A&gt;, B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;B&gt;, C: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;C&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;C&gt;, D: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;D&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;D&gt;, E: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;E&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;E&gt;</span></code></li>
<li><code>impl&lt;A, B, C, D, E, F&gt; PartialOrd&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;A&gt;, B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;B&gt;, C: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;C&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;C&gt;, D: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;D&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;D&gt;, E: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;E&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;E&gt;, F: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;F&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;F&gt;</span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G&gt; PartialOrd&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;A&gt;, B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;B&gt;, C: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;C&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;C&gt;, D: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;D&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;D&gt;, E: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;E&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;E&gt;, F: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;F&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;F&gt;, G: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;G&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;G&gt;</span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G, H&gt; PartialOrd&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;A&gt;, B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;B&gt;, C: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;C&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;C&gt;, D: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;D&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;D&gt;, E: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;E&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;E&gt;, F: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;F&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;F&gt;, G: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;G&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;G&gt;, H: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;H&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;H&gt;</span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G, H, I&gt; PartialOrd&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;A&gt;, B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;B&gt;, C: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;C&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;C&gt;, D: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;D&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;D&gt;, E: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;E&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;E&gt;, F: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;F&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;F&gt;, G: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;G&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;G&gt;, H: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;H&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;H&gt;, I: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;I&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;I&gt;</span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G, H, I, J&gt; PartialOrd&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;A&gt;, B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;B&gt;, C: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;C&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;C&gt;, D: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;D&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;D&gt;, E: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;E&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;E&gt;, F: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;F&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;F&gt;, G: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;G&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;G&gt;, H: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;H&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;H&gt;, I: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;I&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;I&gt;, J: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;J&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;J&gt;</span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G, H, I, J, K&gt; PartialOrd&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J, K<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J, K<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;A&gt;, B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;B&gt;, C: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;C&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;C&gt;, D: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;D&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;D&gt;, E: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;E&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;E&gt;, F: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;F&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;F&gt;, G: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;G&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;G&gt;, H: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;H&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;H&gt;, I: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;I&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;I&gt;, J: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;J&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;J&gt;, K: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;K&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;K&gt;</span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G, H, I, J, K, L&gt; PartialOrd&lt;<a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J, K, L<a class="primitive" href="../primitive.tuple.html">)</a>&gt; for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J, K, L<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;A&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;A&gt;, B: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;B&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;B&gt;, C: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;C&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;C&gt;, D: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;D&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;D&gt;, E: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;E&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;E&gt;, F: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;F&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;F&gt;, G: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;G&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;G&gt;, H: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;H&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;H&gt;, I: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;I&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;I&gt;, J: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;J&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;J&gt;, K: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;K&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;K&gt;, L: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;L&gt; + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;L&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="struct" href="../../std/boxed/struct.Box.html" title="std::boxed::Box">Box</a>&lt;T&gt;&gt; for <a class="struct" href="../../std/boxed/struct.Box.html" title="std::boxed::Box">Box</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt; + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="struct" href="../../std/sync/struct.Arc.html" title="std::sync::Arc">Arc</a>&lt;T&gt;&gt; for <a class="struct" href="../../std/sync/struct.Arc.html" title="std::sync::Arc">Arc</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt; + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="struct" href="../../std/rc/struct.Rc.html" title="std::rc::Rc">Rc</a>&lt;T&gt;&gt; for <a class="struct" href="../../std/rc/struct.Rc.html" title="std::rc::Rc">Rc</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt; + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;K, V&gt; PartialOrd&lt;<a class="struct" href="../../std/collections/btree_map/struct.BTreeMap.html" title="std::collections::btree_map::BTreeMap">BTreeMap</a>&lt;K, V&gt;&gt; for <a class="struct" href="../../std/collections/btree_map/struct.BTreeMap.html" title="std::collections::btree_map::BTreeMap">BTreeMap</a>&lt;K, V&gt; <span class="where">where K: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;K&gt;, V: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;V&gt;</span></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="struct" href="../../std/collections/btree_set/struct.BTreeSet.html" title="std::collections::btree_set::BTreeSet">BTreeSet</a>&lt;T&gt;&gt; for <a class="struct" href="../../std/collections/btree_set/struct.BTreeSet.html" title="std::collections::btree_set::BTreeSet">BTreeSet</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;'a, B&gt; PartialOrd&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, B&gt;&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, B&gt; <span class="where">where B: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;B&gt; + <a class="trait" href="../../std/borrow/trait.ToOwned.html" title="std::borrow::ToOwned">ToOwned</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;E&gt; PartialOrd&lt;<a class="struct" href="../../collections/enum_set/struct.EnumSet.html" title="collections::enum_set::EnumSet">EnumSet</a>&lt;E&gt;&gt; for <a class="struct" href="../../collections/enum_set/struct.EnumSet.html" title="collections::enum_set::EnumSet">EnumSet</a>&lt;E&gt; <span class="where">where E: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;E&gt;</span></code></li>
<li><code>impl&lt;A&gt; PartialOrd&lt;<a class="struct" href="../../std/collections/linked_list/struct.LinkedList.html" title="std::collections::linked_list::LinkedList">LinkedList</a>&lt;A&gt;&gt; for <a class="struct" href="../../std/collections/linked_list/struct.LinkedList.html" title="std::collections::linked_list::LinkedList">LinkedList</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;A&gt;</span></code></li>
<li><code>impl PartialOrd&lt;<a class="struct" href="../../std/string/struct.String.html" title="std::string::String">String</a>&gt; for <a class="struct" href="../../std/string/struct.String.html" title="std::string::String">String</a></code></li>
<li><code>impl&lt;T&gt; PartialOrd&lt;<a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;&gt; for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;T&gt;</span></code></li>
<li><code>impl&lt;A&gt; PartialOrd&lt;<a class="struct" href="../../std/collections/vec_deque/struct.VecDeque.html" title="std::collections::vec_deque::VecDeque">VecDeque</a>&lt;A&gt;&gt; for <a class="struct" href="../../std/collections/vec_deque/struct.VecDeque.html" title="std::collections::vec_deque::VecDeque">VecDeque</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;A&gt;</span></code></li>
<li><code>impl PartialOrd for <a class="struct" href="../../std/ffi/struct.CString.html" title="std::ffi::CString">CString</a></code></li>
<li><code>impl PartialOrd for <a class="struct" href="../../std/ffi/struct.CStr.html" title="std::ffi::CStr">CStr</a></code></li>
<li><code>impl PartialOrd for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl PartialOrd&lt;<a class="primitive" href="../primitive.str.html">str</a>&gt; for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl PartialOrd for <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl PartialOrd&lt;<a class="primitive" href="../primitive.str.html">str</a>&gt; for <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a>&gt; for <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;&amp;'a <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a>&gt; for &amp;'a <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;&gt; for <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;&amp;'b <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;&gt; for &amp;'b <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;&gt; for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl PartialOrd for <a class="enum" href="../../std/net/enum.IpAddr.html" title="std::net::IpAddr">IpAddr</a></code></li>
<li><code>impl PartialOrd for <a class="struct" href="../../std/net/struct.Ipv4Addr.html" title="std::net::Ipv4Addr">Ipv4Addr</a></code></li>
<li><code>impl PartialOrd for <a class="struct" href="../../std/net/struct.Ipv6Addr.html" title="std::net::Ipv6Addr">Ipv6Addr</a></code></li>
<li><code>impl&lt;'a&gt; PartialOrd for <a class="enum" href="../../std/path/enum.Prefix.html" title="std::path::Prefix">Prefix</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; PartialOrd for <a class="struct" href="../../std/path/struct.PrefixComponent.html" title="std::path::PrefixComponent">PrefixComponent</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; PartialOrd for <a class="enum" href="../../std/path/enum.Component.html" title="std::path::Component">Component</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; PartialOrd for <a class="struct" href="../../std/path/struct.Components.html" title="std::path::Components">Components</a>&lt;'a&gt;</code></li>
<li><code>impl PartialOrd for <a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a></code></li>
<li><code>impl PartialOrd for <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt; for <a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a>&gt; for <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;&amp;'a <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt; for <a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a>&gt; for &amp;'a <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;&gt; for <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;&amp;'b <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;&gt; for &amp;'b <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;&gt; for <a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a>&gt; for <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;&amp;'a <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a>&gt; for &amp;'a <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;&gt; for <a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a>&gt; for <a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a>&gt; for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt; for <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;&amp;'a <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt; for &amp;'a <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;&gt; for <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a>&gt; for <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt; for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt; for &amp;'a <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;&amp;'a <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt; for <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'b, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;&gt; for &amp;'a <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;&amp;'a <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'b, <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a>&gt; for &amp;'a <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;&amp;'a <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt; for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;&gt; for <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;&amp;'b <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;&gt; for &amp;'b <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a>&gt; for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;</code></li>
<li><code>impl&lt;'a, 'b&gt; PartialOrd&lt;<a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a>&gt;&gt; for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl PartialOrd for <a class="struct" href="../../std/time/struct.Duration.html" title="std::time::Duration">Duration</a></code></li>
<li><code>impl PartialOrd for <a class="struct" href="../../std/time/struct.Instant.html" title="std::time::Instant">Instant</a></code></li>
<li><code>impl PartialOrd for <a class="struct" href="../../std/time/struct.SystemTime.html" title="std::time::SystemTime">SystemTime</a></code></li>
</ul><script src="../../implementors/core/cmp/trait.PartialOrd.js" async="" type="text/javascript">
                 </script></div></div><div class="outerdoc" id="trait.Eq"><div class="docblock" id="trait.Eq">
<h1 class="fqn"><span class="in-band">Trait <a href="../">std</a>::<wbr><a href="index.html">cmp</a>::<wbr><a class="trait" href="">Eq</a></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><span id="render-detail">
                   <a href="javascript:void(0)" id="toggle-all-docs" title="collapse all docs">
                       [<span class="inner"></span>]
                   </a>
               </span><a class="srclink" href="../../core/cmp/trait.Eq.html?gotosrc=22482" id="src-22482" title="goto source code">[src]</a></span></h1>
<pre class="rust trait">pub trait Eq: <a class="trait" href="../../std/cmp/trait.PartialEq.html" title="std::cmp::PartialEq">PartialEq</a>&lt;Self&gt; { }</pre><div class="docblock"><p>Trait for equality comparisons which are <a href="https://en.wikipedia.org/wiki/Equivalence_relation">equivalence relations</a>.</p>

<p>This means, that in addition to <code>a == b</code> and <code>a != b</code> being strict inverses, the equality must
be (for all <code>a</code>, <code>b</code> and <code>c</code>):</p>

<ul>
<li>reflexive: <code>a == a</code>;</li>
<li>symmetric: <code>a == b</code> implies <code>b == a</code>; and</li>
<li>transitive: <code>a == b</code> and <code>b == c</code> implies <code>a == c</code>.</li>
</ul>

<p>This property cannot be checked by the compiler, and therefore <code>Eq</code> implies
<code>PartialEq</code>, and has no extra methods.</p>

<p>This trait can be used with <code>#[derive]</code>.</p>
</div>
        <h2 id="implementors">Implementors</h2>
        <ul class="item-list" id="implementors-list">
    <li><code>impl&lt;T&gt; Eq for <a class="struct" href="../../std/num/struct.Wrapping.html" title="std::num::Wrapping">Wrapping</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="struct" href="../../core/nonzero/struct.NonZero.html" title="core::nonzero::NonZero">NonZero</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../core/nonzero/trait.Zeroable.html" title="core::nonzero::Zeroable">Zeroable</a> + <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.pointer.html">*const T</a> <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.pointer.html">*mut T</a> <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;Ret&gt; Eq for fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret&gt; Eq for extern fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret&gt; Eq for unsafe fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret&gt; Eq for unsafe extern fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A&gt; Eq for fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A&gt; Eq for extern fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A&gt; Eq for unsafe fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A&gt; Eq for unsafe extern fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B&gt; Eq for fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B&gt; Eq for extern fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B&gt; Eq for unsafe fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B&gt; Eq for unsafe extern fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C&gt; Eq for fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C&gt; Eq for extern fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C&gt; Eq for unsafe fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C&gt; Eq for unsafe extern fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D&gt; Eq for fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D&gt; Eq for extern fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D&gt; Eq for unsafe fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D&gt; Eq for unsafe extern fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E&gt; Eq for fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E&gt; Eq for extern fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E&gt; Eq for unsafe fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E&gt; Eq for unsafe extern fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F&gt; Eq for fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F&gt; Eq for extern fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F&gt; Eq for unsafe fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F&gt; Eq for unsafe extern fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G&gt; Eq for fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G&gt; Eq for extern fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G&gt; Eq for unsafe fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G&gt; Eq for unsafe extern fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H&gt; Eq for fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H&gt; Eq for extern fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H&gt; Eq for unsafe fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H&gt; Eq for unsafe extern fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I&gt; Eq for fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I&gt; Eq for extern fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I&gt; Eq for unsafe fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I&gt; Eq for unsafe extern fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J&gt; Eq for fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J&gt; Eq for extern fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J&gt; Eq for unsafe fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J&gt; Eq for unsafe extern fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K&gt; Eq for fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K&gt; Eq for extern fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K&gt; Eq for unsafe fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K&gt; Eq for unsafe extern fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K, L&gt; Eq for fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K, L&gt; Eq for extern fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K, L&gt; Eq for unsafe fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K, L&gt; Eq for unsafe extern fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;T&gt; Eq for <a class="struct" href="../../std/marker/struct.PhantomData.html" title="std::marker::PhantomData">PhantomData</a>&lt;T&gt; <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl Eq for <a class="struct" href="../../std/ops/struct.RangeFull.html" title="std::ops::RangeFull">RangeFull</a></code></li>
<li><code>impl&lt;Idx&gt; Eq for <a class="struct" href="../../std/ops/struct.Range.html" title="std::ops::Range">Range</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;Idx&gt; Eq for <a class="struct" href="../../std/ops/struct.RangeFrom.html" title="std::ops::RangeFrom">RangeFrom</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;Idx&gt; Eq for <a class="struct" href="../../std/ops/struct.RangeTo.html" title="std::ops::RangeTo">RangeTo</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;Idx&gt; Eq for <a class="enum" href="../../std/ops/enum.RangeInclusive.html" title="std::ops::RangeInclusive">RangeInclusive</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;Idx&gt; Eq for <a class="struct" href="../../std/ops/struct.RangeToInclusive.html" title="std::ops::RangeToInclusive">RangeToInclusive</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl Eq for <a class="enum" href="../../std/cmp/enum.Ordering.html" title="std::cmp::Ordering">Ordering</a></code></li>
<li><code>impl Eq for <a class="primitive" href="../primitive.tuple.html">()</a></code></li>
<li><code>impl Eq for <a class="primitive" href="../primitive.bool.html">bool</a></code></li>
<li><code>impl Eq for <a class="primitive" href="../primitive.char.html">char</a></code></li>
<li><code>impl Eq for <a class="primitive" href="../primitive.usize.html">usize</a></code></li>
<li><code>impl Eq for <a class="primitive" href="../primitive.u8.html">u8</a></code></li>
<li><code>impl Eq for <a class="primitive" href="../primitive.u16.html">u16</a></code></li>
<li><code>impl Eq for <a class="primitive" href="../primitive.u32.html">u32</a></code></li>
<li><code>impl Eq for <a class="primitive" href="../primitive.u64.html">u64</a></code></li>
<li><code>impl Eq for <a class="primitive" href="../primitive.isize.html">isize</a></code></li>
<li><code>impl Eq for <a class="primitive" href="../primitive.i8.html">i8</a></code></li>
<li><code>impl Eq for <a class="primitive" href="../primitive.i16.html">i16</a></code></li>
<li><code>impl Eq for <a class="primitive" href="../primitive.i32.html">i32</a></code></li>
<li><code>impl Eq for <a class="primitive" href="../primitive.i64.html">i64</a></code></li>
<li><code>impl&lt;'a, A&gt; Eq for &amp;'a A <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;'a, A&gt; Eq for &amp;'a mut A <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl Eq for <a class="struct" href="../../std/any/struct.TypeId.html" title="std::any::TypeId">TypeId</a></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 0]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 1]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 2]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 3]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 4]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 5]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 6]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 7]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 8]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 9]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 10]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 11]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 12]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 13]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 14]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 15]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 16]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 17]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 18]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 19]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 20]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 21]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 22]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 23]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 24]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 25]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 26]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 27]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 28]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 29]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 30]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 31]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 32]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="struct" href="../../std/cell/struct.Cell.html" title="std::cell::Cell">Cell</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a> + <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl Eq for <a class="enum" href="../../std/cell/enum.BorrowState.html" title="std::cell::BorrowState">BorrowState</a></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="struct" href="../../std/cell/struct.RefCell.html" title="std::cell::RefCell">RefCell</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T, E&gt; Eq for <a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;T, E&gt; <span class="where">where E: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="primitive" href="../primitive.slice.html">[</a>T<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl Eq for <a class="enum" href="../../std/str/pattern/enum.SearchStep.html" title="std::str::pattern::SearchStep">SearchStep</a></code></li>
<li><code>impl Eq for <a class="struct" href="../../std/str/struct.Utf8Error.html" title="std::str::Utf8Error">Utf8Error</a></code></li>
<li><code>impl Eq for <a class="primitive" href="../primitive.str.html">str</a></code></li>
<li><code>impl Eq for <a class="struct" href="../../std/fmt/struct.Error.html" title="std::fmt::Error">Error</a></code></li>
<li><code>impl&lt;A&gt; Eq for <a class="primitive" href="../primitive.tuple.html">(</a>A,<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;A, B&gt; Eq for <a class="primitive" href="../primitive.tuple.html">(</a>A, B<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, B: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;A, B, C&gt; Eq for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, B: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, C: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;A, B, C, D&gt; Eq for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, B: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, C: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, D: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;A, B, C, D, E&gt; Eq for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, B: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, C: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, D: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, E: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;A, B, C, D, E, F&gt; Eq for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, B: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, C: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, D: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, E: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, F: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G&gt; Eq for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, B: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, C: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, D: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, E: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, F: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, G: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G, H&gt; Eq for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, B: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, C: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, D: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, E: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, F: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, G: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, H: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G, H, I&gt; Eq for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, B: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, C: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, D: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, E: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, F: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, G: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, H: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, I: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G, H, I, J&gt; Eq for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, B: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, C: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, D: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, E: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, F: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, G: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, H: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, I: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, J: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G, H, I, J, K&gt; Eq for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J, K<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, B: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, C: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, D: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, E: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, F: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, G: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, H: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, I: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, J: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, K: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G, H, I, J, K, L&gt; Eq for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J, K, L<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, B: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, C: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, D: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, E: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, F: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, G: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, H: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, I: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, J: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, K: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, L: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="struct" href="../../std/boxed/struct.Box.html" title="std::boxed::Box">Box</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="struct" href="../../std/sync/struct.Arc.html" title="std::sync::Arc">Arc</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="struct" href="../../std/rc/struct.Rc.html" title="std::rc::Rc">Rc</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;K, V&gt; Eq for <a class="struct" href="../../std/collections/btree_map/struct.BTreeMap.html" title="std::collections::btree_map::BTreeMap">BTreeMap</a>&lt;K, V&gt; <span class="where">where K: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, V: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="struct" href="../../std/collections/btree_set/struct.BTreeSet.html" title="std::collections::btree_set::BTreeSet">BTreeSet</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;'a, B&gt; Eq for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, B&gt; <span class="where">where B: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a> + <a class="trait" href="../../std/borrow/trait.ToOwned.html" title="std::borrow::ToOwned">ToOwned</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;E&gt; Eq for <a class="struct" href="../../collections/enum_set/struct.EnumSet.html" title="collections::enum_set::EnumSet">EnumSet</a>&lt;E&gt; <span class="where">where E: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;A&gt; Eq for <a class="struct" href="../../std/collections/linked_list/struct.LinkedList.html" title="std::collections::linked_list::LinkedList">LinkedList</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl Eq for <a class="struct" href="../../std/string/struct.String.html" title="std::string::String">String</a></code></li>
<li><code>impl Eq for <a class="enum" href="../../std/string/enum.ParseError.html" title="std::string::ParseError">ParseError</a></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;A&gt; Eq for <a class="struct" href="../../std/collections/vec_deque/struct.VecDeque.html" title="std::collections::vec_deque::VecDeque">VecDeque</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl&lt;T&gt; Eq for <a class="enum" href="../../std/collections/enum.Bound.html" title="std::collections::Bound">Bound</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></li>
<li><code>impl Eq for <a class="struct" href="../../std/char/struct.DecodeUtf16Error.html" title="std::char::DecodeUtf16Error">DecodeUtf16Error</a></code></li>
<li><code>impl Eq for <a class="enum" href="../../std/thread/enum.LocalKeyState.html" title="std::thread::LocalKeyState">LocalKeyState</a></code></li>
<li><code>impl&lt;K, V, S&gt; Eq for <a class="struct" href="../../std/collections/struct.HashMap.html" title="std::collections::HashMap">HashMap</a>&lt;K, V, S&gt; <span class="where">where K: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a> + <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, V: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>, S: <a class="trait" href="../../std/hash/trait.BuildHasher.html" title="std::hash::BuildHasher">BuildHasher</a></span></code></li>
<li><code>impl&lt;T, S&gt; Eq for <a class="struct" href="../../std/collections/struct.HashSet.html" title="std::collections::HashSet">HashSet</a>&lt;T, S&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a> + <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, S: <a class="trait" href="../../std/hash/trait.BuildHasher.html" title="std::hash::BuildHasher">BuildHasher</a></span></code></li>
<li><code>impl Eq for <a class="enum" href="../../std/env/enum.VarError.html" title="std::env::VarError">VarError</a></code></li>
<li><code>impl Eq for <a class="struct" href="../../std/ffi/struct.CString.html" title="std::ffi::CString">CString</a></code></li>
<li><code>impl Eq for <a class="struct" href="../../std/ffi/struct.CStr.html" title="std::ffi::CStr">CStr</a></code></li>
<li><code>impl Eq for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl Eq for <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl Eq for <a class="struct" href="../../std/fs/struct.Permissions.html" title="std::fs::Permissions">Permissions</a></code></li>
<li><code>impl Eq for <a class="struct" href="../../std/fs/struct.FileType.html" title="std::fs::FileType">FileType</a></code></li>
<li><code>impl Eq for <a class="enum" href="../../std/io/enum.ErrorKind.html" title="std::io::ErrorKind">ErrorKind</a></code></li>
<li><code>impl Eq for <a class="enum" href="../../std/io/enum.SeekFrom.html" title="std::io::SeekFrom">SeekFrom</a></code></li>
<li><code>impl Eq for <a class="enum" href="../../std/net/enum.IpAddr.html" title="std::net::IpAddr">IpAddr</a></code></li>
<li><code>impl Eq for <a class="enum" href="../../std/net/enum.Ipv6MulticastScope.html" title="std::net::Ipv6MulticastScope">Ipv6MulticastScope</a></code></li>
<li><code>impl Eq for <a class="struct" href="../../std/net/struct.Ipv4Addr.html" title="std::net::Ipv4Addr">Ipv4Addr</a></code></li>
<li><code>impl Eq for <a class="struct" href="../../std/net/struct.Ipv6Addr.html" title="std::net::Ipv6Addr">Ipv6Addr</a></code></li>
<li><code>impl Eq for <a class="enum" href="../../std/net/enum.SocketAddr.html" title="std::net::SocketAddr">SocketAddr</a></code></li>
<li><code>impl Eq for <a class="struct" href="../../std/net/struct.SocketAddrV4.html" title="std::net::SocketAddrV4">SocketAddrV4</a></code></li>
<li><code>impl Eq for <a class="struct" href="../../std/net/struct.SocketAddrV6.html" title="std::net::SocketAddrV6">SocketAddrV6</a></code></li>
<li><code>impl&lt;'a&gt; Eq for <a class="enum" href="../../std/path/enum.Prefix.html" title="std::path::Prefix">Prefix</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; Eq for <a class="struct" href="../../std/path/struct.PrefixComponent.html" title="std::path::PrefixComponent">PrefixComponent</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; Eq for <a class="enum" href="../../std/path/enum.Component.html" title="std::path::Component">Component</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; Eq for <a class="struct" href="../../std/path/struct.Components.html" title="std::path::Components">Components</a>&lt;'a&gt;</code></li>
<li><code>impl Eq for <a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a></code></li>
<li><code>impl Eq for <a class="struct" href="../../std/path/struct.StripPrefixError.html" title="std::path::StripPrefixError">StripPrefixError</a></code></li>
<li><code>impl Eq for <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl Eq for <a class="struct" href="../../std/process/struct.Output.html" title="std::process::Output">Output</a></code></li>
<li><code>impl Eq for <a class="struct" href="../../std/process/struct.ExitStatus.html" title="std::process::ExitStatus">ExitStatus</a></code></li>
<li><code>impl&lt;T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>&gt; Eq for <a class="struct" href="../../std/sync/mpsc/struct.SendError.html" title="std::sync::mpsc::SendError">SendError</a>&lt;T&gt;</code></li>
<li><code>impl Eq for <a class="struct" href="../../std/sync/mpsc/struct.RecvError.html" title="std::sync::mpsc::RecvError">RecvError</a></code></li>
<li><code>impl Eq for <a class="enum" href="../../std/sync/mpsc/enum.TryRecvError.html" title="std::sync::mpsc::TryRecvError">TryRecvError</a></code></li>
<li><code>impl&lt;T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a>&gt; Eq for <a class="enum" href="../../std/sync/mpsc/enum.TrySendError.html" title="std::sync::mpsc::TrySendError">TrySendError</a>&lt;T&gt;</code></li>
<li><code>impl Eq for <a class="struct" href="../../std/sync/struct.WaitTimeoutResult.html" title="std::sync::WaitTimeoutResult">WaitTimeoutResult</a></code></li>
<li><code>impl Eq for <a class="struct" href="../../std/time/struct.Duration.html" title="std::time::Duration">Duration</a></code></li>
<li><code>impl Eq for <a class="struct" href="../../std/time/struct.Instant.html" title="std::time::Instant">Instant</a></code></li>
<li><code>impl Eq for <a class="struct" href="../../std/time/struct.SystemTime.html" title="std::time::SystemTime">SystemTime</a></code></li>
</ul><script src="../../implementors/core/cmp/trait.Eq.js" async="" type="text/javascript">
                 </script></div></div><div class="outerdoc" id="trait.Ord"><div class="docblock" id="trait.Ord">
<h1 class="fqn"><span class="in-band">Trait <a href="../">std</a>::<wbr><a href="index.html">cmp</a>::<wbr><a class="trait" href="">Ord</a></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><span id="render-detail">
                   <a href="javascript:void(0)" id="toggle-all-docs" title="collapse all docs">
                       [<span class="inner"></span>]
                   </a>
               </span><a class="srclink" href="../../core/cmp/trait.Ord.html?gotosrc=22520" id="src-22520" title="goto source code">[src]</a></span></h1>
<pre class="rust trait">pub trait Ord: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a> + <a class="trait" href="../../std/cmp/trait.PartialOrd.html" title="std::cmp::PartialOrd">PartialOrd</a>&lt;Self&gt; {
    fn <a class="fnname" href="#tymethod.cmp">cmp</a>(&amp;self, other: &amp;Self) -&gt; <a class="enum" href="../../std/cmp/enum.Ordering.html" title="std::cmp::Ordering">Ordering</a>;
}</pre><div class="docblock"><p>Trait for types that form a <a href="https://en.wikipedia.org/wiki/Total_order">total order</a>.</p>

<p>An order is a total order if it is (for all <code>a</code>, <code>b</code> and <code>c</code>):</p>

<ul>
<li>total and antisymmetric: exactly one of <code>a &lt; b</code>, <code>a == b</code> or <code>a &gt; b</code> is true; and</li>
<li>transitive, <code>a &lt; b</code> and <code>b &lt; c</code> implies <code>a &lt; c</code>. The same must hold for both <code>==</code> and <code>&gt;</code>.</li>
</ul>

<p>This trait can be used with <code>#[derive]</code>. When <code>derive</code>d, it will produce a lexicographic
ordering based on the top-to-bottom declaration order of the struct's members.</p>
</div>
            <h2 id="required-methods">Required Methods</h2>
            <div class="methods">
        <h3 class="method stab " id="tymethod.cmp"><code>fn <a class="fnname" href="#tymethod.cmp">cmp</a>(&amp;self, other: &amp;Self) -&gt; <a class="enum" href="../../std/cmp/enum.Ordering.html" title="std::cmp::Ordering">Ordering</a></code></h3><div class="docblock"><p>This method returns an <code>Ordering</code> between <code>self</code> and <code>other</code>.</p>

<p>By convention, <code>self.cmp(&amp;other)</code> returns the ordering matching the expression
<code>self &lt;operator&gt; other</code> if true.</p>

<h1 class="section-header" id="examples"><a href="#examples">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::cmp::Ordering;

assert_eq!(5.cmp(&amp;10), Ordering::Less);
assert_eq!(10.cmp(&amp;5), Ordering::Greater);
assert_eq!(5.cmp(&amp;5), Ordering::Equal);
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">cmp</span>::<span class="ident">Ordering</span>;

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">5</span>.<span class="ident">cmp</span>(<span class="kw-2">&amp;</span><span class="number">10</span>), <span class="ident">Ordering</span>::<span class="ident">Less</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">10</span>.<span class="ident">cmp</span>(<span class="kw-2">&amp;</span><span class="number">5</span>), <span class="ident">Ordering</span>::<span class="ident">Greater</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">5</span>.<span class="ident">cmp</span>(<span class="kw-2">&amp;</span><span class="number">5</span>), <span class="ident">Ordering</span>::<span class="ident">Equal</span>);</pre>
</div></div>
        <h2 id="implementors">Implementors</h2>
        <ul class="item-list" id="implementors-list">
    <li><code>impl&lt;T&gt; Ord for <a class="struct" href="../../std/num/struct.Wrapping.html" title="std::num::Wrapping">Wrapping</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="struct" href="../../core/nonzero/struct.NonZero.html" title="core::nonzero::NonZero">NonZero</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../core/nonzero/trait.Zeroable.html" title="core::nonzero::Zeroable">Zeroable</a> + <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;Ret&gt; Ord for fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret&gt; Ord for extern fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret&gt; Ord for unsafe fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret&gt; Ord for unsafe extern fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A&gt; Ord for fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A&gt; Ord for extern fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A&gt; Ord for unsafe fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A&gt; Ord for unsafe extern fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B&gt; Ord for fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B&gt; Ord for extern fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B&gt; Ord for unsafe fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B&gt; Ord for unsafe extern fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C&gt; Ord for fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C&gt; Ord for extern fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C&gt; Ord for unsafe fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C&gt; Ord for unsafe extern fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D&gt; Ord for fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D&gt; Ord for extern fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D&gt; Ord for unsafe fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D&gt; Ord for unsafe extern fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E&gt; Ord for fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E&gt; Ord for extern fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E&gt; Ord for unsafe fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E&gt; Ord for unsafe extern fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F&gt; Ord for fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F&gt; Ord for extern fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F&gt; Ord for unsafe fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F&gt; Ord for unsafe extern fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G&gt; Ord for fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G&gt; Ord for extern fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G&gt; Ord for unsafe fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G&gt; Ord for unsafe extern fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H&gt; Ord for fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H&gt; Ord for extern fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H&gt; Ord for unsafe fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H&gt; Ord for unsafe extern fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I&gt; Ord for fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I&gt; Ord for extern fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I&gt; Ord for unsafe fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I&gt; Ord for unsafe extern fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J&gt; Ord for fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J&gt; Ord for extern fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J&gt; Ord for unsafe fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J&gt; Ord for unsafe extern fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K&gt; Ord for fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K&gt; Ord for extern fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K&gt; Ord for unsafe fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K&gt; Ord for unsafe extern fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K, L&gt; Ord for fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K, L&gt; Ord for extern fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K, L&gt; Ord for unsafe fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;Ret, A, B, C, D, E, F, G, H, I, J, K, L&gt; Ord for unsafe extern fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.pointer.html">*const T</a> <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.pointer.html">*mut T</a> <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="struct" href="../../std/marker/struct.PhantomData.html" title="std::marker::PhantomData">PhantomData</a>&lt;T&gt; <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl Ord for <a class="enum" href="../../std/cmp/enum.Ordering.html" title="std::cmp::Ordering">Ordering</a></code></li>
<li><code>impl Ord for <a class="primitive" href="../primitive.tuple.html">()</a></code></li>
<li><code>impl Ord for <a class="primitive" href="../primitive.bool.html">bool</a></code></li>
<li><code>impl Ord for <a class="primitive" href="../primitive.char.html">char</a></code></li>
<li><code>impl Ord for <a class="primitive" href="../primitive.usize.html">usize</a></code></li>
<li><code>impl Ord for <a class="primitive" href="../primitive.u8.html">u8</a></code></li>
<li><code>impl Ord for <a class="primitive" href="../primitive.u16.html">u16</a></code></li>
<li><code>impl Ord for <a class="primitive" href="../primitive.u32.html">u32</a></code></li>
<li><code>impl Ord for <a class="primitive" href="../primitive.u64.html">u64</a></code></li>
<li><code>impl Ord for <a class="primitive" href="../primitive.isize.html">isize</a></code></li>
<li><code>impl Ord for <a class="primitive" href="../primitive.i8.html">i8</a></code></li>
<li><code>impl Ord for <a class="primitive" href="../primitive.i16.html">i16</a></code></li>
<li><code>impl Ord for <a class="primitive" href="../primitive.i32.html">i32</a></code></li>
<li><code>impl Ord for <a class="primitive" href="../primitive.i64.html">i64</a></code></li>
<li><code>impl&lt;'a, A&gt; Ord for &amp;'a A <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;'a, A&gt; Ord for &amp;'a mut A <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 0]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 1]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 2]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 3]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 4]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 5]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 6]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 7]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 8]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 9]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 10]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 11]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 12]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 13]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 14]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 15]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 16]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 17]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 18]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 19]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 20]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 21]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 22]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 23]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 24]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 25]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 26]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 27]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 28]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 29]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 30]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 31]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 32]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="struct" href="../../std/cell/struct.Cell.html" title="std::cell::Cell">Cell</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a> + <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="struct" href="../../std/cell/struct.RefCell.html" title="std::cell::RefCell">RefCell</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T, E&gt; Ord for <a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;T, E&gt; <span class="where">where E: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="primitive" href="../primitive.slice.html">[</a>T<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl Ord for <a class="primitive" href="../primitive.str.html">str</a></code></li>
<li><code>impl Ord for <a class="struct" href="../../std/fmt/struct.Error.html" title="std::fmt::Error">Error</a></code></li>
<li><code>impl&lt;A&gt; Ord for <a class="primitive" href="../primitive.tuple.html">(</a>A,<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;A, B&gt; Ord for <a class="primitive" href="../primitive.tuple.html">(</a>A, B<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, B: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;A, B, C&gt; Ord for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, B: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, C: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;A, B, C, D&gt; Ord for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, B: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, C: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, D: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;A, B, C, D, E&gt; Ord for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, B: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, C: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, D: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, E: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;A, B, C, D, E, F&gt; Ord for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, B: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, C: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, D: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, E: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, F: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G&gt; Ord for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, B: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, C: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, D: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, E: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, F: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, G: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G, H&gt; Ord for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, B: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, C: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, D: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, E: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, F: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, G: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, H: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G, H, I&gt; Ord for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, B: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, C: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, D: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, E: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, F: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, G: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, H: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, I: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G, H, I, J&gt; Ord for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, B: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, C: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, D: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, E: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, F: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, G: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, H: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, I: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, J: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G, H, I, J, K&gt; Ord for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J, K<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, B: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, C: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, D: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, E: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, F: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, G: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, H: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, I: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, J: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, K: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;A, B, C, D, E, F, G, H, I, J, K, L&gt; Ord for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J, K, L<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, B: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, C: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, D: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, E: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, F: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, G: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, H: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, I: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, J: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, K: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, L: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="struct" href="../../std/boxed/struct.Box.html" title="std::boxed::Box">Box</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="struct" href="../../std/sync/struct.Arc.html" title="std::sync::Arc">Arc</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="struct" href="../../std/rc/struct.Rc.html" title="std::rc::Rc">Rc</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;K, V&gt; Ord for <a class="struct" href="../../std/collections/btree_map/struct.BTreeMap.html" title="std::collections::btree_map::BTreeMap">BTreeMap</a>&lt;K, V&gt; <span class="where">where K: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a>, V: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="struct" href="../../std/collections/btree_set/struct.BTreeSet.html" title="std::collections::btree_set::BTreeSet">BTreeSet</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;'a, B&gt; Ord for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a, B&gt; <span class="where">where B: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a> + <a class="trait" href="../../std/borrow/trait.ToOwned.html" title="std::borrow::ToOwned">ToOwned</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;E&gt; Ord for <a class="struct" href="../../collections/enum_set/struct.EnumSet.html" title="collections::enum_set::EnumSet">EnumSet</a>&lt;E&gt; <span class="where">where E: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;A&gt; Ord for <a class="struct" href="../../std/collections/linked_list/struct.LinkedList.html" title="std::collections::linked_list::LinkedList">LinkedList</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl Ord for <a class="struct" href="../../std/string/struct.String.html" title="std::string::String">String</a></code></li>
<li><code>impl&lt;T&gt; Ord for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;A&gt; Ord for <a class="struct" href="../../std/collections/vec_deque/struct.VecDeque.html" title="std::collections::vec_deque::VecDeque">VecDeque</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl Ord for <a class="struct" href="../../std/ffi/struct.CString.html" title="std::ffi::CString">CString</a></code></li>
<li><code>impl Ord for <a class="struct" href="../../std/ffi/struct.CStr.html" title="std::ffi::CStr">CStr</a></code></li>
<li><code>impl Ord for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl Ord for <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl Ord for <a class="enum" href="../../std/net/enum.IpAddr.html" title="std::net::IpAddr">IpAddr</a></code></li>
<li><code>impl Ord for <a class="struct" href="../../std/net/struct.Ipv4Addr.html" title="std::net::Ipv4Addr">Ipv4Addr</a></code></li>
<li><code>impl Ord for <a class="struct" href="../../std/net/struct.Ipv6Addr.html" title="std::net::Ipv6Addr">Ipv6Addr</a></code></li>
<li><code>impl&lt;'a&gt; Ord for <a class="enum" href="../../std/path/enum.Prefix.html" title="std::path::Prefix">Prefix</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; Ord for <a class="struct" href="../../std/path/struct.PrefixComponent.html" title="std::path::PrefixComponent">PrefixComponent</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; Ord for <a class="enum" href="../../std/path/enum.Component.html" title="std::path::Component">Component</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; Ord for <a class="struct" href="../../std/path/struct.Components.html" title="std::path::Components">Components</a>&lt;'a&gt;</code></li>
<li><code>impl Ord for <a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a></code></li>
<li><code>impl Ord for <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl Ord for <a class="struct" href="../../std/time/struct.Duration.html" title="std::time::Duration">Duration</a></code></li>
<li><code>impl Ord for <a class="struct" href="../../std/time/struct.Instant.html" title="std::time::Instant">Instant</a></code></li>
<li><code>impl Ord for <a class="struct" href="../../std/time/struct.SystemTime.html" title="std::time::SystemTime">SystemTime</a></code></li>
</ul><script src="../../implementors/core/cmp/trait.Ord.js" async="" type="text/javascript">
                 </script></div></div><div class="outerdoc" id="trait.Write"><div class="docblock" id="trait.Write">
<h1 class="fqn"><span class="in-band">Trait <a href="../">std</a>::<wbr><a href="index.html">io</a>::<wbr><a class="trait" href="">Write</a></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><span id="render-detail">
                   <a href="javascript:void(0)" id="toggle-all-docs" title="collapse all docs">
                       [<span class="inner"></span>]
                   </a>
               </span><a class="srclink" href="../../src/std/up/src/libstd/io/mod.rs.html#846-1048" id="src-4928" title="goto source code">[src]</a></span></h1>
<pre class="rust trait">pub trait Write {
    fn <a class="fnname" href="#tymethod.write">write</a>(&amp;mut self, buf: <a class="primitive" href="../primitive.slice.html">&amp;[</a><a class="primitive" href="../primitive.u8.html">u8</a><a class="primitive" href="../primitive.slice.html">]</a>) -&gt; <a class="type" href="../../std/io/type.Result.html" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.usize.html">usize</a>&gt;;
    fn <a class="fnname" href="#tymethod.flush">flush</a>(&amp;mut self) -&gt; <a class="type" href="../../std/io/type.Result.html" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.tuple.html">()</a>&gt;;

    fn <a class="fnname" href="#method.write_all">write_all</a>(&amp;mut self, buf: <a class="primitive" href="../primitive.slice.html">&amp;[</a><a class="primitive" href="../primitive.u8.html">u8</a><a class="primitive" href="../primitive.slice.html">]</a>) -&gt; <a class="type" href="../../std/io/type.Result.html" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.tuple.html">()</a>&gt; { ... }
    fn <a class="fnname" href="#method.write_fmt">write_fmt</a>(&amp;mut self, fmt: <a class="struct" href="../../std/fmt/struct.Arguments.html" title="std::fmt::Arguments">Arguments</a>) -&gt; <a class="type" href="../../std/io/type.Result.html" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.tuple.html">()</a>&gt; { ... }
    fn <a class="fnname" href="#method.by_ref">by_ref</a>(&amp;mut self) -&gt; &amp;mut Self <span class="where">where Self: <a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span> { ... }
}</pre><div class="docblock"><p>A trait for objects which are byte-oriented sinks.</p>

<p>Implementors of the <code>Write</code> trait are sometimes called 'writers'.</p>

<p>Writers are defined by two required methods, <code>write()</code> and <code>flush()</code>:</p>

<ul>
<li><p>The <code>write()</code> method will attempt to write some data into the object,
returning how many bytes were successfully written.</p></li>
<li><p>The <code>flush()</code> method is useful for adaptors and explicit buffers
themselves for ensuring that all buffered data has been pushed out to the
'true sink'.</p></li>
</ul>

<p>Writers are intended to be composable with one another. Many implementors
throughout <code>std::io</code> take and provide types which implement the <code>Write</code>
trait.</p>

<h1 class="section-header" id="examples"><a href="#examples">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::io::prelude::*;
use std::fs::File;

fn foo() -&gt; std::io::Result&lt;()&gt; {
let mut buffer = try!(File::create("foo.txt"));

try!(buffer.write(b"some bytes"));
Ok(())
}
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">prelude</span>::<span class="op">*</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">fs</span>::<span class="ident">File</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffer</span> <span class="op">=</span> <span class="macro">try</span><span class="macro">!</span>(<span class="ident">File</span>::<span class="ident">create</span>(<span class="string">"foo.txt"</span>));

<span class="macro">try</span><span class="macro">!</span>(<span class="ident">buffer</span>.<span class="ident">write</span>(<span class="string">b"some bytes"</span>));</pre>
</div>
            <h2 id="required-methods">Required Methods</h2>
            <div class="methods">
        <h3 class="method stab " id="tymethod.write"><code>fn <a class="fnname" href="#tymethod.write">write</a>(&amp;mut self, buf: <a class="primitive" href="../primitive.slice.html">&amp;[</a><a class="primitive" href="../primitive.u8.html">u8</a><a class="primitive" href="../primitive.slice.html">]</a>) -&gt; <a class="type" href="../../std/io/type.Result.html" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.usize.html">usize</a>&gt;</code></h3><div class="docblock"><p>Write a buffer into this object, returning how many bytes were written.</p>

<p>This function will attempt to write the entire contents of <code>buf</code>, but
the entire write may not succeed, or the write may also generate an
error. A call to <code>write</code> represents <em>at most one</em> attempt to write to
any wrapped object.</p>

<p>Calls to <code>write</code> are not guaranteed to block waiting for data to be
written, and a write which would otherwise block can be indicated through
an <code>Err</code> variant.</p>

<p>If the return value is <code>Ok(n)</code> then it must be guaranteed that
<code>0 &lt;= n &lt;= buf.len()</code>. A return value of <code>0</code> typically means that the
underlying object is no longer able to accept bytes and will likely not
be able to in the future as well, or that the buffer provided is empty.</p>

<h1 class="section-header" id="errors"><a href="#errors">Errors</a></h1>
<p>Each call to <code>write</code> may generate an I/O error indicating that the
operation could not be completed. If an error is returned then no bytes
in the buffer were written to this writer.</p>

<p>It is <strong>not</strong> considered an error if the entire buffer could not be
written to this writer.</p>

<h1 class="section-header" id="examples-1"><a href="#examples-1">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::io::prelude::*;
use std::fs::File;

fn foo() -&gt; std::io::Result&lt;()&gt; {
let mut buffer = try!(File::create("foo.txt"));

try!(buffer.write(b"some bytes"));
Ok(())
}
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">prelude</span>::<span class="op">*</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">fs</span>::<span class="ident">File</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffer</span> <span class="op">=</span> <span class="macro">try</span><span class="macro">!</span>(<span class="ident">File</span>::<span class="ident">create</span>(<span class="string">"foo.txt"</span>));

<span class="macro">try</span><span class="macro">!</span>(<span class="ident">buffer</span>.<span class="ident">write</span>(<span class="string">b"some bytes"</span>));</pre>
</div><h3 class="method stab " id="tymethod.flush"><code>fn <a class="fnname" href="#tymethod.flush">flush</a>(&amp;mut self) -&gt; <a class="type" href="../../std/io/type.Result.html" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.tuple.html">()</a>&gt;</code></h3><div class="docblock"><p>Flush this output stream, ensuring that all intermediately buffered
contents reach their destination.</p>

<h1 class="section-header" id="errors-1"><a href="#errors-1">Errors</a></h1>
<p>It is considered an error if not all bytes could be written due to
I/O errors or EOF being reached.</p>

<h1 class="section-header" id="examples-2"><a href="#examples-2">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::io::prelude::*;
use std::io::BufWriter;
use std::fs::File;

fn foo() -&gt; std::io::Result&lt;()&gt; {
let mut buffer = BufWriter::new(try!(File::create("foo.txt")));

try!(buffer.write(b"some bytes"));
try!(buffer.flush());
Ok(())
}
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">prelude</span>::<span class="op">*</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">BufWriter</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">fs</span>::<span class="ident">File</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffer</span> <span class="op">=</span> <span class="ident">BufWriter</span>::<span class="ident">new</span>(<span class="macro">try</span><span class="macro">!</span>(<span class="ident">File</span>::<span class="ident">create</span>(<span class="string">"foo.txt"</span>)));

<span class="macro">try</span><span class="macro">!</span>(<span class="ident">buffer</span>.<span class="ident">write</span>(<span class="string">b"some bytes"</span>));
<span class="macro">try</span><span class="macro">!</span>(<span class="ident">buffer</span>.<span class="ident">flush</span>());</pre>
</div></div>
            <h2 id="provided-methods">Provided Methods</h2>
            <div class="methods">
        <h3 class="method stab " id="method.write_all"><code>fn <a class="fnname" href="#method.write_all">write_all</a>(&amp;mut self, buf: <a class="primitive" href="../primitive.slice.html">&amp;[</a><a class="primitive" href="../primitive.u8.html">u8</a><a class="primitive" href="../primitive.slice.html">]</a>) -&gt; <a class="type" href="../../std/io/type.Result.html" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.tuple.html">()</a>&gt;</code></h3><div class="docblock"><p>Attempts to write an entire buffer into this write.</p>

<p>This method will continuously call <code>write</code> while there is more data to
write. This method will not return until the entire buffer has been
successfully written or an error occurs. The first error generated from
this method will be returned.</p>

<h1 class="section-header" id="errors-2"><a href="#errors-2">Errors</a></h1>
<p>This function will return the first error that <code>write</code> returns.</p>

<h1 class="section-header" id="examples-3"><a href="#examples-3">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::io::prelude::*;
use std::fs::File;

fn foo() -&gt; std::io::Result&lt;()&gt; {
let mut buffer = try!(File::create("foo.txt"));

try!(buffer.write_all(b"some bytes"));
Ok(())
}
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">prelude</span>::<span class="op">*</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">fs</span>::<span class="ident">File</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffer</span> <span class="op">=</span> <span class="macro">try</span><span class="macro">!</span>(<span class="ident">File</span>::<span class="ident">create</span>(<span class="string">"foo.txt"</span>));

<span class="macro">try</span><span class="macro">!</span>(<span class="ident">buffer</span>.<span class="ident">write_all</span>(<span class="string">b"some bytes"</span>));</pre>
</div><h3 class="method stab " id="method.write_fmt"><code>fn <a class="fnname" href="#method.write_fmt">write_fmt</a>(&amp;mut self, fmt: <a class="struct" href="../../std/fmt/struct.Arguments.html" title="std::fmt::Arguments">Arguments</a>) -&gt; <a class="type" href="../../std/io/type.Result.html" title="std::io::Result">Result</a>&lt;<a class="primitive" href="../primitive.tuple.html">()</a>&gt;</code></h3><div class="docblock"><p>Writes a formatted string into this writer, returning any error
encountered.</p>

<p>This method is primarily used to interface with the
<a href="../macro.format_args!.html"><code>format_args!</code></a> macro, but it is rare that this should
explicitly be called. The <a href="../macro.write!.html"><code>write!</code></a> macro should be favored to
invoke this method instead.</p>

<p>This function internally uses the <a href="#method.write_all"><code>write_all</code></a> method on
this trait and hence will continuously write data so long as no errors
are received. This also means that partial writes are not indicated in
this signature.</p>

<h1 class="section-header" id="errors-3"><a href="#errors-3">Errors</a></h1>
<p>This function will return any I/O error reported while formatting.</p>

<h1 class="section-header" id="examples-4"><a href="#examples-4">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::io::prelude::*;
use std::fs::File;

fn foo() -&gt; std::io::Result&lt;()&gt; {
let mut buffer = try!(File::create("foo.txt"));

// this call
try!(write!(buffer, "{:.*}", 2, 1.234567));
// turns into this:
try!(buffer.write_fmt(format_args!("{:.*}", 2, 1.234567)));
Ok(())
}
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">prelude</span>::<span class="op">*</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">fs</span>::<span class="ident">File</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffer</span> <span class="op">=</span> <span class="macro">try</span><span class="macro">!</span>(<span class="ident">File</span>::<span class="ident">create</span>(<span class="string">"foo.txt"</span>));

<span class="comment">// this call</span>
<span class="macro">try</span><span class="macro">!</span>(<span class="macro">write</span><span class="macro">!</span>(<span class="ident">buffer</span>, <span class="string">"{:.*}"</span>, <span class="number">2</span>, <span class="number">1.234567</span>));
<span class="comment">// turns into this:</span>
<span class="macro">try</span><span class="macro">!</span>(<span class="ident">buffer</span>.<span class="ident">write_fmt</span>(<span class="macro">format_args</span><span class="macro">!</span>(<span class="string">"{:.*}"</span>, <span class="number">2</span>, <span class="number">1.234567</span>)));</pre>
</div><h3 class="method stab " id="method.by_ref"><code>fn <a class="fnname" href="#method.by_ref">by_ref</a>(&amp;mut self) -&gt; &amp;mut Self <span class="where">where Self: <a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></h3><div class="docblock"><p>Creates a "by reference" adaptor for this instance of <code>Write</code>.</p>

<p>The returned adaptor also implements <code>Write</code> and will simply borrow this
current writer.</p>

<h1 class="section-header" id="examples-5"><a href="#examples-5">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::io::Write;
use std::fs::File;

fn foo() -&gt; std::io::Result&lt;()&gt; {
let mut buffer = try!(File::create("foo.txt"));

let reference = buffer.by_ref();

// we can use reference just like our original buffer
try!(reference.write_all(b"some bytes"));
Ok(())
}
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">io</span>::<span class="ident">Write</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">fs</span>::<span class="ident">File</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">buffer</span> <span class="op">=</span> <span class="macro">try</span><span class="macro">!</span>(<span class="ident">File</span>::<span class="ident">create</span>(<span class="string">"foo.txt"</span>));

<span class="kw">let</span> <span class="ident">reference</span> <span class="op">=</span> <span class="ident">buffer</span>.<span class="ident">by_ref</span>();

<span class="comment">// we can use reference just like our original buffer</span>
<span class="macro">try</span><span class="macro">!</span>(<span class="ident">reference</span>.<span class="ident">write_all</span>(<span class="string">b"some bytes"</span>));</pre>
</div></div>
        <h2 id="implementors">Implementors</h2>
        <ul class="item-list" id="implementors-list">
    <li><code>impl Write for <a class="struct" href="../../std/fs/struct.File.html" title="std::fs::File">File</a></code></li>
<li><code>impl&lt;'a&gt; Write for &amp;'a <a class="struct" href="../../std/fs/struct.File.html" title="std::fs::File">File</a></code></li>
<li><code>impl&lt;W: <a class="trait" href="../../std/io/trait.Write.html" title="std::io::Write">Write</a>&gt; Write for <a class="struct" href="../../std/io/struct.BufWriter.html" title="std::io::BufWriter">BufWriter</a>&lt;W&gt;</code></li>
<li><code>impl&lt;W: <a class="trait" href="../../std/io/trait.Write.html" title="std::io::Write">Write</a>&gt; Write for <a class="struct" href="../../std/io/struct.LineWriter.html" title="std::io::LineWriter">LineWriter</a>&lt;W&gt;</code></li>
<li><code>impl&lt;'a&gt; Write for <a class="struct" href="../../std/io/struct.Cursor.html" title="std::io::Cursor">Cursor</a>&lt;<a class="primitive" href="../primitive.slice.html">&amp;'a mut [</a><a class="primitive" href="../primitive.u8.html">u8</a><a class="primitive" href="../primitive.slice.html">]</a>&gt;</code></li>
<li><code>impl Write for <a class="struct" href="../../std/io/struct.Cursor.html" title="std::io::Cursor">Cursor</a>&lt;<a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;<a class="primitive" href="../primitive.u8.html">u8</a>&gt;&gt;</code></li>
<li><code>impl Write for <a class="struct" href="../../std/io/struct.Cursor.html" title="std::io::Cursor">Cursor</a>&lt;<a class="struct" href="../../std/boxed/struct.Box.html" title="std::boxed::Box">Box</a>&lt;<a class="primitive" href="../primitive.slice.html">[</a><a class="primitive" href="../primitive.u8.html">u8</a><a class="primitive" href="../primitive.slice.html">]</a>&gt;&gt;</code></li>
<li><code>impl&lt;'a, W: <a class="trait" href="../../std/io/trait.Write.html" title="std::io::Write">Write</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a>&gt; Write for &amp;'a mut W</code></li>
<li><code>impl&lt;W: <a class="trait" href="../../std/io/trait.Write.html" title="std::io::Write">Write</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a>&gt; Write for <a class="struct" href="../../std/boxed/struct.Box.html" title="std::boxed::Box">Box</a>&lt;W&gt;</code></li>
<li><code>impl&lt;'a&gt; Write for <a class="primitive" href="../primitive.slice.html">&amp;'a mut [</a><a class="primitive" href="../primitive.u8.html">u8</a><a class="primitive" href="../primitive.slice.html">]</a></code></li>
<li><code>impl Write for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;<a class="primitive" href="../primitive.u8.html">u8</a>&gt;</code></li>
<li><code>impl Write for <a class="struct" href="../../std/io/struct.Sink.html" title="std::io::Sink">Sink</a></code></li>
<li><code>impl Write for <a class="struct" href="../../std/io/struct.Stdout.html" title="std::io::Stdout">Stdout</a></code></li>
<li><code>impl&lt;'a&gt; Write for <a class="struct" href="../../std/io/struct.StdoutLock.html" title="std::io::StdoutLock">StdoutLock</a>&lt;'a&gt;</code></li>
<li><code>impl Write for <a class="struct" href="../../std/io/struct.Stderr.html" title="std::io::Stderr">Stderr</a></code></li>
<li><code>impl&lt;'a&gt; Write for <a class="struct" href="../../std/io/struct.StderrLock.html" title="std::io::StderrLock">StderrLock</a>&lt;'a&gt;</code></li>
<li><code>impl Write for <a class="struct" href="../../std/net/struct.TcpStream.html" title="std::net::TcpStream">TcpStream</a></code></li>
<li><code>impl&lt;'a&gt; Write for &amp;'a <a class="struct" href="../../std/net/struct.TcpStream.html" title="std::net::TcpStream">TcpStream</a></code></li>
<li><code>impl Write for <a class="struct" href="../../std/os/unix/net/struct.UnixStream.html" title="std::os::unix::net::UnixStream">UnixStream</a></code></li>
<li><code>impl&lt;'a&gt; Write for &amp;'a <a class="struct" href="../../std/os/unix/net/struct.UnixStream.html" title="std::os::unix::net::UnixStream">UnixStream</a></code></li>
<li><code>impl Write for <a class="struct" href="../../std/process/struct.ChildStdin.html" title="std::process::ChildStdin">ChildStdin</a></code></li>
</ul><script src="../../implementors/std/io/trait.Write.js" async="" type="text/javascript">
                 </script></div></div><div class="outerdoc" id="iter.find"><h4 class="method" id="method.find"><code>fn <a class="fnname" href="../../std/iter/trait.Iterator.html#method.find">find</a>&lt;P&gt;(&amp;mut self, predicate: P) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;Self::<a class="trait" href="../../std/iter/trait.Iterator.html" title="std::iter::Iterator">Item</a>&gt; <span class="where">where P: <a class="trait" href="../../std/ops/trait.FnMut.html" title="std::ops::FnMut">FnMut</a>(&amp;Self::<a class="trait" href="../../std/iter/trait.Iterator.html" title="std::iter::Iterator">Item</a>) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></span></code></h4><div class="docblock"><p>Searches for an element of an iterator that satisfies a predicate. <a href="../../std/iter/trait.Iterator.html#method.find">Read more</a></p>
</div></div><div class="outerdoc" id="hm.hm"><div class="docblock" id="hm.hm"><p>A hash map implementation which uses linear probing with Robin
Hood bucket stealing.</p>

<p>The hashes are all keyed by the thread-local random number generator
on creation by default. This means that the ordering of the keys is
randomized, but makes the tables more resistant to
denial-of-service attacks (Hash DoS). No guarantees are made to the
quality of the random data. The implementation uses the best available
random data from your platform at the time of creation. This behavior
can be overridden with one of the constructors.</p>

<p>It is required that the keys implement the <code>Eq</code> and <code>Hash</code> traits, although
this can frequently be achieved by using <code>#[derive(PartialEq, Eq, Hash)]</code>.
If you implement these yourself, it is important that the following
property holds:</p>

<pre><code class="language-text">k1 == k2 -&gt; hash(k1) == hash(k2)
</code></pre>

<p>In other words, if two keys are equal, their hashes must be equal.</p>

<p>It is a logic error for a key to be modified in such a way that the key's
hash, as determined by the <code>Hash</code> trait, or its equality, as determined by
the <code>Eq</code> trait, changes while it is in the map. This is normally only
possible through <code>Cell</code>, <code>RefCell</code>, global state, I/O, or unsafe code.</p>

<p>Relevant papers/articles:</p>

<ol>
<li>Pedro Celis. <a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf">"Robin Hood Hashing"</a></li>
<li>Emmanuel Goossaert. <a href="http://codecapsule.com/2013/11/11/robin-hood-hashing/">"Robin Hood
hashing"</a></li>
<li>Emmanuel Goossaert. <a href="http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/">"Robin Hood hashing: backward shift
deletion"</a></li>
</ol>

<h1 class="section-header" id="examples"><a href="#examples">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;

// type inference lets us omit an explicit type signature (which
// would be `HashMap&lt;&amp;str, &amp;str&gt;` in this example).
let mut book_reviews = HashMap::new();

// review some books.
book_reviews.insert("Adventures of Huckleberry Finn",    "My favorite book.");
book_reviews.insert("Grimms' Fairy Tales",               "Masterpiece.");
book_reviews.insert("Pride and Prejudice",               "Very enjoyable.");
book_reviews.insert("The Adventures of Sherlock Holmes", "Eye lyked it alot.");

// check for a specific one.
if !book_reviews.contains_key("Les Misrables") {
    println!("We've got {} reviews, but Les Misrables ain't one.",
             book_reviews.len());
}

// oops, this review has a lot of spelling mistakes, let's delete it.
book_reviews.remove("The Adventures of Sherlock Holmes");

// look up the values associated with some keys.
let to_find = ["Pride and Prejudice", "Alice's Adventure in Wonderland"];
for book in &amp;to_find {
    match book_reviews.get(book) {
        Some(review) =&gt; println!("{}: {}", book, review),
        None =&gt; println!("{} is unreviewed.", book)
    }
}

// iterate over everything.
for (book, review) in &amp;book_reviews {
    println!("{}: \"{}\"", book, review);
}
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="comment">// type inference lets us omit an explicit type signature (which</span>
<span class="comment">// would be `HashMap&lt;&amp;str, &amp;str&gt;` in this example).</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">book_reviews</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();

<span class="comment">// review some books.</span>
<span class="ident">book_reviews</span>.<span class="ident">insert</span>(<span class="string">"Adventures of Huckleberry Finn"</span>,    <span class="string">"My favorite book."</span>);
<span class="ident">book_reviews</span>.<span class="ident">insert</span>(<span class="string">"Grimms' Fairy Tales"</span>,               <span class="string">"Masterpiece."</span>);
<span class="ident">book_reviews</span>.<span class="ident">insert</span>(<span class="string">"Pride and Prejudice"</span>,               <span class="string">"Very enjoyable."</span>);
<span class="ident">book_reviews</span>.<span class="ident">insert</span>(<span class="string">"The Adventures of Sherlock Holmes"</span>, <span class="string">"Eye lyked it alot."</span>);

<span class="comment">// check for a specific one.</span>
<span class="kw">if</span> <span class="op">!</span><span class="ident">book_reviews</span>.<span class="ident">contains_key</span>(<span class="string">"Les Misrables"</span>) {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">"We've got {} reviews, but Les Misrables ain't one."</span>,
             <span class="ident">book_reviews</span>.<span class="ident">len</span>());
}

<span class="comment">// oops, this review has a lot of spelling mistakes, let's delete it.</span>
<span class="ident">book_reviews</span>.<span class="ident">remove</span>(<span class="string">"The Adventures of Sherlock Holmes"</span>);

<span class="comment">// look up the values associated with some keys.</span>
<span class="kw">let</span> <span class="ident">to_find</span> <span class="op">=</span> [<span class="string">"Pride and Prejudice"</span>, <span class="string">"Alice's Adventure in Wonderland"</span>];
<span class="kw">for</span> <span class="ident">book</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">to_find</span> {
    <span class="kw">match</span> <span class="ident">book_reviews</span>.<span class="ident">get</span>(<span class="ident">book</span>) {
        <span class="prelude-val">Some</span>(<span class="ident">review</span>) <span class="op">=&gt;</span> <span class="macro">println</span><span class="macro">!</span>(<span class="string">"{}: {}"</span>, <span class="ident">book</span>, <span class="ident">review</span>),
        <span class="prelude-val">None</span> <span class="op">=&gt;</span> <span class="macro">println</span><span class="macro">!</span>(<span class="string">"{} is unreviewed."</span>, <span class="ident">book</span>)
    }
}

<span class="comment">// iterate over everything.</span>
<span class="kw">for</span> (<span class="ident">book</span>, <span class="ident">review</span>) <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">book_reviews</span> {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">"{}: \"{}\""</span>, <span class="ident">book</span>, <span class="ident">review</span>);
}</pre>

<p><code>HashMap</code> also implements an <a href="#method.entry"><code>Entry API</code></a>, which allows
for more complex methods of getting, setting, updating and removing keys and
their values:</p>

<span class="rusttest">fn main() {
    use std::collections::HashMap;

// type inference lets us omit an explicit type signature (which
// would be `HashMap&lt;&amp;str, u8&gt;` in this example).
let mut player_stats = HashMap::new();

fn random_stat_buff() -&gt; u8 {
    // could actually return some random value here - let's just return
    // some fixed value for now
    42
}

// insert a key only if it doesn't already exist
player_stats.entry("health").or_insert(100);

// insert a key using a function that provides a new value only if it
// doesn't already exist
player_stats.entry("defence").or_insert_with(random_stat_buff);

// update a key, guarding against the key possibly not being set
let stat = player_stats.entry("attack").or_insert(100);
*stat += random_stat_buff();
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="comment">// type inference lets us omit an explicit type signature (which</span>
<span class="comment">// would be `HashMap&lt;&amp;str, u8&gt;` in this example).</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">player_stats</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();

<span class="kw">fn</span> <span class="ident">random_stat_buff</span>() <span class="op">-&gt;</span> <span class="ident">u8</span> {
    <span class="comment">// could actually return some random value here - let's just return</span>
    <span class="comment">// some fixed value for now</span>
    <span class="number">42</span>
}

<span class="comment">// insert a key only if it doesn't already exist</span>
<span class="ident">player_stats</span>.<span class="ident">entry</span>(<span class="string">"health"</span>).<span class="ident">or_insert</span>(<span class="number">100</span>);

<span class="comment">// insert a key using a function that provides a new value only if it</span>
<span class="comment">// doesn't already exist</span>
<span class="ident">player_stats</span>.<span class="ident">entry</span>(<span class="string">"defence"</span>).<span class="ident">or_insert_with</span>(<span class="ident">random_stat_buff</span>);

<span class="comment">// update a key, guarding against the key possibly not being set</span>
<span class="kw">let</span> <span class="ident">stat</span> <span class="op">=</span> <span class="ident">player_stats</span>.<span class="ident">entry</span>(<span class="string">"attack"</span>).<span class="ident">or_insert</span>(<span class="number">100</span>);
<span class="op">*</span><span class="ident">stat</span> <span class="op">+=</span> <span class="ident">random_stat_buff</span>();</pre>

<p>The easiest way to use <code>HashMap</code> with a custom type as key is to derive <code>Eq</code> and <code>Hash</code>.
We must also derive <code>PartialEq</code>.</p>

<span class="rusttest">fn main() {
    use std::collections::HashMap;

#[derive(Hash, Eq, PartialEq, Debug)]
struct Viking {
    name: String,
    country: String,
}

impl Viking {
    /// Create a new Viking.
    fn new(name: &amp;str, country: &amp;str) -&gt; Viking {
        Viking { name: name.to_string(), country: country.to_string() }
    }
}

// Use a HashMap to store the vikings' health points.
let mut vikings = HashMap::new();

vikings.insert(Viking::new("Einar", "Norway"), 25);
vikings.insert(Viking::new("Olaf", "Denmark"), 24);
vikings.insert(Viking::new("Harald", "Iceland"), 12);

// Use derived implementation to print the status of the vikings.
for (viking, health) in &amp;vikings {
    println!("{:?} has {} hp", viking, health);
}
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Hash</span>, <span class="ident">Eq</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">struct</span> <span class="ident">Viking</span> {
    <span class="ident">name</span>: <span class="ident">String</span>,
    <span class="ident">country</span>: <span class="ident">String</span>,
}

<span class="kw">impl</span> <span class="ident">Viking</span> {
    <span class="doccomment">/// Create a new Viking.</span>
    <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">name</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>, <span class="ident">country</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-&gt;</span> <span class="ident">Viking</span> {
        <span class="ident">Viking</span> { <span class="ident">name</span>: <span class="ident">name</span>.<span class="ident">to_string</span>(), <span class="ident">country</span>: <span class="ident">country</span>.<span class="ident">to_string</span>() }
    }
}

<span class="comment">// Use a HashMap to store the vikings' health points.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vikings</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();

<span class="ident">vikings</span>.<span class="ident">insert</span>(<span class="ident">Viking</span>::<span class="ident">new</span>(<span class="string">"Einar"</span>, <span class="string">"Norway"</span>), <span class="number">25</span>);
<span class="ident">vikings</span>.<span class="ident">insert</span>(<span class="ident">Viking</span>::<span class="ident">new</span>(<span class="string">"Olaf"</span>, <span class="string">"Denmark"</span>), <span class="number">24</span>);
<span class="ident">vikings</span>.<span class="ident">insert</span>(<span class="ident">Viking</span>::<span class="ident">new</span>(<span class="string">"Harald"</span>, <span class="string">"Iceland"</span>), <span class="number">12</span>);

<span class="comment">// Use derived implementation to print the status of the vikings.</span>
<span class="kw">for</span> (<span class="ident">viking</span>, <span class="ident">health</span>) <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">vikings</span> {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">"{:?} has {} hp"</span>, <span class="ident">viking</span>, <span class="ident">health</span>);
}</pre>
</div></div><div class="outerdoc" id="3951816119501521738.new"><h4 class="method" id="method.new"><code>fn <a class="fnname" href="#method.new">new</a>() -&gt; <a class="struct" href="../../std/collections/struct.HashMap.html" title="std::collections::HashMap">HashMap</a>&lt;K, V, <a class="struct" href="../../std/collections/hash_map/struct.RandomState.html" title="std::collections::hash_map::RandomState">RandomState</a>&gt;</code></h4><div class="docblock"><p>Creates an empty HashMap.</p>

<h1 class="section-header" id="examples-1"><a href="#examples-1">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;
let mut map: HashMap&lt;&amp;str, isize&gt; = HashMap::new();
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">map</span>: <span class="ident">HashMap</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span>, <span class="ident">isize</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();</pre>
</div></div><div class="outerdoc" id="8191949285084334880.with_capacity"><h4 class="method" id="method.with_capacity"><code>fn <a class="fnname" href="#method.with_capacity">with_capacity</a>(capacity: <a class="primitive" href="../primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../std/collections/struct.HashMap.html" title="std::collections::HashMap">HashMap</a>&lt;K, V, <a class="struct" href="../../std/collections/hash_map/struct.RandomState.html" title="std::collections::hash_map::RandomState">RandomState</a>&gt;</code></h4><div class="docblock"><p>Creates an empty hash map with the given initial capacity.</p>

<h1 class="section-header" id="examples-2"><a href="#examples-2">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;
let mut map: HashMap&lt;&amp;str, isize&gt; = HashMap::with_capacity(10);
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">map</span>: <span class="ident">HashMap</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span>, <span class="ident">isize</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">with_capacity</span>(<span class="number">10</span>);</pre>
</div></div><div class="outerdoc" id="hm.clone"><h4 class="method" id="method.clone"><code>fn <a class="fnname" href="../../std/clone/trait.Clone.html#tymethod.clone">clone</a>(&amp;self) -&gt; <a class="struct" href="../../std/collections/struct.HashMap.html" title="std::collections::HashMap">HashMap</a>&lt;K, V, S&gt;</code></h4><div class="docblock"><p>Returns a copy of the value. <a href="../../std/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div></div><div class="outerdoc" id="hm.index"><h4 class="method" id="method.index"><code>fn <a class="fnname" href="../../std/ops/trait.Index.html#tymethod.index">index</a>(&amp;self, index: &amp;Q) -&gt; &amp;V</code></h4><div class="docblock"><p>The method for the indexing (<code>Foo[Bar]</code>) operation</p>
</div></div><div class="outerdoc" id="16914058508379879378.len"><h4 class="method" id="method.len"><code>fn <a class="fnname" href="#method.len">len</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.usize.html">usize</a></code></h4><div class="docblock"><p>Returns the number of elements in the map.</p>

<h1 class="section-header" id="examples-14"><a href="#examples-14">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;

let mut a = HashMap::new();
assert_eq!(a.len(), 0);
a.insert(1, "a");
assert_eq!(a.len(), 1);
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">len</span>(), <span class="number">0</span>);
<span class="ident">a</span>.<span class="ident">insert</span>(<span class="number">1</span>, <span class="string">"a"</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">len</span>(), <span class="number">1</span>);</pre>
</div></div><div class="outerdoc" id="2561269595886650242.iter"><h4 class="method" id="method.iter"><code>fn <a class="fnname" href="#method.iter">iter</a>(&amp;self) -&gt; <a class="struct" href="../../std/collections/hash_map/struct.Iter.html" title="std::collections::hash_map::Iter">Iter</a>&lt;K, V&gt;</code></h4><div class="docblock"><p>An iterator visiting all key-value pairs in arbitrary order.
Iterator element type is <code>(&amp;'a K, &amp;'a V)</code>.</p>

<h1 class="section-header" id="examples-11"><a href="#examples-11">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;

let mut map = HashMap::new();
map.insert("a", 1);
map.insert("b", 2);
map.insert("c", 3);

for (key, val) in map.iter() {
    println!("key: {} val: {}", key, val);
}
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">map</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="string">"a"</span>, <span class="number">1</span>);
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="string">"b"</span>, <span class="number">2</span>);
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="string">"c"</span>, <span class="number">3</span>);

<span class="kw">for</span> (<span class="ident">key</span>, <span class="ident">val</span>) <span class="kw">in</span> <span class="ident">map</span>.<span class="ident">iter</span>() {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">"key: {} val: {}"</span>, <span class="ident">key</span>, <span class="ident">val</span>);
}</pre>
</div></div><div class="outerdoc" id="9387861970427059807.iter_mut"><h4 class="method" id="method.iter_mut"><code>fn <a class="fnname" href="#method.iter_mut">iter_mut</a>(&amp;mut self) -&gt; <a class="struct" href="../../std/collections/hash_map/struct.IterMut.html" title="std::collections::hash_map::IterMut">IterMut</a>&lt;K, V&gt;</code></h4><div class="docblock"><p>An iterator visiting all key-value pairs in arbitrary order,
with mutable references to the values.
Iterator element type is <code>(&amp;'a K, &amp;'a mut V)</code>.</p>

<h1 class="section-header" id="examples-12"><a href="#examples-12">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;

let mut map = HashMap::new();
map.insert("a", 1);
map.insert("b", 2);
map.insert("c", 3);

// Update all values
for (_, val) in map.iter_mut() {
    *val *= 2;
}

for (key, val) in &amp;map {
    println!("key: {} val: {}", key, val);
}
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">map</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="string">"a"</span>, <span class="number">1</span>);
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="string">"b"</span>, <span class="number">2</span>);
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="string">"c"</span>, <span class="number">3</span>);

<span class="comment">// Update all values</span>
<span class="kw">for</span> (_, <span class="ident">val</span>) <span class="kw">in</span> <span class="ident">map</span>.<span class="ident">iter_mut</span>() {
    <span class="op">*</span><span class="ident">val</span> <span class="op">*=</span> <span class="number">2</span>;
}

<span class="kw">for</span> (<span class="ident">key</span>, <span class="ident">val</span>) <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">map</span> {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">"key: {} val: {}"</span>, <span class="ident">key</span>, <span class="ident">val</span>);
}</pre>
</div></div><div class="outerdoc" id="16911220232665630235.into_iter"><h4 class="method" id="method.into_iter"><code>fn <a class="fnname" href="../../std/iter/trait.IntoIterator.html#tymethod.into_iter">into_iter</a>(self) -&gt; <a class="struct" href="../../std/collections/hash_map/struct.Iter.html" title="std::collections::hash_map::Iter">Iter</a>&lt;'a, K, V&gt;</code></h4><div class="docblock"><p>Creates an iterator from a value. <a href="../../std/iter/trait.IntoIterator.html#tymethod.into_iter">Read more</a></p>
</div></div><div class="outerdoc" id="17021325784318796058.keys"><h4 class="method" id="method.keys"><code>fn <a class="fnname" href="#method.keys">keys</a>(&amp;self) -&gt; <a class="struct" href="../../std/collections/hash_map/struct.Keys.html" title="std::collections::hash_map::Keys">Keys</a>&lt;K, V&gt;</code></h4><div class="docblock"><p>An iterator visiting all keys in arbitrary order.
Iterator element type is <code>&amp;'a K</code>.</p>

<h1 class="section-header" id="examples-8"><a href="#examples-8">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;

let mut map = HashMap::new();
map.insert("a", 1);
map.insert("b", 2);
map.insert("c", 3);

for key in map.keys() {
    println!("{}", key);
}
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">map</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="string">"a"</span>, <span class="number">1</span>);
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="string">"b"</span>, <span class="number">2</span>);
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="string">"c"</span>, <span class="number">3</span>);

<span class="kw">for</span> <span class="ident">key</span> <span class="kw">in</span> <span class="ident">map</span>.<span class="ident">keys</span>() {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">"{}"</span>, <span class="ident">key</span>);
}</pre>
</div></div><div class="outerdoc" id="4366484008278958505.values"><h4 class="method" id="method.values"><code>fn <a class="fnname" href="#method.values">values</a>(&amp;self) -&gt; <a class="struct" href="../../std/collections/hash_map/struct.Values.html" title="std::collections::hash_map::Values">Values</a>&lt;K, V&gt;</code></h4><div class="docblock"><p>An iterator visiting all values in arbitrary order.
Iterator element type is <code>&amp;'a V</code>.</p>

<h1 class="section-header" id="examples-9"><a href="#examples-9">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;

let mut map = HashMap::new();
map.insert("a", 1);
map.insert("b", 2);
map.insert("c", 3);

for val in map.values() {
    println!("{}", val);
}
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">map</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="string">"a"</span>, <span class="number">1</span>);
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="string">"b"</span>, <span class="number">2</span>);
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="string">"c"</span>, <span class="number">3</span>);

<span class="kw">for</span> <span class="ident">val</span> <span class="kw">in</span> <span class="ident">map</span>.<span class="ident">values</span>() {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">"{}"</span>, <span class="ident">val</span>);
}</pre>
</div></div><div class="outerdoc" id="12268253870461834768.values_mut"><h4 class="method" id="method.values_mut"><code>fn <a class="fnname" href="#method.values_mut">values_mut</a>(&amp;mut self) -&gt; <a class="struct" href="../../std/collections/hash_map/struct.ValuesMut.html" title="std::collections::hash_map::ValuesMut">ValuesMut</a>&lt;K, V&gt;</code><div class="since" title="Stable since Rust version 1.10.0">1.10.0</div></h4><div class="docblock"><p>An iterator visiting all values mutably in arbitrary order.
Iterator element type is <code>&amp;'a mut V</code>.</p>

<h1 class="section-header" id="examples-10"><a href="#examples-10">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;

let mut map = HashMap::new();

map.insert("a", 1);
map.insert("b", 2);
map.insert("c", 3);

for val in map.values_mut() {
    *val = *val + 10;
}

for val in map.values() {
    print!("{}", val);
}
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">map</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();

<span class="ident">map</span>.<span class="ident">insert</span>(<span class="string">"a"</span>, <span class="number">1</span>);
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="string">"b"</span>, <span class="number">2</span>);
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="string">"c"</span>, <span class="number">3</span>);

<span class="kw">for</span> <span class="ident">val</span> <span class="kw">in</span> <span class="ident">map</span>.<span class="ident">values_mut</span>() {
    <span class="op">*</span><span class="ident">val</span> <span class="op">=</span> <span class="op">*</span><span class="ident">val</span> <span class="op">+</span> <span class="number">10</span>;
}

<span class="kw">for</span> <span class="ident">val</span> <span class="kw">in</span> <span class="ident">map</span>.<span class="ident">values</span>() {
    <span class="macro">print</span><span class="macro">!</span>(<span class="string">"{}"</span>, <span class="ident">val</span>);
}</pre>
</div></div><div class="outerdoc" id="6296352860526464879.is_empty"><h4 class="method" id="method.is_empty"><code>fn <a class="fnname" href="#method.is_empty">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h4><div class="docblock"><p>Returns true if the map contains no elements.</p>

<h1 class="section-header" id="examples-15"><a href="#examples-15">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;

let mut a = HashMap::new();
assert!(a.is_empty());
a.insert(1, "a");
assert!(!a.is_empty());
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">is_empty</span>());
<span class="ident">a</span>.<span class="ident">insert</span>(<span class="number">1</span>, <span class="string">"a"</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">a</span>.<span class="ident">is_empty</span>());</pre>
</div></div><div class="outerdoc" id="15256724127138141247.contains_key"><h4 class="method" id="method.contains_key"><code>fn <a class="fnname" href="#method.contains_key">contains_key</a>&lt;Q: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a>&gt;(&amp;self, k: &amp;Q) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a> <span class="where">where K: <a class="trait" href="../../std/borrow/trait.Borrow.html" title="std::borrow::Borrow">Borrow</a>&lt;Q&gt;, Q: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a> + <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></h4><div class="docblock"><p>Returns true if the map contains a value for the specified key.</p>

<p>The key may be any borrowed form of the map's key type, but
<code>Hash</code> and <code>Eq</code> on the borrowed form <em>must</em> match those for
the key type.</p>

<h1 class="section-header" id="examples-19"><a href="#examples-19">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;

let mut map = HashMap::new();
map.insert(1, "a");
assert_eq!(map.contains_key(&amp;1), true);
assert_eq!(map.contains_key(&amp;2), false);
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">map</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="number">1</span>, <span class="string">"a"</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">map</span>.<span class="ident">contains_key</span>(<span class="kw-2">&amp;</span><span class="number">1</span>), <span class="boolvalue">true</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">map</span>.<span class="ident">contains_key</span>(<span class="kw-2">&amp;</span><span class="number">2</span>), <span class="boolvalue">false</span>);</pre>
</div></div><div class="outerdoc" id="10306206937336477769.get"><h4 class="method" id="method.get"><code>fn <a class="fnname" href="#method.get">get</a>&lt;Q: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a>&gt;(&amp;self, k: &amp;Q) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;&amp;V&gt; <span class="where">where K: <a class="trait" href="../../std/borrow/trait.Borrow.html" title="std::borrow::Borrow">Borrow</a>&lt;Q&gt;, Q: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a> + <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></h4><div class="docblock"><p>Returns a reference to the value corresponding to the key.</p>

<p>The key may be any borrowed form of the map's key type, but
<code>Hash</code> and <code>Eq</code> on the borrowed form <em>must</em> match those for
the key type.</p>

<h1 class="section-header" id="examples-18"><a href="#examples-18">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;

let mut map = HashMap::new();
map.insert(1, "a");
assert_eq!(map.get(&amp;1), Some(&amp;"a"));
assert_eq!(map.get(&amp;2), None);
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">map</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="number">1</span>, <span class="string">"a"</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">map</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="number">1</span>), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="string">"a"</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">map</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="number">2</span>), <span class="prelude-val">None</span>);</pre>
</div></div><div class="outerdoc" id="9241196281296325969.get_mut"><h4 class="method" id="method.get_mut"><code>fn <a class="fnname" href="#method.get_mut">get_mut</a>&lt;Q: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a>&gt;(&amp;mut self, k: &amp;Q) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;&amp;mut V&gt; <span class="where">where K: <a class="trait" href="../../std/borrow/trait.Borrow.html" title="std::borrow::Borrow">Borrow</a>&lt;Q&gt;, Q: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a> + <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></h4><div class="docblock"><p>Returns a mutable reference to the value corresponding to the key.</p>

<p>The key may be any borrowed form of the map's key type, but
<code>Hash</code> and <code>Eq</code> on the borrowed form <em>must</em> match those for
the key type.</p>

<h1 class="section-header" id="examples-20"><a href="#examples-20">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;

let mut map = HashMap::new();
map.insert(1, "a");
if let Some(x) = map.get_mut(&amp;1) {
    *x = "b";
}
assert_eq!(map[&amp;1], "b");
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">map</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="number">1</span>, <span class="string">"a"</span>);
<span class="kw">if</span> <span class="kw">let</span> <span class="prelude-val">Some</span>(<span class="ident">x</span>) <span class="op">=</span> <span class="ident">map</span>.<span class="ident">get_mut</span>(<span class="kw-2">&amp;</span><span class="number">1</span>) {
    <span class="op">*</span><span class="ident">x</span> <span class="op">=</span> <span class="string">"b"</span>;
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">map</span>[<span class="kw-2">&amp;</span><span class="number">1</span>], <span class="string">"b"</span>);</pre>
</div></div><div class="outerdoc" id="8540415240848312525.entry"><h4 class="method" id="method.entry"><code>fn <a class="fnname" href="#method.entry">entry</a>(&amp;mut self, key: K) -&gt; <a class="enum" href="../../std/collections/hash_map/enum.Entry.html" title="std::collections::hash_map::Entry">Entry</a>&lt;K, V&gt;</code></h4><div class="docblock"><p>Gets the given key's corresponding entry in the map for in-place manipulation.</p>

<h1 class="section-header" id="examples-13"><a href="#examples-13">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;

let mut letters = HashMap::new();

for ch in "a short treatise on fungi".chars() {
    let counter = letters.entry(ch).or_insert(0);
    *counter += 1;
}

assert_eq!(letters[&amp;'s'], 2);
assert_eq!(letters[&amp;'t'], 3);
assert_eq!(letters[&amp;'u'], 1);
assert_eq!(letters.get(&amp;'y'), None);
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">letters</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();

<span class="kw">for</span> <span class="ident">ch</span> <span class="kw">in</span> <span class="string">"a short treatise on fungi"</span>.<span class="ident">chars</span>() {
    <span class="kw">let</span> <span class="ident">counter</span> <span class="op">=</span> <span class="ident">letters</span>.<span class="ident">entry</span>(<span class="ident">ch</span>).<span class="ident">or_insert</span>(<span class="number">0</span>);
    <span class="op">*</span><span class="ident">counter</span> <span class="op">+=</span> <span class="number">1</span>;
}

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">letters</span>[<span class="kw-2">&amp;</span><span class="string">'s'</span>], <span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">letters</span>[<span class="kw-2">&amp;</span><span class="string">'t'</span>], <span class="number">3</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">letters</span>[<span class="kw-2">&amp;</span><span class="string">'u'</span>], <span class="number">1</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">letters</span>.<span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="string">'y'</span>), <span class="prelude-val">None</span>);</pre>
</div></div><div class="outerdoc" id="354554368606142782.drain"><h4 class="method" id="method.drain"><code>fn <a class="fnname" href="#method.drain">drain</a>(&amp;mut self) -&gt; <a class="struct" href="../../std/collections/hash_map/struct.Drain.html" title="std::collections::hash_map::Drain">Drain</a>&lt;K, V&gt;</code><div class="since" title="Stable since Rust version 1.6.0">1.6.0</div></h4><div class="docblock"><p>Clears the map, returning all key-value pairs as an iterator. Keeps the
allocated memory for reuse.</p>

<h1 class="section-header" id="examples-16"><a href="#examples-16">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;

let mut a = HashMap::new();
a.insert(1, "a");
a.insert(2, "b");

for (k, v) in a.drain().take(1) {
    assert!(k == 1 || k == 2);
    assert!(v == "a" || v == "b");
}

assert!(a.is_empty());
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();
<span class="ident">a</span>.<span class="ident">insert</span>(<span class="number">1</span>, <span class="string">"a"</span>);
<span class="ident">a</span>.<span class="ident">insert</span>(<span class="number">2</span>, <span class="string">"b"</span>);

<span class="kw">for</span> (<span class="ident">k</span>, <span class="ident">v</span>) <span class="kw">in</span> <span class="ident">a</span>.<span class="ident">drain</span>().<span class="ident">take</span>(<span class="number">1</span>) {
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">k</span> <span class="op">==</span> <span class="number">1</span> <span class="op">||</span> <span class="ident">k</span> <span class="op">==</span> <span class="number">2</span>);
    <span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span> <span class="op">==</span> <span class="string">"a"</span> <span class="op">||</span> <span class="ident">v</span> <span class="op">==</span> <span class="string">"b"</span>);
}

<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">is_empty</span>());</pre>
</div></div><div class="outerdoc" id="12816268798660319156.clear"><h4 class="method" id="method.clear"><code>fn <a class="fnname" href="#method.clear">clear</a>(&amp;mut self)</code></h4><div class="docblock"><p>Clears the map, removing all key-value pairs. Keeps the allocated memory
for reuse.</p>

<h1 class="section-header" id="examples-17"><a href="#examples-17">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;

let mut a = HashMap::new();
a.insert(1, "a");
a.clear();
assert!(a.is_empty());
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">a</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();
<span class="ident">a</span>.<span class="ident">insert</span>(<span class="number">1</span>, <span class="string">"a"</span>);
<span class="ident">a</span>.<span class="ident">clear</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">is_empty</span>());</pre>
</div></div><div class="outerdoc" id="hm.extend"><h4 class="method" id="method.extend"><code>fn <a class="fnname" href="../../std/iter/trait.Extend.html#tymethod.extend">extend</a>&lt;T: <a class="trait" href="../../std/iter/trait.IntoIterator.html" title="std::iter::IntoIterator">IntoIterator</a>&lt;Item=<a class="primitive" href="../primitive.tuple.html">(</a>K, V<a class="primitive" href="../primitive.tuple.html">)</a>&gt;&gt;(&amp;mut self, iter: T)</code></h4><div class="docblock"><p>Extends a collection with the contents of an iterator. <a href="../../std/iter/trait.Extend.html#tymethod.extend">Read more</a></p>
</div></div><div class="outerdoc" id="hm.extend-1"><h4 class="method" id="method.extend-1"><code>fn <a class="fnname" href="../../std/iter/trait.Extend.html#tymethod.extend">extend</a>&lt;T: <a class="trait" href="../../std/iter/trait.IntoIterator.html" title="std::iter::IntoIterator">IntoIterator</a>&lt;Item=<a class="primitive" href="../primitive.tuple.html">(</a>&amp;'a K, &amp;'a V<a class="primitive" href="../primitive.tuple.html">)</a>&gt;&gt;(&amp;mut self, iter: T)</code></h4><div class="docblock"><p>Extends a collection with the contents of an iterator. <a href="../../std/iter/trait.Extend.html#tymethod.extend">Read more</a></p>
</div></div><div class="outerdoc" id="6629847579497595584.insert"><h4 class="method" id="method.insert"><code>fn <a class="fnname" href="#method.insert">insert</a>(&amp;mut self, k: K, v: V) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;V&gt;</code></h4><div class="docblock"><p>Inserts a key-value pair into the map.</p>

<p>If the map did not have this key present, <code>None</code> is returned.</p>

<p>If the map did have this key present, the value is updated, and the old
value is returned. The key is not updated, though; this matters for
types that can be <code>==</code> without being identical. See the <a href="index.html#insert-and-complex-keys">module-level
documentation</a> for more.</p>

<h1 class="section-header" id="examples-21"><a href="#examples-21">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;

let mut map = HashMap::new();
assert_eq!(map.insert(37, "a"), None);
assert_eq!(map.is_empty(), false);

map.insert(37, "b");
assert_eq!(map.insert(37, "c"), Some("b"));
assert_eq!(map[&amp;37], "c");
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">map</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">map</span>.<span class="ident">insert</span>(<span class="number">37</span>, <span class="string">"a"</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">map</span>.<span class="ident">is_empty</span>(), <span class="boolvalue">false</span>);

<span class="ident">map</span>.<span class="ident">insert</span>(<span class="number">37</span>, <span class="string">"b"</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">map</span>.<span class="ident">insert</span>(<span class="number">37</span>, <span class="string">"c"</span>), <span class="prelude-val">Some</span>(<span class="string">"b"</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">map</span>[<span class="kw-2">&amp;</span><span class="number">37</span>], <span class="string">"c"</span>);</pre>
</div></div><div class="outerdoc" id="15986064613564575763.remove"><h4 class="method" id="method.remove"><code>fn <a class="fnname" href="#method.remove">remove</a>&lt;Q: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a>&gt;(&amp;mut self, k: &amp;Q) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;V&gt; <span class="where">where K: <a class="trait" href="../../std/borrow/trait.Borrow.html" title="std::borrow::Borrow">Borrow</a>&lt;Q&gt;, Q: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a> + <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a></span></code></h4><div class="docblock"><p>Removes a key from the map, returning the value at the key if the key
was previously in the map.</p>

<p>The key may be any borrowed form of the map's key type, but
<code>Hash</code> and <code>Eq</code> on the borrowed form <em>must</em> match those for
the key type.</p>

<h1 class="section-header" id="examples-22"><a href="#examples-22">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;

let mut map = HashMap::new();
map.insert(1, "a");
assert_eq!(map.remove(&amp;1), Some("a"));
assert_eq!(map.remove(&amp;1), None);
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">map</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="number">1</span>, <span class="string">"a"</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">map</span>.<span class="ident">remove</span>(<span class="kw-2">&amp;</span><span class="number">1</span>), <span class="prelude-val">Some</span>(<span class="string">"a"</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">map</span>.<span class="ident">remove</span>(<span class="kw-2">&amp;</span><span class="number">1</span>), <span class="prelude-val">None</span>);</pre>
</div></div><div class="outerdoc" id="13596212680900755199.from_iter"><h4 class="method" id="method.from_iter"><code>fn <a class="fnname" href="../../std/iter/trait.FromIterator.html#tymethod.from_iter">from_iter</a>&lt;T: <a class="trait" href="../../std/iter/trait.IntoIterator.html" title="std::iter::IntoIterator">IntoIterator</a>&lt;Item=<a class="primitive" href="../primitive.tuple.html">(</a>K, V<a class="primitive" href="../primitive.tuple.html">)</a>&gt;&gt;(iter: T) -&gt; <a class="struct" href="../../std/collections/struct.HashMap.html" title="std::collections::HashMap">HashMap</a>&lt;K, V, S&gt;</code></h4><div class="docblock"><p>Creates a value from an iterator. <a href="../../std/iter/trait.FromIterator.html#tymethod.from_iter">Read more</a></p>
</div></div><div class="outerdoc" id="14837119453722379474.capacity"><h4 class="method" id="method.capacity"><code>fn <a class="fnname" href="#method.capacity">capacity</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.usize.html">usize</a></code></h4><div class="docblock"><p>Returns the number of elements the map can hold without reallocating.</p>

<p>This number is a lower bound; the <code>HashMap&lt;K, V&gt;</code> might be able to hold
more, but is guaranteed to be able to hold at least this many.</p>

<h1 class="section-header" id="examples-5"><a href="#examples-5">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;
let map: HashMap&lt;isize, isize&gt; = HashMap::with_capacity(100);
assert!(map.capacity() &gt;= 100);
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;
<span class="kw">let</span> <span class="ident">map</span>: <span class="ident">HashMap</span><span class="op">&lt;</span><span class="ident">isize</span>, <span class="ident">isize</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">with_capacity</span>(<span class="number">100</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">map</span>.<span class="ident">capacity</span>() <span class="op">&gt;=</span> <span class="number">100</span>);</pre>
</div></div><div class="outerdoc" id="2148307557360492419.reserve"><h4 class="method" id="method.reserve"><code>fn <a class="fnname" href="#method.reserve">reserve</a>(&amp;mut self, additional: <a class="primitive" href="../primitive.usize.html">usize</a>)</code></h4><div class="docblock"><p>Reserves capacity for at least <code>additional</code> more elements to be inserted
in the <code>HashMap</code>. The collection may reserve more space to avoid
frequent reallocations.</p>

<h1 class="section-header" id="panics"><a href="#panics">Panics</a></h1>
<p>Panics if the new allocation size overflows <code>usize</code>.</p>

<h1 class="section-header" id="examples-6"><a href="#examples-6">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;
let mut map: HashMap&lt;&amp;str, isize&gt; = HashMap::new();
map.reserve(10);
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">map</span>: <span class="ident">HashMap</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span>, <span class="ident">isize</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();
<span class="ident">map</span>.<span class="ident">reserve</span>(<span class="number">10</span>);</pre>
</div></div><div class="outerdoc" id="12686840722232842188.shrink_to_fit"><h4 class="method" id="method.shrink_to_fit"><code>fn <a class="fnname" href="#method.shrink_to_fit">shrink_to_fit</a>(&amp;mut self)</code></h4><div class="docblock"><p>Shrinks the capacity of the map as much as possible. It will drop
down as much as possible while maintaining the internal rules
and possibly leaving some space in accordance with the resize policy.</p>

<h1 class="section-header" id="examples-7"><a href="#examples-7">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;

let mut map: HashMap&lt;isize, isize&gt; = HashMap::with_capacity(100);
map.insert(1, 2);
map.insert(3, 4);
assert!(map.capacity() &gt;= 100);
map.shrink_to_fit();
assert!(map.capacity() &gt;= 2);
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">map</span>: <span class="ident">HashMap</span><span class="op">&lt;</span><span class="ident">isize</span>, <span class="ident">isize</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">with_capacity</span>(<span class="number">100</span>);
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="number">1</span>, <span class="number">2</span>);
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="number">3</span>, <span class="number">4</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">map</span>.<span class="ident">capacity</span>() <span class="op">&gt;=</span> <span class="number">100</span>);
<span class="ident">map</span>.<span class="ident">shrink_to_fit</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">map</span>.<span class="ident">capacity</span>() <span class="op">&gt;=</span> <span class="number">2</span>);</pre>
</div></div><div class="outerdoc" id="hm.clone_from"><h4 class="method" id="method.clone_from"><code>fn <a class="fnname" href="../../std/clone/trait.Clone.html#method.clone_from">clone_from</a>(&amp;mut self, source: &amp;Self)</code></h4><div class="docblock"><p>Performs copy-assignment from <code>source</code>. <a href="../../std/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div><div class="outerdoc" id="17744303864984779017.eq"><h4 class="method" id="method.eq"><code>fn <a class="fnname" href="../../std/cmp/trait.PartialEq.html#tymethod.eq">eq</a>(&amp;self, other: &amp;<a class="struct" href="../../std/collections/struct.HashMap.html" title="std::collections::HashMap">HashMap</a>&lt;K, V, S&gt;) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h4><div class="docblock"><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../../std/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></div><div class="outerdoc" id="1758821620296622440.ne"><h4 class="method" id="method.ne"><code>fn <a class="fnname" href="../../std/cmp/trait.PartialEq.html#method.ne">ne</a>(&amp;self, other: &amp;Rhs) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h4><div class="docblock"><p>This method tests for <code>!=</code>.</p>
</div></div><div class="outerdoc" id="17291470429843975631.with_hasher"><h4 class="method" id="method.with_hasher"><code>fn <a class="fnname" href="#method.with_hasher">with_hasher</a>(hash_builder: S) -&gt; <a class="struct" href="../../std/collections/struct.HashMap.html" title="std::collections::HashMap">HashMap</a>&lt;K, V, S&gt;</code><div class="since" title="Stable since Rust version 1.7.0">1.7.0</div></h4><div class="docblock"><p>Creates an empty hashmap which will use the given hash builder to hash
keys.</p>

<p>The created map has the default initial capacity.</p>

<p>Warning: <code>hash_builder</code> is normally randomly generated, and
is designed to allow HashMaps to be resistant to attacks that
cause many collisions and very poor performance. Setting it
manually using this function can expose a DoS attack vector.</p>

<h1 class="section-header" id="examples-3"><a href="#examples-3">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;
use std::collections::hash_map::RandomState;

let s = RandomState::new();
let mut map = HashMap::with_hasher(s);
map.insert(1, 2);
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">hash_map</span>::<span class="ident">RandomState</span>;

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">RandomState</span>::<span class="ident">new</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">map</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">with_hasher</span>(<span class="ident">s</span>);
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="number">1</span>, <span class="number">2</span>);</pre>
</div></div><div class="outerdoc" id="16546744701173878944.with_capacity_and_hasher"><h4 class="method" id="method.with_capacity_and_hasher"><code>fn <a class="fnname" href="#method.with_capacity_and_hasher">with_capacity_and_hasher</a>(capacity: <a class="primitive" href="../primitive.usize.html">usize</a>, hash_builder: S) -&gt; <a class="struct" href="../../std/collections/struct.HashMap.html" title="std::collections::HashMap">HashMap</a>&lt;K, V, S&gt;</code><div class="since" title="Stable since Rust version 1.7.0">1.7.0</div></h4><div class="docblock"><p>Creates an empty HashMap with space for at least <code>capacity</code>
elements, using <code>hasher</code> to hash the keys.</p>

<p>Warning: <code>hasher</code> is normally randomly generated, and
is designed to allow HashMaps to be resistant to attacks that
cause many collisions and very poor performance. Setting it
manually using this function can expose a DoS attack vector.</p>

<h1 class="section-header" id="examples-4"><a href="#examples-4">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;
use std::collections::hash_map::RandomState;

let s = RandomState::new();
let mut map = HashMap::with_capacity_and_hasher(10, s);
map.insert(1, 2);
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;
<span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">hash_map</span>::<span class="ident">RandomState</span>;

<span class="kw">let</span> <span class="ident">s</span> <span class="op">=</span> <span class="ident">RandomState</span>::<span class="ident">new</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">map</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">with_capacity_and_hasher</span>(<span class="number">10</span>, <span class="ident">s</span>);
<span class="ident">map</span>.<span class="ident">insert</span>(<span class="number">1</span>, <span class="number">2</span>);</pre>
</div></div><div class="outerdoc" id="4396959748909205563.hasher"><h4 class="method" id="method.hasher"><code>fn <a class="fnname" href="#method.hasher">hasher</a>(&amp;self) -&gt; &amp;S</code><div class="since" title="Stable since Rust version 1.9.0">1.9.0</div></h4><div class="docblock"><p>Returns a reference to the map's hasher.</p>
</div></div><div class="outerdoc" id="4451132110321701077.default"><h4 class="method" id="method.default"><code>fn <a class="fnname" href="../../std/default/trait.Default.html#tymethod.default">default</a>() -&gt; <a class="struct" href="../../std/collections/struct.HashMap.html" title="std::collections::HashMap">HashMap</a>&lt;K, V, S&gt;</code></h4><div class="docblock"><p>Returns the "default value" for a type. <a href="../../std/default/trait.Default.html#tymethod.default">Read more</a></p>
</div></div><div class="outerdoc" id="7316208468755632574.fmt"><h4 class="method" id="method.fmt"><code>fn <a class="fnname" href="../../std/fmt/trait.Debug.html#tymethod.fmt">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="../../std/fmt/struct.Formatter.html" title="std::fmt::Formatter">Formatter</a>) -&gt; <a class="type" href="../../std/fmt/type.Result.html" title="std::fmt::Result">Result</a></code></h4><div class="docblock"><p>Formats the value using the given formatter.</p>
</div></div><div class="outerdoc" id="option.option"><div class="docblock" id="option.option"><p>A hash map implementation which uses linear probing with Robin
Hood bucket stealing.</p>

<p>The hashes are all keyed by the thread-local random number generator
on creation by default. This means that the ordering of the keys is
randomized, but makes the tables more resistant to
denial-of-service attacks (Hash DoS). No guarantees are made to the
quality of the random data. The implementation uses the best available
random data from your platform at the time of creation. This behavior
can be overridden with one of the constructors.</p>

<p>It is required that the keys implement the <code>Eq</code> and <code>Hash</code> traits, although
this can frequently be achieved by using <code>#[derive(PartialEq, Eq, Hash)]</code>.
If you implement these yourself, it is important that the following
property holds:</p>

<pre><code class="language-text">k1 == k2 -&gt; hash(k1) == hash(k2)
</code></pre>

<p>In other words, if two keys are equal, their hashes must be equal.</p>

<p>It is a logic error for a key to be modified in such a way that the key's
hash, as determined by the <code>Hash</code> trait, or its equality, as determined by
the <code>Eq</code> trait, changes while it is in the map. This is normally only
possible through <code>Cell</code>, <code>RefCell</code>, global state, I/O, or unsafe code.</p>

<p>Relevant papers/articles:</p>

<ol>
<li>Pedro Celis. <a href="https://cs.uwaterloo.ca/research/tr/1986/CS-86-14.pdf">"Robin Hood Hashing"</a></li>
<li>Emmanuel Goossaert. <a href="http://codecapsule.com/2013/11/11/robin-hood-hashing/">"Robin Hood
hashing"</a></li>
<li>Emmanuel Goossaert. <a href="http://codecapsule.com/2013/11/17/robin-hood-hashing-backward-shift-deletion/">"Robin Hood hashing: backward shift
deletion"</a></li>
</ol>

<h1 class="section-header" id="examples"><a href="#examples">Examples</a></h1>
<span class="rusttest">fn main() {
    use std::collections::HashMap;

// type inference lets us omit an explicit type signature (which
// would be `HashMap&lt;&amp;str, &amp;str&gt;` in this example).
let mut book_reviews = HashMap::new();

// review some books.
book_reviews.insert("Adventures of Huckleberry Finn",    "My favorite book.");
book_reviews.insert("Grimms' Fairy Tales",               "Masterpiece.");
book_reviews.insert("Pride and Prejudice",               "Very enjoyable.");
book_reviews.insert("The Adventures of Sherlock Holmes", "Eye lyked it alot.");

// check for a specific one.
if !book_reviews.contains_key("Les Misrables") {
    println!("We've got {} reviews, but Les Misrables ain't one.",
             book_reviews.len());
}

// oops, this review has a lot of spelling mistakes, let's delete it.
book_reviews.remove("The Adventures of Sherlock Holmes");

// look up the values associated with some keys.
let to_find = ["Pride and Prejudice", "Alice's Adventure in Wonderland"];
for book in &amp;to_find {
    match book_reviews.get(book) {
        Some(review) =&gt; println!("{}: {}", book, review),
        None =&gt; println!("{} is unreviewed.", book)
    }
}

// iterate over everything.
for (book, review) in &amp;book_reviews {
    println!("{}: \"{}\"", book, review);
}
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="comment">// type inference lets us omit an explicit type signature (which</span>
<span class="comment">// would be `HashMap&lt;&amp;str, &amp;str&gt;` in this example).</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">book_reviews</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();

<span class="comment">// review some books.</span>
<span class="ident">book_reviews</span>.<span class="ident">insert</span>(<span class="string">"Adventures of Huckleberry Finn"</span>,    <span class="string">"My favorite book."</span>);
<span class="ident">book_reviews</span>.<span class="ident">insert</span>(<span class="string">"Grimms' Fairy Tales"</span>,               <span class="string">"Masterpiece."</span>);
<span class="ident">book_reviews</span>.<span class="ident">insert</span>(<span class="string">"Pride and Prejudice"</span>,               <span class="string">"Very enjoyable."</span>);
<span class="ident">book_reviews</span>.<span class="ident">insert</span>(<span class="string">"The Adventures of Sherlock Holmes"</span>, <span class="string">"Eye lyked it alot."</span>);

<span class="comment">// check for a specific one.</span>
<span class="kw">if</span> <span class="op">!</span><span class="ident">book_reviews</span>.<span class="ident">contains_key</span>(<span class="string">"Les Misrables"</span>) {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">"We've got {} reviews, but Les Misrables ain't one."</span>,
             <span class="ident">book_reviews</span>.<span class="ident">len</span>());
}

<span class="comment">// oops, this review has a lot of spelling mistakes, let's delete it.</span>
<span class="ident">book_reviews</span>.<span class="ident">remove</span>(<span class="string">"The Adventures of Sherlock Holmes"</span>);

<span class="comment">// look up the values associated with some keys.</span>
<span class="kw">let</span> <span class="ident">to_find</span> <span class="op">=</span> [<span class="string">"Pride and Prejudice"</span>, <span class="string">"Alice's Adventure in Wonderland"</span>];
<span class="kw">for</span> <span class="ident">book</span> <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">to_find</span> {
    <span class="kw">match</span> <span class="ident">book_reviews</span>.<span class="ident">get</span>(<span class="ident">book</span>) {
        <span class="prelude-val">Some</span>(<span class="ident">review</span>) <span class="op">=&gt;</span> <span class="macro">println</span><span class="macro">!</span>(<span class="string">"{}: {}"</span>, <span class="ident">book</span>, <span class="ident">review</span>),
        <span class="prelude-val">None</span> <span class="op">=&gt;</span> <span class="macro">println</span><span class="macro">!</span>(<span class="string">"{} is unreviewed."</span>, <span class="ident">book</span>)
    }
}

<span class="comment">// iterate over everything.</span>
<span class="kw">for</span> (<span class="ident">book</span>, <span class="ident">review</span>) <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">book_reviews</span> {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">"{}: \"{}\""</span>, <span class="ident">book</span>, <span class="ident">review</span>);
}</pre>

<p><code>HashMap</code> also implements an <a href="#method.entry"><code>Entry API</code></a>, which allows
for more complex methods of getting, setting, updating and removing keys and
their values:</p>

<span class="rusttest">fn main() {
    use std::collections::HashMap;

// type inference lets us omit an explicit type signature (which
// would be `HashMap&lt;&amp;str, u8&gt;` in this example).
let mut player_stats = HashMap::new();

fn random_stat_buff() -&gt; u8 {
    // could actually return some random value here - let's just return
    // some fixed value for now
    42
}

// insert a key only if it doesn't already exist
player_stats.entry("health").or_insert(100);

// insert a key using a function that provides a new value only if it
// doesn't already exist
player_stats.entry("defence").or_insert_with(random_stat_buff);

// update a key, guarding against the key possibly not being set
let stat = player_stats.entry("attack").or_insert(100);
*stat += random_stat_buff();
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="comment">// type inference lets us omit an explicit type signature (which</span>
<span class="comment">// would be `HashMap&lt;&amp;str, u8&gt;` in this example).</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">player_stats</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();

<span class="kw">fn</span> <span class="ident">random_stat_buff</span>() <span class="op">-&gt;</span> <span class="ident">u8</span> {
    <span class="comment">// could actually return some random value here - let's just return</span>
    <span class="comment">// some fixed value for now</span>
    <span class="number">42</span>
}

<span class="comment">// insert a key only if it doesn't already exist</span>
<span class="ident">player_stats</span>.<span class="ident">entry</span>(<span class="string">"health"</span>).<span class="ident">or_insert</span>(<span class="number">100</span>);

<span class="comment">// insert a key using a function that provides a new value only if it</span>
<span class="comment">// doesn't already exist</span>
<span class="ident">player_stats</span>.<span class="ident">entry</span>(<span class="string">"defence"</span>).<span class="ident">or_insert_with</span>(<span class="ident">random_stat_buff</span>);

<span class="comment">// update a key, guarding against the key possibly not being set</span>
<span class="kw">let</span> <span class="ident">stat</span> <span class="op">=</span> <span class="ident">player_stats</span>.<span class="ident">entry</span>(<span class="string">"attack"</span>).<span class="ident">or_insert</span>(<span class="number">100</span>);
<span class="op">*</span><span class="ident">stat</span> <span class="op">+=</span> <span class="ident">random_stat_buff</span>();</pre>

<p>The easiest way to use <code>HashMap</code> with a custom type as key is to derive <code>Eq</code> and <code>Hash</code>.
We must also derive <code>PartialEq</code>.</p>

<span class="rusttest">fn main() {
    use std::collections::HashMap;

#[derive(Hash, Eq, PartialEq, Debug)]
struct Viking {
    name: String,
    country: String,
}

impl Viking {
    /// Create a new Viking.
    fn new(name: &amp;str, country: &amp;str) -&gt; Viking {
        Viking { name: name.to_string(), country: country.to_string() }
    }
}

// Use a HashMap to store the vikings' health points.
let mut vikings = HashMap::new();

vikings.insert(Viking::new("Einar", "Norway"), 25);
vikings.insert(Viking::new("Olaf", "Denmark"), 24);
vikings.insert(Viking::new("Harald", "Iceland"), 12);

// Use derived implementation to print the status of the vikings.
for (viking, health) in &amp;vikings {
    println!("{:?} has {} hp", viking, health);
}
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">collections</span>::<span class="ident">HashMap</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Hash</span>, <span class="ident">Eq</span>, <span class="ident">PartialEq</span>, <span class="ident">Debug</span>)]</span>
<span class="kw">struct</span> <span class="ident">Viking</span> {
    <span class="ident">name</span>: <span class="ident">String</span>,
    <span class="ident">country</span>: <span class="ident">String</span>,
}

<span class="kw">impl</span> <span class="ident">Viking</span> {
    <span class="doccomment">/// Create a new Viking.</span>
    <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">name</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>, <span class="ident">country</span>: <span class="kw-2">&amp;</span><span class="ident">str</span>) <span class="op">-&gt;</span> <span class="ident">Viking</span> {
        <span class="ident">Viking</span> { <span class="ident">name</span>: <span class="ident">name</span>.<span class="ident">to_string</span>(), <span class="ident">country</span>: <span class="ident">country</span>.<span class="ident">to_string</span>() }
    }
}

<span class="comment">// Use a HashMap to store the vikings' health points.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vikings</span> <span class="op">=</span> <span class="ident">HashMap</span>::<span class="ident">new</span>();

<span class="ident">vikings</span>.<span class="ident">insert</span>(<span class="ident">Viking</span>::<span class="ident">new</span>(<span class="string">"Einar"</span>, <span class="string">"Norway"</span>), <span class="number">25</span>);
<span class="ident">vikings</span>.<span class="ident">insert</span>(<span class="ident">Viking</span>::<span class="ident">new</span>(<span class="string">"Olaf"</span>, <span class="string">"Denmark"</span>), <span class="number">24</span>);
<span class="ident">vikings</span>.<span class="ident">insert</span>(<span class="ident">Viking</span>::<span class="ident">new</span>(<span class="string">"Harald"</span>, <span class="string">"Iceland"</span>), <span class="number">12</span>);

<span class="comment">// Use derived implementation to print the status of the vikings.</span>
<span class="kw">for</span> (<span class="ident">viking</span>, <span class="ident">health</span>) <span class="kw">in</span> <span class="kw-2">&amp;</span><span class="ident">vikings</span> {
    <span class="macro">println</span><span class="macro">!</span>(<span class="string">"{:?} has {} hp"</span>, <span class="ident">viking</span>, <span class="ident">health</span>);
}</pre>
</div></div><div class="outerdoc" id="6504451597404164306.is_some"><h4 class="method" id="method.is_some"><code>fn <a class="fnname" href="#method.is_some">is_some</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h4><div class="docblock"><p>Returns <code>true</code> if the option is a <code>Some</code> value</p>

<h1 class="section-header" id="examples"><a href="#examples">Examples</a></h1>
<span class="rusttest">fn main() {
    let x: Option&lt;u32&gt; = Some(2);
assert_eq!(x.is_some(), true);

let x: Option&lt;u32&gt; = None;
assert_eq!(x.is_some(), false);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">x</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">is_some</span>(), <span class="bool-val">true</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">None</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">is_some</span>(), <span class="bool-val">false</span>);</pre>
</div></div><div class="outerdoc" id="17353264871639778283.is_none"><h4 class="method" id="method.is_none"><code>fn <a class="fnname" href="#method.is_none">is_none</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h4><div class="docblock"><p>Returns <code>true</code> if the option is a <code>None</code> value</p>

<h1 class="section-header" id="examples-1"><a href="#examples-1">Examples</a></h1>
<span class="rusttest">fn main() {
    let x: Option&lt;u32&gt; = Some(2);
assert_eq!(x.is_none(), false);

let x: Option&lt;u32&gt; = None;
assert_eq!(x.is_none(), true);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">x</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">is_none</span>(), <span class="bool-val">false</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">None</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">is_none</span>(), <span class="bool-val">true</span>);</pre>
</div></div><div class="outerdoc" id="15207913341984443606.as_ref"><h4 class="method" id="method.as_ref"><code>fn <a class="fnname" href="#method.as_ref">as_ref</a>(&amp;self) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;&amp;T&gt;</code></h4><div class="docblock"><p>Converts from <code>Option&lt;T&gt;</code> to <code>Option&lt;&amp;T&gt;</code></p>

<h1 class="section-header" id="examples-2"><a href="#examples-2">Examples</a></h1>
<p>Convert an <code>Option&lt;String&gt;</code> into an <code>Option&lt;usize&gt;</code>, preserving the original.
The <code>map</code> method takes the <code>self</code> argument by value, consuming the original,
so this technique uses <code>as_ref</code> to first take an <code>Option</code> to a reference
to the value inside the original.</p>

<span class="rusttest">fn main() {
    let num_as_str: Option&lt;String&gt; = Some("10".to_string());
// First, cast `Option&lt;String&gt;` to `Option&lt;&amp;String&gt;` with `as_ref`,
// then consume *that* with `map`, leaving `num_as_str` on the stack.
let num_as_int: Option&lt;usize&gt; = num_as_str.as_ref().map(|n| n.len());
println!("still can print num_as_str: {:?}", num_as_str);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">num_as_str</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="string">"10"</span>.<span class="ident">to_string</span>());
<span class="comment">// First, cast `Option&lt;String&gt;` to `Option&lt;&amp;String&gt;` with `as_ref`,</span>
<span class="comment">// then consume *that* with `map`, leaving `num_as_str` on the stack.</span>
<span class="kw">let</span> <span class="ident">num_as_int</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">usize</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">num_as_str</span>.<span class="ident">as_ref</span>().<span class="ident">map</span>(<span class="op">|</span><span class="ident">n</span><span class="op">|</span> <span class="ident">n</span>.<span class="ident">len</span>());
<span class="macro">println</span><span class="macro">!</span>(<span class="string">"still can print num_as_str: {:?}"</span>, <span class="ident">num_as_str</span>);</pre>
</div></div><div class="outerdoc" id="5691384552386697087.as_mut"><h4 class="method" id="method.as_mut"><code>fn <a class="fnname" href="#method.as_mut">as_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;&amp;mut T&gt;</code></h4><div class="docblock"><p>Converts from <code>Option&lt;T&gt;</code> to <code>Option&lt;&amp;mut T&gt;</code></p>

<h1 class="section-header" id="examples-3"><a href="#examples-3">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut x = Some(2);
match x.as_mut() {
    Some(v) =&gt; *v = 42,
    None =&gt; {},
}
assert_eq!(x, Some(42));
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="number">2</span>);
<span class="kw">match</span> <span class="ident">x</span>.<span class="ident">as_mut</span>() {
    <span class="prelude-val">Some</span>(<span class="ident">v</span>) <span class="op">=&gt;</span> <span class="op">*</span><span class="ident">v</span> <span class="op">=</span> <span class="number">42</span>,
    <span class="prelude-val">None</span> <span class="op">=&gt;</span> {},
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="prelude-val">Some</span>(<span class="number">42</span>));</pre>
</div></div><div class="outerdoc" id="9288462660437931993.cloned"><h4 class="method" id="method.cloned"><code>fn <a class="fnname" href="#method.cloned">cloned</a>(self) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt;</code></h4><div class="docblock"><p>Maps an <code>Option&lt;&amp;T&gt;</code> to an <code>Option&lt;T&gt;</code> by cloning the contents of the
option.</p>
</div></div><div class="outerdoc" id="14666763506234159559.iter"><h4 class="method" id="method.iter"><code>fn <a class="fnname" href="#method.iter">iter</a>(&amp;self) -&gt; <a class="struct" href="../../std/option/struct.Iter.html" title="std::option::Iter">Iter</a>&lt;T&gt;</code></h4><div class="docblock"><p>Returns an iterator over the possibly contained value.</p>

<h1 class="section-header" id="examples-13"><a href="#examples-13">Examples</a></h1>
<span class="rusttest">fn main() {
    let x = Some(4);
assert_eq!(x.iter().next(), Some(&amp;4));

let x: Option&lt;u32&gt; = None;
assert_eq!(x.iter().next(), None);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="number">4</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">iter</span>().<span class="ident">next</span>(), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">4</span>));

<span class="kw">let</span> <span class="ident">x</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">None</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">iter</span>().<span class="ident">next</span>(), <span class="prelude-val">None</span>);</pre>
</div></div><div class="outerdoc" id="6394198856654040359.iter_mut"><h4 class="method" id="method.iter_mut"><code>fn <a class="fnname" href="#method.iter_mut">iter_mut</a>(&amp;mut self) -&gt; <a class="struct" href="../../std/option/struct.IterMut.html" title="std::option::IterMut">IterMut</a>&lt;T&gt;</code></h4><div class="docblock"><p>Returns a mutable iterator over the possibly contained value.</p>

<h1 class="section-header" id="examples-14"><a href="#examples-14">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut x = Some(4);
match x.iter_mut().next() {
    Some(v) =&gt; *v = 42,
    None =&gt; {},
}
assert_eq!(x, Some(42));

let mut x: Option&lt;u32&gt; = None;
assert_eq!(x.iter_mut().next(), None);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="number">4</span>);
<span class="kw">match</span> <span class="ident">x</span>.<span class="ident">iter_mut</span>().<span class="ident">next</span>() {
    <span class="prelude-val">Some</span>(<span class="ident">v</span>) <span class="op">=&gt;</span> <span class="op">*</span><span class="ident">v</span> <span class="op">=</span> <span class="number">42</span>,
    <span class="prelude-val">None</span> <span class="op">=&gt;</span> {},
}
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="prelude-val">Some</span>(<span class="number">42</span>));

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">None</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">iter_mut</span>().<span class="ident">next</span>(), <span class="prelude-val">None</span>);</pre>
</div></div><div class="outerdoc" id="16432270654953061313.unwrap"><h4 class="method" id="method.unwrap"><code>fn <a class="fnname" href="#method.unwrap">unwrap</a>(self) -&gt; T</code></h4><div class="docblock"><p>Moves the value <code>v</code> out of the <code>Option&lt;T&gt;</code> if it is <code>Some(v)</code>.</p>

<h1 class="section-header" id="panics-1"><a href="#panics-1">Panics</a></h1>
<p>Panics if the self value equals <code>None</code>.</p>

<h1 class="section-header" id="safety-note"><a href="#safety-note">Safety note</a></h1>
<p>In general, because this function may panic, its use is discouraged.
Instead, prefer to use pattern matching and handle the <code>None</code>
case explicitly.</p>

<h1 class="section-header" id="examples-5"><a href="#examples-5">Examples</a></h1>
<span class="rusttest">fn main() {
    let x = Some("air");
assert_eq!(x.unwrap(), "air");
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="string">"air"</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">unwrap</span>(), <span class="string">"air"</span>);</pre>

<span class="rusttest">fn main() {
    let x: Option&lt;&amp;str&gt; = None;
assert_eq!(x.unwrap(), "air"); // fails
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">x</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">None</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">unwrap</span>(), <span class="string">"air"</span>); <span class="comment">// fails</span></pre>
</div></div><div class="outerdoc" id="11274258317012853528.expect"><h4 class="method" id="method.expect"><code>fn <a class="fnname" href="#method.expect">expect</a>(self, msg: &amp;<a class="primitive" href="../primitive.str.html">str</a>) -&gt; T</code></h4><div class="docblock"><p>Unwraps an option, yielding the content of a <code>Some</code>.</p>

<h1 class="section-header" id="panics"><a href="#panics">Panics</a></h1>
<p>Panics if the value is a <code>None</code> with a custom panic message provided by
<code>msg</code>.</p>

<h1 class="section-header" id="examples-4"><a href="#examples-4">Examples</a></h1>
<span class="rusttest">fn main() {
    let x = Some("value");
assert_eq!(x.expect("the world is ending"), "value");
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="string">"value"</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">expect</span>(<span class="string">"the world is ending"</span>), <span class="string">"value"</span>);</pre>

<span class="rusttest">fn main() {
    let x: Option&lt;&amp;str&gt; = None;
x.expect("the world is ending"); // panics with `the world is ending`
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">x</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">None</span>;
<span class="ident">x</span>.<span class="ident">expect</span>(<span class="string">"the world is ending"</span>); <span class="comment">// panics with `the world is ending`</span></pre>
</div></div><div class="outerdoc" id="11805277003619008830.unwrap_or"><h4 class="method" id="method.unwrap_or"><code>fn <a class="fnname" href="#method.unwrap_or">unwrap_or</a>(self, def: T) -&gt; T</code></h4><div class="docblock"><p>Returns the contained value or a default.</p>

<h1 class="section-header" id="examples-6"><a href="#examples-6">Examples</a></h1>
<span class="rusttest">fn main() {
    assert_eq!(Some("car").unwrap_or("bike"), "car");
assert_eq!(None.unwrap_or("bike"), "bike");
}</span><pre class="rust rust-example-rendered"><span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">"car"</span>).<span class="ident">unwrap_or</span>(<span class="string">"bike"</span>), <span class="string">"car"</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>.<span class="ident">unwrap_or</span>(<span class="string">"bike"</span>), <span class="string">"bike"</span>);</pre>
</div></div><div class="outerdoc" id="1533701075291881512.unwrap_or_default"><h4 class="method" id="method.unwrap_or_default"><code>fn <a class="fnname" href="#method.unwrap_or_default">unwrap_or_default</a>(self) -&gt; T</code></h4><div class="docblock"><p>Returns the contained value or a default</p>

<p>Consumes the <code>self</code> argument then, if <code>Some</code>, returns the contained
value, otherwise if <code>None</code>, returns the default value for that
type.</p>

<h1 class="section-header" id="examples-20"><a href="#examples-20">Examples</a></h1>
<p>Convert a string to an integer, turning poorly-formed strings
into 0 (the default value for integers). <code>parse</code> converts
a string to any other type that implements <code>FromStr</code>, returning
<code>None</code> on error.</p>

<span class="rusttest">fn main() {
    let good_year_from_input = "1909";
let bad_year_from_input = "190blarg";
let good_year = good_year_from_input.parse().ok().unwrap_or_default();
let bad_year = bad_year_from_input.parse().ok().unwrap_or_default();

assert_eq!(1909, good_year);
assert_eq!(0, bad_year);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">good_year_from_input</span> <span class="op">=</span> <span class="string">"1909"</span>;
<span class="kw">let</span> <span class="ident">bad_year_from_input</span> <span class="op">=</span> <span class="string">"190blarg"</span>;
<span class="kw">let</span> <span class="ident">good_year</span> <span class="op">=</span> <span class="ident">good_year_from_input</span>.<span class="ident">parse</span>().<span class="ident">ok</span>().<span class="ident">unwrap_or_default</span>();
<span class="kw">let</span> <span class="ident">bad_year</span> <span class="op">=</span> <span class="ident">bad_year_from_input</span>.<span class="ident">parse</span>().<span class="ident">ok</span>().<span class="ident">unwrap_or_default</span>();

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">1909</span>, <span class="ident">good_year</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="number">0</span>, <span class="ident">bad_year</span>);</pre>
</div></div><div class="outerdoc" id="16689666266530795931.unwrap_or_else"><h4 class="method" id="method.unwrap_or_else"><code>fn <a class="fnname" href="#method.unwrap_or_else">unwrap_or_else</a>&lt;F&gt;(self, f: F) -&gt; T <span class="where">where F: <a class="trait" href="../../std/ops/trait.FnOnce.html" title="std::ops::FnOnce">FnOnce</a>() -&gt; T</span></code></h4><div class="docblock"><p>Returns the contained value or computes it from a closure.</p>

<h1 class="section-header" id="examples-7"><a href="#examples-7">Examples</a></h1>
<span class="rusttest">fn main() {
    let k = 10;
assert_eq!(Some(4).unwrap_or_else(|| 2 * k), 4);
assert_eq!(None.unwrap_or_else(|| 2 * k), 20);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">k</span> <span class="op">=</span> <span class="number">10</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">4</span>).<span class="ident">unwrap_or_else</span>(<span class="op">||</span> <span class="number">2</span> <span class="op">*</span> <span class="ident">k</span>), <span class="number">4</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>.<span class="ident">unwrap_or_else</span>(<span class="op">||</span> <span class="number">2</span> <span class="op">*</span> <span class="ident">k</span>), <span class="number">20</span>);</pre>
</div></div><div class="outerdoc" id="1313084959026557620.take"><h4 class="method" id="method.take"><code>fn <a class="fnname" href="#method.take">take</a>(&amp;mut self) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt;</code></h4><div class="docblock"><p>Takes the value out of the option, leaving a <code>None</code> in its place.</p>

<h1 class="section-header" id="examples-19"><a href="#examples-19">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut x = Some(2);
x.take();
assert_eq!(x, None);

let mut x: Option&lt;u32&gt; = None;
x.take();
assert_eq!(x, None);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="number">2</span>);
<span class="ident">x</span>.<span class="ident">take</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="prelude-val">None</span>);

<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">None</span>;
<span class="ident">x</span>.<span class="ident">take</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>, <span class="prelude-val">None</span>);</pre>
</div></div><div class="outerdoc" id="12319667499590152877.map"><h4 class="method" id="method.map"><code>fn <a class="fnname" href="#method.map">map</a>&lt;U,&nbsp;F&gt;(self, f: F) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;U&gt; <span class="where">where F: <a class="trait" href="../../std/ops/trait.FnOnce.html" title="std::ops::FnOnce">FnOnce</a>(T) -&gt; U</span></code></h4><div class="docblock"><p>Maps an <code>Option&lt;T&gt;</code> to <code>Option&lt;U&gt;</code> by applying a function to a contained value</p>

<h1 class="section-header" id="examples-8"><a href="#examples-8">Examples</a></h1>
<p>Convert an <code>Option&lt;String&gt;</code> into an <code>Option&lt;usize&gt;</code>, consuming the original:</p>

<span class="rusttest">fn main() {
    let maybe_some_string = Some(String::from("Hello, World!"));
// `Option::map` takes self *by value*, consuming `maybe_some_string`
let maybe_some_len = maybe_some_string.map(|s| s.len());

assert_eq!(maybe_some_len, Some(13));
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">maybe_some_string</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="ident">String</span>::<span class="ident">from</span>(<span class="string">"Hello, World!"</span>));
<span class="comment">// `Option::map` takes self *by value*, consuming `maybe_some_string`</span>
<span class="kw">let</span> <span class="ident">maybe_some_len</span> <span class="op">=</span> <span class="ident">maybe_some_string</span>.<span class="ident">map</span>(<span class="op">|</span><span class="ident">s</span><span class="op">|</span> <span class="ident">s</span>.<span class="ident">len</span>());

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">maybe_some_len</span>, <span class="prelude-val">Some</span>(<span class="number">13</span>));</pre>
</div></div><div class="outerdoc" id="8971424463067818034.map_or"><h4 class="method" id="method.map_or"><code>fn <a class="fnname" href="#method.map_or">map_or</a>&lt;U,&nbsp;F&gt;(self, default: U, f: F) -&gt; U <span class="where">where F: <a class="trait" href="../../std/ops/trait.FnOnce.html" title="std::ops::FnOnce">FnOnce</a>(T) -&gt; U</span></code></h4><div class="docblock"><p>Applies a function to the contained value (if any),
or returns a <code>default</code> (if not).</p>

<h1 class="section-header" id="examples-9"><a href="#examples-9">Examples</a></h1>
<span class="rusttest">fn main() {
    let x = Some("foo");
assert_eq!(x.map_or(42, |v| v.len()), 3);

let x: Option&lt;&amp;str&gt; = None;
assert_eq!(x.map_or(42, |v| v.len()), 42);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="string">"foo"</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">map_or</span>(<span class="number">42</span>, <span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">len</span>()), <span class="number">3</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">None</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">map_or</span>(<span class="number">42</span>, <span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">len</span>()), <span class="number">42</span>);</pre>
</div></div><div class="outerdoc" id="11863433451634880378.map_or_else"><h4 class="method" id="method.map_or_else"><code>fn <a class="fnname" href="#method.map_or_else">map_or_else</a>&lt;U,&nbsp;D,&nbsp;F&gt;(self, default: D, f: F) -&gt; U <span class="where">where D: <a class="trait" href="../../std/ops/trait.FnOnce.html" title="std::ops::FnOnce">FnOnce</a>() -&gt; U, F: <a class="trait" href="../../std/ops/trait.FnOnce.html" title="std::ops::FnOnce">FnOnce</a>(T) -&gt; U</span></code></h4><div class="docblock"><p>Applies a function to the contained value (if any),
or computes a <code>default</code> (if not).</p>

<h1 class="section-header" id="examples-10"><a href="#examples-10">Examples</a></h1>
<span class="rusttest">fn main() {
    let k = 21;

let x = Some("foo");
assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 3);

let x: Option&lt;&amp;str&gt; = None;
assert_eq!(x.map_or_else(|| 2 * k, |v| v.len()), 42);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">k</span> <span class="op">=</span> <span class="number">21</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="string">"foo"</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">map_or_else</span>(<span class="op">||</span> <span class="number">2</span> <span class="op">*</span> <span class="ident">k</span>, <span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">len</span>()), <span class="number">3</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">None</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">map_or_else</span>(<span class="op">||</span> <span class="number">2</span> <span class="op">*</span> <span class="ident">k</span>, <span class="op">|</span><span class="ident">v</span><span class="op">|</span> <span class="ident">v</span>.<span class="ident">len</span>()), <span class="number">42</span>);</pre>
</div></div><div class="outerdoc" id="8333859018885568806.ok_or"><h4 class="method" id="method.ok_or"><code>fn <a class="fnname" href="#method.ok_or">ok_or</a>&lt;E&gt;(self, err: E) -&gt; <a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;T,&nbsp;E&gt;</code></h4><div class="docblock"><p>Transforms the <code>Option&lt;T&gt;</code> into a <code>Result&lt;T, E&gt;</code>, mapping <code>Some(v)</code> to
<code>Ok(v)</code> and <code>None</code> to <code>Err(err)</code>.</p>

<h1 class="section-header" id="examples-11"><a href="#examples-11">Examples</a></h1>
<span class="rusttest">fn main() {
    let x = Some("foo");
assert_eq!(x.ok_or(0), Ok("foo"));

let x: Option&lt;&amp;str&gt; = None;
assert_eq!(x.ok_or(0), Err(0));
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="string">"foo"</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">ok_or</span>(<span class="number">0</span>), <span class="prelude-val">Ok</span>(<span class="string">"foo"</span>));

<span class="kw">let</span> <span class="ident">x</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">None</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">ok_or</span>(<span class="number">0</span>), <span class="prelude-val">Err</span>(<span class="number">0</span>));</pre>
</div></div><div class="outerdoc" id="5114918529540926804.ok_or_else"><h4 class="method" id="method.ok_or_else"><code>fn <a class="fnname" href="#method.ok_or_else">ok_or_else</a>&lt;E,&nbsp;F&gt;(self, err: F) -&gt; <a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;T,&nbsp;E&gt; <span class="where">where F: <a class="trait" href="../../std/ops/trait.FnOnce.html" title="std::ops::FnOnce">FnOnce</a>() -&gt; E</span></code></h4><div class="docblock"><p>Transforms the <code>Option&lt;T&gt;</code> into a <code>Result&lt;T, E&gt;</code>, mapping <code>Some(v)</code> to
<code>Ok(v)</code> and <code>None</code> to <code>Err(err())</code>.</p>

<h1 class="section-header" id="examples-12"><a href="#examples-12">Examples</a></h1>
<span class="rusttest">fn main() {
    let x = Some("foo");
assert_eq!(x.ok_or_else(|| 0), Ok("foo"));

let x: Option&lt;&amp;str&gt; = None;
assert_eq!(x.ok_or_else(|| 0), Err(0));
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="string">"foo"</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">ok_or_else</span>(<span class="op">||</span> <span class="number">0</span>), <span class="prelude-val">Ok</span>(<span class="string">"foo"</span>));

<span class="kw">let</span> <span class="ident">x</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">None</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">ok_or_else</span>(<span class="op">||</span> <span class="number">0</span>), <span class="prelude-val">Err</span>(<span class="number">0</span>));</pre>
</div></div><div class="outerdoc" id="1876176474297165977.and"><h4 class="method" id="method.and"><code>fn <a class="fnname" href="#method.and">and</a>&lt;U&gt;(self, optb: <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;U&gt;) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;U&gt;</code></h4><div class="docblock"><p>Returns <code>None</code> if the option is <code>None</code>, otherwise returns <code>optb</code>.</p>

<h1 class="section-header" id="examples-15"><a href="#examples-15">Examples</a></h1>
<span class="rusttest">fn main() {
    let x = Some(2);
let y: Option&lt;&amp;str&gt; = None;
assert_eq!(x.and(y), None);

let x: Option&lt;u32&gt; = None;
let y = Some("foo");
assert_eq!(x.and(y), None);

let x = Some(2);
let y = Some("foo");
assert_eq!(x.and(y), Some("foo"));

let x: Option&lt;u32&gt; = None;
let y: Option&lt;&amp;str&gt; = None;
assert_eq!(x.and(y), None);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="number">2</span>);
<span class="kw">let</span> <span class="ident">y</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">None</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">and</span>(<span class="ident">y</span>), <span class="prelude-val">None</span>);

<span class="kw">let</span> <span class="ident">x</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">None</span>;
<span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="string">"foo"</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">and</span>(<span class="ident">y</span>), <span class="prelude-val">None</span>);

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="number">2</span>);
<span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="string">"foo"</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">and</span>(<span class="ident">y</span>), <span class="prelude-val">Some</span>(<span class="string">"foo"</span>));

<span class="kw">let</span> <span class="ident">x</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">None</span>;
<span class="kw">let</span> <span class="ident">y</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">None</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">and</span>(<span class="ident">y</span>), <span class="prelude-val">None</span>);</pre>
</div></div><div class="outerdoc" id="1066401321214794057.and_then"><h4 class="method" id="method.and_then"><code>fn <a class="fnname" href="#method.and_then">and_then</a>&lt;U,&nbsp;F&gt;(self, f: F) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;U&gt; <span class="where">where F: <a class="trait" href="../../std/ops/trait.FnOnce.html" title="std::ops::FnOnce">FnOnce</a>(T) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;U&gt;</span></code></h4><div class="docblock"><p>Returns <code>None</code> if the option is <code>None</code>, otherwise calls <code>f</code> with the
wrapped value and returns the result.</p>

<p>Some languages call this operation flatmap.</p>

<h1 class="section-header" id="examples-16"><a href="#examples-16">Examples</a></h1>
<span class="rusttest">fn main() {
    fn sq(x: u32) -&gt; Option&lt;u32&gt; { Some(x * x) }
fn nope(_: u32) -&gt; Option&lt;u32&gt; { None }

assert_eq!(Some(2).and_then(sq).and_then(sq), Some(16));
assert_eq!(Some(2).and_then(sq).and_then(nope), None);
assert_eq!(Some(2).and_then(nope).and_then(sq), None);
assert_eq!(None.and_then(sq).and_then(sq), None);
}</span><pre class="rust rust-example-rendered"><span class="kw">fn</span> <span class="ident">sq</span>(<span class="ident">x</span>: <span class="ident">u32</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> { <span class="prelude-val">Some</span>(<span class="ident">x</span> <span class="op">*</span> <span class="ident">x</span>) }
<span class="kw">fn</span> <span class="ident">nope</span>(_: <span class="ident">u32</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> { <span class="prelude-val">None</span> }

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">2</span>).<span class="ident">and_then</span>(<span class="ident">sq</span>).<span class="ident">and_then</span>(<span class="ident">sq</span>), <span class="prelude-val">Some</span>(<span class="number">16</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">2</span>).<span class="ident">and_then</span>(<span class="ident">sq</span>).<span class="ident">and_then</span>(<span class="ident">nope</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="number">2</span>).<span class="ident">and_then</span>(<span class="ident">nope</span>).<span class="ident">and_then</span>(<span class="ident">sq</span>), <span class="prelude-val">None</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>.<span class="ident">and_then</span>(<span class="ident">sq</span>).<span class="ident">and_then</span>(<span class="ident">sq</span>), <span class="prelude-val">None</span>);</pre>
</div></div><div class="outerdoc" id="3832898963387606678.or"><h4 class="method" id="method.or"><code>fn <a class="fnname" href="#method.or">or</a>(self, optb: <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt;) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt;</code></h4><div class="docblock"><p>Returns the option if it contains a value, otherwise returns <code>optb</code>.</p>

<h1 class="section-header" id="examples-17"><a href="#examples-17">Examples</a></h1>
<span class="rusttest">fn main() {
    let x = Some(2);
let y = None;
assert_eq!(x.or(y), Some(2));

let x = None;
let y = Some(100);
assert_eq!(x.or(y), Some(100));

let x = Some(2);
let y = Some(100);
assert_eq!(x.or(y), Some(2));

let x: Option&lt;u32&gt; = None;
let y = None;
assert_eq!(x.or(y), None);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="number">2</span>);
<span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="prelude-val">None</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">or</span>(<span class="ident">y</span>), <span class="prelude-val">Some</span>(<span class="number">2</span>));

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="prelude-val">None</span>;
<span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="number">100</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">or</span>(<span class="ident">y</span>), <span class="prelude-val">Some</span>(<span class="number">100</span>));

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="number">2</span>);
<span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="number">100</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">or</span>(<span class="ident">y</span>), <span class="prelude-val">Some</span>(<span class="number">2</span>));

<span class="kw">let</span> <span class="ident">x</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="prelude-val">None</span>;
<span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="prelude-val">None</span>;
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">x</span>.<span class="ident">or</span>(<span class="ident">y</span>), <span class="prelude-val">None</span>);</pre>
</div></div><div class="outerdoc" id="18116111635374583314.or_else"><h4 class="method" id="method.or_else"><code>fn <a class="fnname" href="#method.or_else">or_else</a>&lt;F&gt;(self, f: F) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt; <span class="where">where F: <a class="trait" href="../../std/ops/trait.FnOnce.html" title="std::ops::FnOnce">FnOnce</a>() -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt;</span></code></h4><div class="docblock"><p>Returns the option if it contains a value, otherwise calls <code>f</code> and
returns the result.</p>

<h1 class="section-header" id="examples-18"><a href="#examples-18">Examples</a></h1>
<span class="rusttest">fn main() {
    fn nobody() -&gt; Option&lt;&amp;'static str&gt; { None }
fn vikings() -&gt; Option&lt;&amp;'static str&gt; { Some("vikings") }

assert_eq!(Some("barbarians").or_else(vikings), Some("barbarians"));
assert_eq!(None.or_else(vikings), Some("vikings"));
assert_eq!(None.or_else(nobody), None);
}</span><pre class="rust rust-example-rendered"><span class="kw">fn</span> <span class="ident">nobody</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">'static</span> <span class="ident">str</span><span class="op">&gt;</span> { <span class="prelude-val">None</span> }
<span class="kw">fn</span> <span class="ident">vikings</span>() <span class="op">-&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">'static</span> <span class="ident">str</span><span class="op">&gt;</span> { <span class="prelude-val">Some</span>(<span class="string">"vikings"</span>) }

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="string">"barbarians"</span>).<span class="ident">or_else</span>(<span class="ident">vikings</span>), <span class="prelude-val">Some</span>(<span class="string">"barbarians"</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>.<span class="ident">or_else</span>(<span class="ident">vikings</span>), <span class="prelude-val">Some</span>(<span class="string">"vikings"</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>.<span class="ident">or_else</span>(<span class="ident">nobody</span>), <span class="prelude-val">None</span>);</pre>
</div></div><div class="outerdoc" id="389856273934873617.hash"><h4 class="method" id="method.hash"><code>fn <a class="fnname" href="../../std/hash/trait.Hash.html#tymethod.hash">hash</a>&lt;__HT&gt;(&amp;self, __arg_0: &amp;mut __HT) <span class="where">where __HT: <a class="trait" href="../../std/hash/trait.Hasher.html" title="std::hash::Hasher">Hasher</a></span></code></h4><div class="docblock"><p>Feeds this value into the state given, updating the hasher as necessary.</p>
</div></div><div class="outerdoc" id="4574392842334917395.hash_slice"><h4 class="method" id="method.hash_slice"><code>fn <a class="fnname" href="../../std/hash/trait.Hash.html#method.hash_slice">hash_slice</a>&lt;H&gt;(data: <a class="primitive" href="../primitive.slice.html">&amp;[Self]</a>, state: &amp;mut H) <span class="where">where H: <a class="trait" href="../../std/hash/trait.Hasher.html" title="std::hash::Hasher">Hasher</a></span></code><div class="since" title="Stable since Rust version 1.3.0">1.3.0</div></h4><div class="docblock"><p>Feeds a slice of this type into the state provided.</p>
</div></div><div class="outerdoc" id="13199671331023959611.fmt"><h4 class="method" id="method.fmt"><code>fn <a class="fnname" href="../../std/fmt/trait.Debug.html#tymethod.fmt">fmt</a>(&amp;self, __arg_0: &amp;mut <a class="struct" href="../../std/fmt/struct.Formatter.html" title="std::fmt::Formatter">Formatter</a>) -&gt; <a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;<a class="primitive" href="../primitive.tuple.html">()</a>,&nbsp;<a class="struct" href="../../std/fmt/struct.Error.html" title="std::fmt::Error">Error</a>&gt;</code></h4><div class="docblock"><p>Formats the value using the given formatter.</p>
</div></div><div class="outerdoc" id="17866902328306906809.cmp"><h4 class="method" id="method.cmp"><code>fn <a class="fnname" href="../../std/cmp/trait.Ord.html#tymethod.cmp">cmp</a>(&amp;self, __arg_0: &amp;<a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt;) -&gt; <a class="enum" href="../../std/cmp/enum.Ordering.html" title="std::cmp::Ordering">Ordering</a></code></h4><div class="docblock"><p>This method returns an <code>Ordering</code> between <code>self</code> and <code>other</code>. <a href="../../std/cmp/trait.Ord.html#tymethod.cmp">Read more</a></p>
</div></div><div class="outerdoc" id="18296562665875618520.partial_cmp"><h4 class="method" id="method.partial_cmp"><code>fn <a class="fnname" href="../../std/cmp/trait.PartialOrd.html#tymethod.partial_cmp">partial_cmp</a>(&amp;self, __arg_0: &amp;<a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt;) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;<a class="enum" href="../../std/cmp/enum.Ordering.html" title="std::cmp::Ordering">Ordering</a>&gt;</code></h4><div class="docblock"><p>This method returns an ordering between <code>self</code> and <code>other</code> values if one exists. <a href="../../std/cmp/trait.PartialOrd.html#tymethod.partial_cmp">Read more</a></p>
</div></div><div class="outerdoc" id="14430656552780856558.lt"><h4 class="method" id="method.lt"><code>fn <a class="fnname" href="../../std/cmp/trait.PartialOrd.html#method.lt">lt</a>(&amp;self, __arg_0: &amp;<a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt;) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h4><div class="docblock"><p>This method tests less than (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;</code> operator. <a href="../../std/cmp/trait.PartialOrd.html#method.lt">Read more</a></p>
</div></div><div class="outerdoc" id="15542999645070279494.le"><h4 class="method" id="method.le"><code>fn <a class="fnname" href="../../std/cmp/trait.PartialOrd.html#method.le">le</a>(&amp;self, __arg_0: &amp;<a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt;) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h4><div class="docblock"><p>This method tests less than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&lt;=</code> operator. <a href="../../std/cmp/trait.PartialOrd.html#method.le">Read more</a></p>
</div></div><div class="outerdoc" id="7219544018863720640.gt"><h4 class="method" id="method.gt"><code>fn <a class="fnname" href="../../std/cmp/trait.PartialOrd.html#method.gt">gt</a>(&amp;self, __arg_0: &amp;<a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt;) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h4><div class="docblock"><p>This method tests greater than (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;</code> operator. <a href="../../std/cmp/trait.PartialOrd.html#method.gt">Read more</a></p>
</div></div><div class="outerdoc" id="17725730971198962671.ge"><h4 class="method" id="method.ge"><code>fn <a class="fnname" href="../../std/cmp/trait.PartialOrd.html#method.ge">ge</a>(&amp;self, __arg_0: &amp;<a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt;) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h4><div class="docblock"><p>This method tests greater than or equal to (for <code>self</code> and <code>other</code>) and is used by the <code>&gt;=</code> operator. <a href="../../std/cmp/trait.PartialOrd.html#method.ge">Read more</a></p>
</div></div><div class="outerdoc" id="1472516741008242409.eq"><h4 class="method" id="method.eq"><code>fn <a class="fnname" href="../../std/cmp/trait.PartialEq.html#tymethod.eq">eq</a>(&amp;self, __arg_0: &amp;<a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt;) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h4><div class="docblock"><p>This method tests for <code>self</code> and <code>other</code> values to be equal, and is used by <code>==</code>. <a href="../../std/cmp/trait.PartialEq.html#tymethod.eq">Read more</a></p>
</div></div><div class="outerdoc" id="4065647751515692205.ne"><h4 class="method" id="method.ne"><code>fn <a class="fnname" href="../../std/cmp/trait.PartialEq.html#method.ne">ne</a>(&amp;self, __arg_0: &amp;<a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt;) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h4><div class="docblock"><p>This method tests for <code>!=</code>.</p>
</div></div><div class="outerdoc" id="10975458318622769309.clone"><h4 class="method" id="method.clone"><code>fn <a class="fnname" href="../../std/clone/trait.Clone.html#tymethod.clone">clone</a>(&amp;self) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt;</code></h4><div class="docblock"><p>Returns a copy of the value. <a href="../../std/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div></div><div class="outerdoc" id="2331504072263541851.clone_from"><h4 class="method" id="method.clone_from"><code>fn <a class="fnname" href="../../std/clone/trait.Clone.html#method.clone_from">clone_from</a>(&amp;mut self, source: &amp;Self)</code></h4><div class="docblock"><p>Performs copy-assignment from <code>source</code>. <a href="../../std/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div><div class="outerdoc" id="11680357678959509649.default"><h4 class="method" id="method.default"><code>fn <a class="fnname" href="../../std/default/trait.Default.html#tymethod.default">default</a>() -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt;</code></h4><div class="docblock"><p>Returns the "default value" for a type. <a href="../../std/default/trait.Default.html#tymethod.default">Read more</a></p>
</div></div><div class="outerdoc" id="1227242874701021233.into_iter"><h4 class="method" id="method.into_iter"><code>fn <a class="fnname" href="../../std/iter/trait.IntoIterator.html#tymethod.into_iter">into_iter</a>(self) -&gt; <a class="struct" href="../../std/option/struct.IntoIter.html" title="std::option::IntoIter">IntoIter</a>&lt;T&gt;</code></h4><div class="docblock"><p>Returns a consuming iterator over the possibly contained value.</p>

<h1 class="section-header" id="examples-21"><a href="#examples-21">Examples</a></h1>
<span class="rusttest">fn main() {
    let x = Some("string");
let v: Vec&lt;&amp;str&gt; = x.into_iter().collect();
assert_eq!(v, ["string"]);

let x = None;
let v: Vec&lt;&amp;str&gt; = x.into_iter().collect();
assert!(v.is_empty());
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="prelude-val">Some</span>(<span class="string">"string"</span>);
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">into_iter</span>().<span class="ident">collect</span>();
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="string">"string"</span>]);

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="prelude-val">None</span>;
<span class="kw">let</span> <span class="ident">v</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="ident">str</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">x</span>.<span class="ident">into_iter</span>().<span class="ident">collect</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">is_empty</span>());</pre>
</div></div><div class="outerdoc" id="17860051281235821222.from_iter"><h4 class="method" id="method.from_iter"><code>fn <a class="fnname" href="../../std/iter/trait.FromIterator.html#tymethod.from_iter">from_iter</a>&lt;I&gt;(iter: I) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;V&gt; <span class="where">where I: <a class="trait" href="../../std/iter/trait.IntoIterator.html" title="std::iter::IntoIterator">IntoIterator</a>&lt;Item=<a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;A&gt;&gt;</span></code></h4><div class="docblock"><p>Takes each element in the <code>Iterator</code>: if it is <code>None</code>, no further
elements are taken, and the <code>None</code> is returned. Should no <code>None</code> occur, a
container with the values of each <code>Option</code> is returned.</p>

<p>Here is an example which increments every integer in a vector,
checking for overflow:</p>

<span class="rusttest">fn main() {
    use std::u16;

let v = vec!(1, 2);
let res: Option&lt;Vec&lt;u16&gt;&gt; = v.iter().map(|&amp;x: &amp;u16|
    if x == u16::MAX { None }
    else { Some(x + 1) }
).collect();
assert!(res == Some(vec!(2, 3)));
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">u16</span>;

<span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>(<span class="number">1</span>, <span class="number">2</span>);
<span class="kw">let</span> <span class="ident">res</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u16</span><span class="op">&gt;&gt;</span> <span class="op">=</span> <span class="ident">v</span>.<span class="ident">iter</span>().<span class="ident">map</span>(<span class="op">|</span><span class="kw-2">&amp;</span><span class="ident">x</span>: <span class="kw-2">&amp;</span><span class="ident">u16</span><span class="op">|</span>
    <span class="kw">if</span> <span class="ident">x</span> <span class="op">==</span> <span class="ident">u16</span>::<span class="ident">MAX</span> { <span class="prelude-val">None</span> }
    <span class="kw">else</span> { <span class="prelude-val">Some</span>(<span class="ident">x</span> <span class="op">+</span> <span class="number">1</span>) }
).<span class="ident">collect</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">res</span> <span class="op">==</span> <span class="prelude-val">Some</span>(<span class="macro">vec</span><span class="macro">!</span>(<span class="number">2</span>, <span class="number">3</span>)));</pre>
</div></div><div class="outerdoc" id="trait.Hash"><div class="docblock" id="trait.Hash">
<h1 class="fqn"><span class="in-band">Trait <a href="../">std</a>::<wbr><a href="index.html">hash</a>::<wbr><a class="trait" href="">Hash</a></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><span id="render-detail">
                   <a href="javascript:void(0)" id="toggle-all-docs" title="collapse all docs">
                       [<span class="inner"></span>]
                   </a>
               </span><a class="srclink" href="../../core/hash/trait.Hash.html?gotosrc=37016" id="src-37016" title="goto source code">[src]</a></span></h1>
<pre class="rust trait">pub trait Hash {
    fn <a class="fnname" href="#tymethod.hash">hash</a>&lt;H&gt;(&amp;self, state: &amp;mut H) <span class="where">where H: <a class="trait" href="../../std/hash/trait.Hasher.html" title="std::hash::Hasher">Hasher</a></span>;

    fn <a class="fnname" href="#method.hash_slice">hash_slice</a>&lt;H&gt;(data: <a class="primitive" href="../primitive.slice.html">&amp;[Self]</a>, state: &amp;mut H) <span class="where">where H: <a class="trait" href="../../std/hash/trait.Hasher.html" title="std::hash::Hasher">Hasher</a></span> { ... }
}</pre><div class="docblock"><p>A hashable type.</p>

<p>The <code>H</code> type parameter is an abstract hash state that is used by the <code>Hash</code>
to compute the hash.</p>

<p>If you are also implementing <code>Eq</code>, there is an additional property that
is important:</p>

<pre><code class="language-text">k1 == k2 -&gt; hash(k1) == hash(k2)
</code></pre>

<p>In other words, if two keys are equal, their hashes should also be equal.
<code>HashMap</code> and <code>HashSet</code> both rely on this behavior.</p>

<h2 class="section-header" id="derivable"><a href="#derivable">Derivable</a></h2>
<p>This trait can be used with <code>#[derive]</code> if all fields implement <code>Hash</code>.
When <code>derive</code>d, the resulting hash will be the combination of the values
from calling <code>.hash()</code> on each field.</p>

<h2 class="section-header" id="how-can-i-implement-hash"><a href="#how-can-i-implement-hash">How can I implement <code>Hash</code>?</a></h2>
<p>If you need more control over how a value is hashed, you need to implement
the <code>Hash</code> trait:</p>

<span class="rusttest">fn main() {
    use std::hash::{Hash, Hasher};

struct Person {
    id: u32,
    name: String,
    phone: u64,
}

impl Hash for Person {
    fn hash&lt;H: Hasher&gt;(&amp;self, state: &amp;mut H) {
        self.id.hash(state);
        self.phone.hash(state);
    }
}
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">hash</span>::{<span class="ident">Hash</span>, <span class="ident">Hasher</span>};

<span class="kw">struct</span> <span class="ident">Person</span> {
    <span class="ident">id</span>: <span class="ident">u32</span>,
    <span class="ident">name</span>: <span class="ident">String</span>,
    <span class="ident">phone</span>: <span class="ident">u64</span>,
}

<span class="kw">impl</span> <span class="ident">Hash</span> <span class="kw">for</span> <span class="ident">Person</span> {
    <span class="kw">fn</span> <span class="ident">hash</span><span class="op">&lt;</span><span class="ident">H</span>: <span class="ident">Hasher</span><span class="op">&gt;</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">state</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">H</span>) {
        <span class="self">self</span>.<span class="ident">id</span>.<span class="ident">hash</span>(<span class="ident">state</span>);
        <span class="self">self</span>.<span class="ident">phone</span>.<span class="ident">hash</span>(<span class="ident">state</span>);
    }
}</pre>
</div>
            <h2 id="required-methods">Required Methods</h2>
            <div class="methods">
        <h3 class="method stab " id="tymethod.hash"><code>fn <a class="fnname" href="#tymethod.hash">hash</a>&lt;H&gt;(&amp;self, state: &amp;mut H) <span class="where">where H: <a class="trait" href="../../std/hash/trait.Hasher.html" title="std::hash::Hasher">Hasher</a></span></code></h3><div class="docblock"><p>Feeds this value into the state given, updating the hasher as necessary.</p>
</div></div>
            <h2 id="provided-methods">Provided Methods</h2>
            <div class="methods">
        <h3 class="method stab " id="method.hash_slice"><code>fn <a class="fnname" href="#method.hash_slice">hash_slice</a>&lt;H&gt;(data: <a class="primitive" href="../primitive.slice.html">&amp;[Self]</a>, state: &amp;mut H) <span class="where">where H: <a class="trait" href="../../std/hash/trait.Hasher.html" title="std::hash::Hasher">Hasher</a></span></code><div class="since" title="Stable since Rust version 1.3.0">1.3.0</div></h3><div class="docblock"><p>Feeds a slice of this type into the state provided.</p>
</div></div>
        <h2 id="implementors">Implementors</h2>
        <ul class="item-list" id="implementors-list">
    <li><code>impl&lt;T&gt; Hash for <a class="struct" href="../../std/num/struct.Wrapping.html" title="std::num::Wrapping">Wrapping</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="struct" href="../../core/nonzero/struct.NonZero.html" title="core::nonzero::NonZero">NonZero</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../core/nonzero/trait.Zeroable.html" title="core::nonzero::Zeroable">Zeroable</a> + <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;Ret&gt; Hash for fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret&gt; Hash for extern fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret&gt; Hash for unsafe fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret&gt; Hash for unsafe extern fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A&gt; Hash for fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A&gt; Hash for extern fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A&gt; Hash for unsafe fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A&gt; Hash for unsafe extern fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B&gt; Hash for fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B&gt; Hash for extern fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B&gt; Hash for unsafe fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B&gt; Hash for unsafe extern fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C&gt; Hash for fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C&gt; Hash for extern fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C&gt; Hash for unsafe fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C&gt; Hash for unsafe extern fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D&gt; Hash for fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D&gt; Hash for extern fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D&gt; Hash for unsafe fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D&gt; Hash for unsafe extern fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E&gt; Hash for fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E&gt; Hash for extern fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E&gt; Hash for unsafe fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E&gt; Hash for unsafe extern fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F&gt; Hash for fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F&gt; Hash for extern fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F&gt; Hash for unsafe fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F&gt; Hash for unsafe extern fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G&gt; Hash for fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G&gt; Hash for extern fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G&gt; Hash for unsafe fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G&gt; Hash for unsafe extern fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H&gt; Hash for fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H&gt; Hash for extern fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H&gt; Hash for unsafe fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H&gt; Hash for unsafe extern fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I&gt; Hash for fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I&gt; Hash for extern fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I&gt; Hash for unsafe fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I&gt; Hash for unsafe extern fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J&gt; Hash for fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J&gt; Hash for extern fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J&gt; Hash for unsafe fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J&gt; Hash for unsafe extern fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K&gt; Hash for fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K&gt; Hash for extern fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K&gt; Hash for unsafe fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K&gt; Hash for unsafe extern fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K,&nbsp;L&gt; Hash for fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K,&nbsp;L&gt; Hash for extern fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K,&nbsp;L&gt; Hash for unsafe fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K,&nbsp;L&gt; Hash for unsafe extern fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;T&gt; Hash for <a class="struct" href="../../std/marker/struct.PhantomData.html" title="std::marker::PhantomData">PhantomData</a>&lt;T&gt; <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl Hash for <a class="struct" href="../../std/ops/struct.RangeFull.html" title="std::ops::RangeFull">RangeFull</a></code></li>
<li><code>impl&lt;Idx&gt; Hash for <a class="struct" href="../../std/ops/struct.Range.html" title="std::ops::Range">Range</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;Idx&gt; Hash for <a class="struct" href="../../std/ops/struct.RangeFrom.html" title="std::ops::RangeFrom">RangeFrom</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;Idx&gt; Hash for <a class="struct" href="../../std/ops/struct.RangeTo.html" title="std::ops::RangeTo">RangeTo</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;Idx&gt; Hash for <a class="enum" href="../../std/ops/enum.RangeInclusive.html" title="std::ops::RangeInclusive">RangeInclusive</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;Idx&gt; Hash for <a class="struct" href="../../std/ops/struct.RangeToInclusive.html" title="std::ops::RangeToInclusive">RangeToInclusive</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl Hash for <a class="enum" href="../../std/cmp/enum.Ordering.html" title="std::cmp::Ordering">Ordering</a></code></li>
<li><code>impl Hash for <a class="struct" href="../../std/any/struct.TypeId.html" title="std::any::TypeId">TypeId</a></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 0]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 1]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 2]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 3]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 4]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 5]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 6]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 7]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 8]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 9]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 10]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 11]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 12]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 13]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 14]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 15]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 16]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 17]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 18]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 19]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 20]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 21]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 22]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 23]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 24]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 25]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 26]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 27]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 28]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 29]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 30]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 31]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 32]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T,&nbsp;E&gt; Hash for <a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;T,&nbsp;E&gt; <span class="where">where E: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl Hash for <a class="primitive" href="../primitive.u8.html">u8</a></code></li>
<li><code>impl Hash for <a class="primitive" href="../primitive.u16.html">u16</a></code></li>
<li><code>impl Hash for <a class="primitive" href="../primitive.u32.html">u32</a></code></li>
<li><code>impl Hash for <a class="primitive" href="../primitive.u64.html">u64</a></code></li>
<li><code>impl Hash for <a class="primitive" href="../primitive.usize.html">usize</a></code></li>
<li><code>impl Hash for <a class="primitive" href="../primitive.i8.html">i8</a></code></li>
<li><code>impl Hash for <a class="primitive" href="../primitive.i16.html">i16</a></code></li>
<li><code>impl Hash for <a class="primitive" href="../primitive.i32.html">i32</a></code></li>
<li><code>impl Hash for <a class="primitive" href="../primitive.i64.html">i64</a></code></li>
<li><code>impl Hash for <a class="primitive" href="../primitive.isize.html">isize</a></code></li>
<li><code>impl Hash for <a class="primitive" href="../primitive.bool.html">bool</a></code></li>
<li><code>impl Hash for <a class="primitive" href="../primitive.char.html">char</a></code></li>
<li><code>impl Hash for <a class="primitive" href="../primitive.str.html">str</a></code></li>
<li><code>impl Hash for <a class="primitive" href="../primitive.tuple.html">()</a></code></li>
<li><code>impl&lt;A&gt; Hash for <a class="primitive" href="../primitive.tuple.html">(</a>A,<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B&gt; Hash for <a class="primitive" href="../primitive.tuple.html">(</a>A, B<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, B: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C&gt; Hash for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, B: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, C: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D&gt; Hash for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, B: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, C: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, D: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E&gt; Hash for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, B: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, C: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, D: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, E: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F&gt; Hash for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, B: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, C: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, D: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, E: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, F: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G&gt; Hash for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, B: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, C: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, D: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, E: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, F: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, G: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H&gt; Hash for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, B: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, C: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, D: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, E: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, F: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, G: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, H: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I&gt; Hash for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, B: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, C: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, D: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, E: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, F: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, G: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, H: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, I: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J&gt; Hash for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, B: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, C: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, D: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, E: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, F: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, G: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, H: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, I: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, J: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K&gt; Hash for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J, K<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, B: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, C: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, D: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, E: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, F: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, G: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, H: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, I: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, J: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, K: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K,&nbsp;L&gt; Hash for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J, K, L<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, B: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, C: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, D: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, E: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, F: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, G: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, H: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, I: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, J: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, K: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, L: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.slice.html">[</a>T<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Hash for &amp;'a T <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Hash for &amp;'a mut T <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.pointer.html">*const T</a></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="primitive" href="../primitive.pointer.html">*mut T</a></code></li>
<li><code>impl Hash for <a class="struct" href="../../std/fmt/struct.Error.html" title="std::fmt::Error">Error</a></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="struct" href="../../std/boxed/struct.Box.html" title="std::boxed::Box">Box</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="struct" href="../../std/sync/struct.Arc.html" title="std::sync::Arc">Arc</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="struct" href="../../std/rc/struct.Rc.html" title="std::rc::Rc">Rc</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;K,&nbsp;V&gt; Hash for <a class="struct" href="../../std/collections/btree_map/struct.BTreeMap.html" title="std::collections::btree_map::BTreeMap">BTreeMap</a>&lt;K,&nbsp;V&gt; <span class="where">where K: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, V: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="struct" href="../../std/collections/btree_set/struct.BTreeSet.html" title="std::collections::btree_set::BTreeSet">BTreeSet</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;B&gt; Hash for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a,&nbsp;B&gt; <span class="where">where B: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a> + <a class="trait" href="../../std/borrow/trait.ToOwned.html" title="std::borrow::ToOwned">ToOwned</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;E&gt; Hash for <a class="struct" href="../../collections/enum_set/struct.EnumSet.html" title="collections::enum_set::EnumSet">EnumSet</a>&lt;E&gt; <span class="where">where E: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;A&gt; Hash for <a class="struct" href="../../std/collections/linked_list/struct.LinkedList.html" title="std::collections::linked_list::LinkedList">LinkedList</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl Hash for <a class="struct" href="../../std/string/struct.String.html" title="std::string::String">String</a></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;A&gt; Hash for <a class="struct" href="../../std/collections/vec_deque/struct.VecDeque.html" title="std::collections::vec_deque::VecDeque">VecDeque</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl&lt;T&gt; Hash for <a class="enum" href="../../std/collections/enum.Bound.html" title="std::collections::Bound">Bound</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a></span></code></li>
<li><code>impl Hash for <a class="struct" href="../../std/ffi/struct.CString.html" title="std::ffi::CString">CString</a></code></li>
<li><code>impl Hash for <a class="struct" href="../../std/ffi/struct.CStr.html" title="std::ffi::CStr">CStr</a></code></li>
<li><code>impl Hash for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl Hash for <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl Hash for <a class="struct" href="../../std/fs/struct.FileType.html" title="std::fs::FileType">FileType</a></code></li>
<li><code>impl Hash for <a class="enum" href="../../std/net/enum.IpAddr.html" title="std::net::IpAddr">IpAddr</a></code></li>
<li><code>impl Hash for <a class="enum" href="../../std/net/enum.Ipv6MulticastScope.html" title="std::net::Ipv6MulticastScope">Ipv6MulticastScope</a></code></li>
<li><code>impl Hash for <a class="struct" href="../../std/net/struct.Ipv4Addr.html" title="std::net::Ipv4Addr">Ipv4Addr</a></code></li>
<li><code>impl Hash for <a class="struct" href="../../std/net/struct.Ipv6Addr.html" title="std::net::Ipv6Addr">Ipv6Addr</a></code></li>
<li><code>impl Hash for <a class="enum" href="../../std/net/enum.SocketAddr.html" title="std::net::SocketAddr">SocketAddr</a></code></li>
<li><code>impl Hash for <a class="struct" href="../../std/net/struct.SocketAddrV4.html" title="std::net::SocketAddrV4">SocketAddrV4</a></code></li>
<li><code>impl Hash for <a class="struct" href="../../std/net/struct.SocketAddrV6.html" title="std::net::SocketAddrV6">SocketAddrV6</a></code></li>
<li><code>impl&lt;'a&gt; Hash for <a class="enum" href="../../std/path/enum.Prefix.html" title="std::path::Prefix">Prefix</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; Hash for <a class="struct" href="../../std/path/struct.PrefixComponent.html" title="std::path::PrefixComponent">PrefixComponent</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; Hash for <a class="enum" href="../../std/path/enum.Component.html" title="std::path::Component">Component</a>&lt;'a&gt;</code></li>
<li><code>impl Hash for <a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a></code></li>
<li><code>impl Hash for <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl Hash for <a class="struct" href="../../std/time/struct.Duration.html" title="std::time::Duration">Duration</a></code></li>
</ul><script src="../../implementors/core/hash/trait.Hash.js" async="" type="text/javascript">
                 </script></div></div><div class="outerdoc" id="trait.Debug"><div class="docblock" id="trait.Debug">
<h1 class="fqn"><span class="in-band">Trait <a href="../">std</a>::<wbr><a href="index.html">fmt</a>::<wbr><a class="trait" href="">Debug</a></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><span id="render-detail">
                   <a href="javascript:void(0)" id="toggle-all-docs" title="collapse all docs">
                       [<span class="inner"></span>]
                   </a>
               </span><a class="srclink" href="../../core/fmt/trait.Debug.html?gotosrc=38588" id="src-38588" title="goto source code">[src]</a></span></h1>
<pre class="rust trait">pub trait Debug {
    fn <a class="fnname" href="#tymethod.fmt">fmt</a>(&amp;self, &amp;mut <a class="struct" href="../../std/fmt/struct.Formatter.html" title="std::fmt::Formatter">Formatter</a>) -&gt; <a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;<a class="primitive" href="../primitive.tuple.html">()</a>,&nbsp;<a class="struct" href="../../std/fmt/struct.Error.html" title="std::fmt::Error">Error</a>&gt;;
}</pre><div class="docblock"><p>Format trait for the <code>?</code> character.</p>

<p><code>Debug</code> should format the output in a programmer-facing, debugging context.</p>

<p>Generally speaking, you should just <code>derive</code> a <code>Debug</code> implementation.</p>

<p>When used with the alternate format specifier <code>#?</code>, the output is pretty-printed.</p>

<p>For more information on formatters, see <a href="../../std/fmt/">the module-level documentation</a>.</p>

<p>This trait can be used with <code>#[derive]</code> if all fields implement <code>Debug</code>. When
<code>derive</code>d for structs, it will use the name of the <code>struct</code>, then <code>{</code>, then a
comma-separated list of each field's name and <code>Debug</code> value, then <code>}</code>. For
<code>enum</code>s, it will use the name of the variant and, if applicable, <code>(</code>, then the
<code>Debug</code> values of the fields, then <code>)</code>.</p>

<h1 class="section-header" id="examples"><a href="#examples">Examples</a></h1>
<p>Deriving an implementation:</p>

<span class="rusttest">fn main() {
    #[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

println!("The origin is: {:?}", origin);
}</span><pre class="rust rust-example-rendered"><span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
<span class="kw">struct</span> <span class="ident">Point</span> {
    <span class="ident">x</span>: <span class="ident">i32</span>,
    <span class="ident">y</span>: <span class="ident">i32</span>,
}

<span class="kw">let</span> <span class="ident">origin</span> <span class="op">=</span> <span class="ident">Point</span> { <span class="ident">x</span>: <span class="number">0</span>, <span class="ident">y</span>: <span class="number">0</span> };

<span class="macro">println</span><span class="macro">!</span>(<span class="string">"The origin is: {:?}"</span>, <span class="ident">origin</span>);</pre>

<p>Manually implementing:</p>

<span class="rusttest">fn main() {
    use std::fmt;

struct Point {
    x: i32,
    y: i32,
}

impl fmt::Debug for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, "Point {{ x: {}, y: {} }}", self.x, self.y)
    }
}

let origin = Point { x: 0, y: 0 };

println!("The origin is: {:?}", origin);
}</span><pre class="rust rust-example-rendered"><span class="kw">use</span> <span class="ident">std</span>::<span class="ident">fmt</span>;

<span class="kw">struct</span> <span class="ident">Point</span> {
    <span class="ident">x</span>: <span class="ident">i32</span>,
    <span class="ident">y</span>: <span class="ident">i32</span>,
}

<span class="kw">impl</span> <span class="ident">fmt</span>::<span class="ident">Debug</span> <span class="kw">for</span> <span class="ident">Point</span> {
    <span class="kw">fn</span> <span class="ident">fmt</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">f</span>: <span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">fmt</span>::<span class="ident">Formatter</span>) <span class="op">-&gt;</span> <span class="ident">fmt</span>::<span class="prelude-ty">Result</span> {
        <span class="macro">write</span><span class="macro">!</span>(<span class="ident">f</span>, <span class="string">"Point {{ x: {}, y: {} }}"</span>, <span class="self">self</span>.<span class="ident">x</span>, <span class="self">self</span>.<span class="ident">y</span>)
    }
}

<span class="kw">let</span> <span class="ident">origin</span> <span class="op">=</span> <span class="ident">Point</span> { <span class="ident">x</span>: <span class="number">0</span>, <span class="ident">y</span>: <span class="number">0</span> };

<span class="macro">println</span><span class="macro">!</span>(<span class="string">"The origin is: {:?}"</span>, <span class="ident">origin</span>);</pre>

<p>This outputs:</p>

<pre><code class="language-text">The origin is: Point { x: 0, y: 0 }
</code></pre>

<p>There are a number of <code>debug_*</code> methods on <code>Formatter</code> to help you with manual
implementations, such as <a href="../../std/fmt/struct.Formatter.html#method.debug_struct"><code>debug_struct</code></a>.</p>

<p><code>Debug</code> implementations using either <code>derive</code> or the debug builder API
on <code>Formatter</code> support pretty printing using the alternate flag: <code>{:#?}</code>.</p>

<p>Pretty printing with <code>#?</code>:</p>

<span class="rusttest">fn main() {
    #[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

let origin = Point { x: 0, y: 0 };

println!("The origin is: {:#?}", origin);
}</span><pre class="rust rust-example-rendered"><span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
<span class="kw">struct</span> <span class="ident">Point</span> {
    <span class="ident">x</span>: <span class="ident">i32</span>,
    <span class="ident">y</span>: <span class="ident">i32</span>,
}

<span class="kw">let</span> <span class="ident">origin</span> <span class="op">=</span> <span class="ident">Point</span> { <span class="ident">x</span>: <span class="number">0</span>, <span class="ident">y</span>: <span class="number">0</span> };

<span class="macro">println</span><span class="macro">!</span>(<span class="string">"The origin is: {:#?}"</span>, <span class="ident">origin</span>);</pre>

<p>This outputs:</p>

<pre><code class="language-text">The origin is: Point {
    x: 0,
    y: 0
}
</code></pre>
</div>
            <h2 id="required-methods">Required Methods</h2>
            <div class="methods">
        <h3 class="method stab " id="tymethod.fmt"><code>fn <a class="fnname" href="#tymethod.fmt">fmt</a>(&amp;self, &amp;mut <a class="struct" href="../../std/fmt/struct.Formatter.html" title="std::fmt::Formatter">Formatter</a>) -&gt; <a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;<a class="primitive" href="../primitive.tuple.html">()</a>,&nbsp;<a class="struct" href="../../std/fmt/struct.Error.html" title="std::fmt::Error">Error</a>&gt;</code></h3><div class="docblock"><p>Formats the value using the given formatter.</p>
</div></div>
        <h2 id="implementors">Implementors</h2>
        <ul class="item-list" id="implementors-list">
    <li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/num/struct.Wrapping.html" title="std::num::Wrapping">Wrapping</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/num/struct.ParseFloatError.html" title="std::num::ParseFloatError">ParseFloatError</a></code></li>
<li><code>impl Debug for <a class="enum" href="../../std/num/enum.FpCategory.html" title="std::num::FpCategory">FpCategory</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/num/struct.TryFromIntError.html" title="std::num::TryFromIntError">TryFromIntError</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/num/struct.ParseIntError.html" title="std::num::ParseIntError">ParseIntError</a></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../core/nonzero/struct.NonZero.html" title="core::nonzero::NonZero">NonZero</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../core/nonzero/trait.Zeroable.html" title="core::nonzero::Zeroable">Zeroable</a> + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;Ret&gt; Debug for fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret&gt; Debug for extern fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret&gt; Debug for unsafe fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret&gt; Debug for unsafe extern fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A&gt; Debug for fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A&gt; Debug for extern fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A&gt; Debug for unsafe fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A&gt; Debug for unsafe extern fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B&gt; Debug for fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B&gt; Debug for extern fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B&gt; Debug for unsafe fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B&gt; Debug for unsafe extern fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C&gt; Debug for fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C&gt; Debug for extern fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C&gt; Debug for unsafe fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C&gt; Debug for unsafe extern fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D&gt; Debug for fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D&gt; Debug for extern fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D&gt; Debug for unsafe fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D&gt; Debug for unsafe extern fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E&gt; Debug for fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E&gt; Debug for extern fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E&gt; Debug for unsafe fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E&gt; Debug for unsafe extern fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F&gt; Debug for fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F&gt; Debug for extern fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F&gt; Debug for unsafe fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F&gt; Debug for unsafe extern fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G&gt; Debug for fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G&gt; Debug for extern fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G&gt; Debug for unsafe fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G&gt; Debug for unsafe extern fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H&gt; Debug for fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H&gt; Debug for extern fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H&gt; Debug for unsafe fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H&gt; Debug for unsafe extern fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I&gt; Debug for fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I&gt; Debug for extern fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I&gt; Debug for unsafe fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I&gt; Debug for unsafe extern fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J&gt; Debug for fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J&gt; Debug for extern fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J&gt; Debug for unsafe fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J&gt; Debug for unsafe extern fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K&gt; Debug for fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K&gt; Debug for extern fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K&gt; Debug for unsafe fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K&gt; Debug for unsafe extern fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K,&nbsp;L&gt; Debug for fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K,&nbsp;L&gt; Debug for extern fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K,&nbsp;L&gt; Debug for unsafe fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K,&nbsp;L&gt; Debug for unsafe extern fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl Debug for <a class="struct" href="../../std/ops/struct.RangeFull.html" title="std::ops::RangeFull">RangeFull</a></code></li>
<li><code>impl&lt;Idx&gt; Debug for <a class="struct" href="../../std/ops/struct.Range.html" title="std::ops::Range">Range</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;Idx&gt; Debug for <a class="struct" href="../../std/ops/struct.RangeFrom.html" title="std::ops::RangeFrom">RangeFrom</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;Idx&gt; Debug for <a class="struct" href="../../std/ops/struct.RangeTo.html" title="std::ops::RangeTo">RangeTo</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;Idx&gt; Debug for <a class="enum" href="../../std/ops/enum.RangeInclusive.html" title="std::ops::RangeInclusive">RangeInclusive</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;Idx&gt; Debug for <a class="struct" href="../../std/ops/struct.RangeToInclusive.html" title="std::ops::RangeToInclusive">RangeToInclusive</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl Debug for <a class="enum" href="../../std/cmp/enum.Ordering.html" title="std::cmp::Ordering">Ordering</a></code></li>
<li><code>impl Debug for <a class="trait" href="../../std/any/trait.Any.html" title="std::any::Any">Any</a> + 'static</code></li>
<li><code>impl Debug for <a class="trait" href="../../std/any/trait.Any.html" title="std::any::Any">Any</a> + 'static + <a class="trait" href="../../std/marker/trait.Send.html" title="std::marker::Send">Send</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/any/struct.TypeId.html" title="std::any::TypeId">TypeId</a></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 0]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 1]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 2]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 3]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 4]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 5]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 6]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 7]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 8]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 9]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 10]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 11]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 12]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 13]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 14]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 15]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 16]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 17]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 18]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 19]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 20]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 21]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 22]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 23]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 24]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 25]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 26]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 27]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 28]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 29]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 30]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 31]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 32]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl Debug for <a class="enum" href="../../std/sync/atomic/enum.Ordering.html" title="std::sync::atomic::Ordering">Ordering</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/sync/atomic/struct.AtomicI8.html" title="std::sync::atomic::AtomicI8">AtomicI8</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/sync/atomic/struct.AtomicU8.html" title="std::sync::atomic::AtomicU8">AtomicU8</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/sync/atomic/struct.AtomicI16.html" title="std::sync::atomic::AtomicI16">AtomicI16</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/sync/atomic/struct.AtomicU16.html" title="std::sync::atomic::AtomicU16">AtomicU16</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/sync/atomic/struct.AtomicI32.html" title="std::sync::atomic::AtomicI32">AtomicI32</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/sync/atomic/struct.AtomicU32.html" title="std::sync::atomic::AtomicU32">AtomicU32</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/sync/atomic/struct.AtomicI64.html" title="std::sync::atomic::AtomicI64">AtomicI64</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/sync/atomic/struct.AtomicU64.html" title="std::sync::atomic::AtomicU64">AtomicU64</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/sync/atomic/struct.AtomicIsize.html" title="std::sync::atomic::AtomicIsize">AtomicIsize</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/sync/atomic/struct.AtomicUsize.html" title="std::sync::atomic::AtomicUsize">AtomicUsize</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/sync/atomic/struct.AtomicBool.html" title="std::sync::atomic::AtomicBool">AtomicBool</a></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/sync/atomic/struct.AtomicPtr.html" title="std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</code></li>
<li><code>impl Debug for <a class="enum" href="../../std/cell/enum.BorrowState.html" title="std::cell::BorrowState">BorrowState</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/char/struct.EscapeUnicode.html" title="std::char::EscapeUnicode">EscapeUnicode</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/char/struct.EscapeDefault.html" title="std::char::EscapeDefault">EscapeDefault</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/char/struct.EncodeUtf8.html" title="std::char::EncodeUtf8">EncodeUtf8</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/char/struct.EncodeUtf16.html" title="std::char::EncodeUtf16">EncodeUtf16</a></code></li>
<li><code>impl&lt;A,&nbsp;R&gt; Debug for <a class="struct" href="../../std/iter/struct.StepBy.html" title="std::iter::StepBy">StepBy</a>&lt;A,&nbsp;R&gt; <span class="where">where A: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, R: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;A&gt; Debug for <a class="struct" href="../../std/iter/struct.Repeat.html" title="std::iter::Repeat">Repeat</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/iter/struct.Empty.html" title="std::iter::Empty">Empty</a>&lt;T&gt;</code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/iter/struct.Once.html" title="std::iter::Once">Once</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/iter/struct.Rev.html" title="std::iter::Rev">Rev</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;I&gt; Debug for <a class="struct" href="../../std/iter/struct.Cloned.html" title="std::iter::Cloned">Cloned</a>&lt;I&gt; <span class="where">where I: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;I&gt; Debug for <a class="struct" href="../../std/iter/struct.Cycle.html" title="std::iter::Cycle">Cycle</a>&lt;I&gt; <span class="where">where I: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B&gt; Debug for <a class="struct" href="../../std/iter/struct.Chain.html" title="std::iter::Chain">Chain</a>&lt;A,&nbsp;B&gt; <span class="where">where A: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, B: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B&gt; Debug for <a class="struct" href="../../std/iter/struct.Zip.html" title="std::iter::Zip">Zip</a>&lt;A,&nbsp;B&gt; <span class="where">where A: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, B: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;I,&nbsp;F&gt; Debug for <a class="struct" href="../../std/iter/struct.Map.html" title="std::iter::Map">Map</a>&lt;I,&nbsp;F&gt; <span class="where">where I: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;I,&nbsp;P&gt; Debug for <a class="struct" href="../../std/iter/struct.Filter.html" title="std::iter::Filter">Filter</a>&lt;I,&nbsp;P&gt; <span class="where">where I: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;I,&nbsp;F&gt; Debug for <a class="struct" href="../../std/iter/struct.FilterMap.html" title="std::iter::FilterMap">FilterMap</a>&lt;I,&nbsp;F&gt; <span class="where">where I: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;I&gt; Debug for <a class="struct" href="../../std/iter/struct.Enumerate.html" title="std::iter::Enumerate">Enumerate</a>&lt;I&gt; <span class="where">where I: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;I&gt; Debug for <a class="struct" href="../../std/iter/struct.Peekable.html" title="std::iter::Peekable">Peekable</a>&lt;I&gt; <span class="where">where I: <a class="trait" href="../../std/iter/trait.Iterator.html" title="std::iter::Iterator">Iterator</a> + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, I::<a class="trait" href="../../std/iter/trait.Iterator.html" title="std::iter::Iterator">Item</a>: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;I,&nbsp;P&gt; Debug for <a class="struct" href="../../std/iter/struct.SkipWhile.html" title="std::iter::SkipWhile">SkipWhile</a>&lt;I,&nbsp;P&gt; <span class="where">where I: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;I,&nbsp;P&gt; Debug for <a class="struct" href="../../std/iter/struct.TakeWhile.html" title="std::iter::TakeWhile">TakeWhile</a>&lt;I,&nbsp;P&gt; <span class="where">where I: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;I&gt; Debug for <a class="struct" href="../../std/iter/struct.Skip.html" title="std::iter::Skip">Skip</a>&lt;I&gt; <span class="where">where I: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;I&gt; Debug for <a class="struct" href="../../std/iter/struct.Take.html" title="std::iter::Take">Take</a>&lt;I&gt; <span class="where">where I: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;I,&nbsp;St,&nbsp;F&gt; Debug for <a class="struct" href="../../std/iter/struct.Scan.html" title="std::iter::Scan">Scan</a>&lt;I,&nbsp;St,&nbsp;F&gt; <span class="where">where I: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, St: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;I,&nbsp;U,&nbsp;F&gt; Debug for <a class="struct" href="../../std/iter/struct.FlatMap.html" title="std::iter::FlatMap">FlatMap</a>&lt;I,&nbsp;U,&nbsp;F&gt; <span class="where">where I: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, U: <a class="trait" href="../../std/iter/trait.IntoIterator.html" title="std::iter::IntoIterator">IntoIterator</a>, U::<a class="trait" href="../../std/iter/trait.IntoIterator.html" title="std::iter::IntoIterator">IntoIter</a>: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;I&gt; Debug for <a class="struct" href="../../std/iter/struct.Fuse.html" title="std::iter::Fuse">Fuse</a>&lt;I&gt; <span class="where">where I: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;I,&nbsp;F&gt; Debug for <a class="struct" href="../../std/iter/struct.Inspect.html" title="std::iter::Inspect">Inspect</a>&lt;I,&nbsp;F&gt; <span class="where">where I: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;A&gt; Debug for <a class="struct" href="../../std/option/struct.Iter.html" title="std::option::Iter">Iter</a>&lt;'a,&nbsp;A&gt; <span class="where">where A: 'a + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;A&gt; Debug for <a class="struct" href="../../std/option/struct.IterMut.html" title="std::option::IterMut">IterMut</a>&lt;'a,&nbsp;A&gt; <span class="where">where A: 'a + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;A&gt; Debug for <a class="struct" href="../../std/option/struct.IntoIter.html" title="std::option::IntoIter">IntoIter</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T,&nbsp;E&gt; Debug for <a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;T,&nbsp;E&gt; <span class="where">where E: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Debug for <a class="struct" href="../../std/result/struct.Iter.html" title="std::result::Iter">Iter</a>&lt;'a,&nbsp;T&gt; <span class="where">where T: 'a + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Debug for <a class="struct" href="../../std/result/struct.IterMut.html" title="std::result::IterMut">IterMut</a>&lt;'a,&nbsp;T&gt; <span class="where">where T: 'a + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/result/struct.IntoIter.html" title="std::result::IntoIter">IntoIter</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Debug for <a class="struct" href="../../std/slice/struct.Iter.html" title="std::slice::Iter">Iter</a>&lt;'a,&nbsp;T&gt; <span class="where">where T: 'a + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Debug for <a class="struct" href="../../std/slice/struct.IterMut.html" title="std::slice::IterMut">IterMut</a>&lt;'a,&nbsp;T&gt; <span class="where">where T: 'a + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;T,&nbsp;P&gt; Debug for <a class="struct" href="../../std/slice/struct.Split.html" title="std::slice::Split">Split</a>&lt;'a,&nbsp;T,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/ops/trait.FnMut.html" title="std::ops::FnMut">FnMut</a>(&amp;T) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a>, T: 'a + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;T,&nbsp;P&gt; Debug for <a class="struct" href="../../std/slice/struct.SplitMut.html" title="std::slice::SplitMut">SplitMut</a>&lt;'a,&nbsp;T,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/ops/trait.FnMut.html" title="std::ops::FnMut">FnMut</a>(&amp;T) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a>, T: 'a + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;T,&nbsp;P&gt; Debug for <a class="struct" href="../../std/slice/struct.SplitN.html" title="std::slice::SplitN">SplitN</a>&lt;'a,&nbsp;T,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/ops/trait.FnMut.html" title="std::ops::FnMut">FnMut</a>(&amp;T) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a>, T: 'a + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;T,&nbsp;P&gt; Debug for <a class="struct" href="../../std/slice/struct.RSplitN.html" title="std::slice::RSplitN">RSplitN</a>&lt;'a,&nbsp;T,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/ops/trait.FnMut.html" title="std::ops::FnMut">FnMut</a>(&amp;T) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a>, T: 'a + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;T,&nbsp;P&gt; Debug for <a class="struct" href="../../std/slice/struct.SplitNMut.html" title="std::slice::SplitNMut">SplitNMut</a>&lt;'a,&nbsp;T,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/ops/trait.FnMut.html" title="std::ops::FnMut">FnMut</a>(&amp;T) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a>, T: 'a + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;T,&nbsp;P&gt; Debug for <a class="struct" href="../../std/slice/struct.RSplitNMut.html" title="std::slice::RSplitNMut">RSplitNMut</a>&lt;'a,&nbsp;T,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/ops/trait.FnMut.html" title="std::ops::FnMut">FnMut</a>(&amp;T) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a>, T: 'a + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Debug for <a class="struct" href="../../std/slice/struct.Windows.html" title="std::slice::Windows">Windows</a>&lt;'a,&nbsp;T&gt; <span class="where">where T: 'a + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Debug for <a class="struct" href="../../std/slice/struct.Chunks.html" title="std::slice::Chunks">Chunks</a>&lt;'a,&nbsp;T&gt; <span class="where">where T: 'a + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Debug for <a class="struct" href="../../std/slice/struct.ChunksMut.html" title="std::slice::ChunksMut">ChunksMut</a>&lt;'a,&nbsp;T&gt; <span class="where">where T: 'a + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl Debug for <a class="enum" href="../../std/str/pattern/enum.SearchStep.html" title="std::str::pattern::SearchStep">SearchStep</a></code></li>
<li><code>impl&lt;'a&gt; Debug for <a class="struct" href="../../std/str/pattern/struct.CharSearcher.html" title="std::str::pattern::CharSearcher">CharSearcher</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;'b&gt; Debug for <a class="struct" href="../../std/str/pattern/struct.CharSliceSearcher.html" title="std::str::pattern::CharSliceSearcher">CharSliceSearcher</a>&lt;'a,&nbsp;'b&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;F&gt; Debug for <a class="struct" href="../../std/str/pattern/struct.CharPredicateSearcher.html" title="std::str::pattern::CharPredicateSearcher">CharPredicateSearcher</a>&lt;'a,&nbsp;F&gt; <span class="where">where F: <a class="trait" href="../../std/ops/trait.FnMut.html" title="std::ops::FnMut">FnMut</a>(<a class="primitive" href="../primitive.char.html">char</a>) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;'b&gt; Debug for <a class="struct" href="../../std/str/pattern/struct.StrSearcher.html" title="std::str::pattern::StrSearcher">StrSearcher</a>&lt;'a,&nbsp;'b&gt;</code></li>
<li><code>impl Debug for <a class="struct" href="../../std/str/struct.ParseBoolError.html" title="std::str::ParseBoolError">ParseBoolError</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/str/struct.Utf8Error.html" title="std::str::Utf8Error">Utf8Error</a></code></li>
<li><code>impl&lt;'a&gt; Debug for <a class="struct" href="../../std/str/struct.Chars.html" title="std::str::Chars">Chars</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; Debug for <a class="struct" href="../../std/str/struct.CharIndices.html" title="std::str::CharIndices">CharIndices</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; Debug for <a class="struct" href="../../std/str/struct.Bytes.html" title="std::str::Bytes">Bytes</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;P&gt; Debug for <a class="struct" href="../../std/str/struct.Split.html" title="std::str::Split">Split</a>&lt;'a,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;P&gt; Debug for <a class="struct" href="../../std/str/struct.RSplit.html" title="std::str::RSplit">RSplit</a>&lt;'a,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;P&gt; Debug for <a class="struct" href="../../std/str/struct.SplitTerminator.html" title="std::str::SplitTerminator">SplitTerminator</a>&lt;'a,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;P&gt; Debug for <a class="struct" href="../../std/str/struct.RSplitTerminator.html" title="std::str::RSplitTerminator">RSplitTerminator</a>&lt;'a,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;P&gt; Debug for <a class="struct" href="../../std/str/struct.SplitN.html" title="std::str::SplitN">SplitN</a>&lt;'a,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;P&gt; Debug for <a class="struct" href="../../std/str/struct.RSplitN.html" title="std::str::RSplitN">RSplitN</a>&lt;'a,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;P&gt; Debug for <a class="struct" href="../../std/str/struct.MatchIndices.html" title="std::str::MatchIndices">MatchIndices</a>&lt;'a,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;P&gt; Debug for <a class="struct" href="../../std/str/struct.RMatchIndices.html" title="std::str::RMatchIndices">RMatchIndices</a>&lt;'a,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;P&gt; Debug for <a class="struct" href="../../std/str/struct.Matches.html" title="std::str::Matches">Matches</a>&lt;'a,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;P&gt; Debug for <a class="struct" href="../../std/str/struct.RMatches.html" title="std::str::RMatches">RMatches</a>&lt;'a,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a&gt; Debug for <a class="struct" href="../../std/str/struct.Lines.html" title="std::str::Lines">Lines</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; Debug for <a class="struct" href="../../std/str/struct.LinesAny.html" title="std::str::LinesAny">LinesAny</a>&lt;'a&gt;</code></li>
<li><code>impl Debug for <a class="struct" href="../../std/hash/struct.SipHasher13.html" title="std::hash::SipHasher13">SipHasher13</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/hash/struct.SipHasher24.html" title="std::hash::SipHasher24">SipHasher24</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/hash/struct.SipHasher.html" title="std::hash::SipHasher">SipHasher</a></code></li>
<li><code>impl&lt;H&gt; Debug for <a class="struct" href="../../std/hash/struct.BuildHasherDefault.html" title="std::hash::BuildHasherDefault">BuildHasherDefault</a>&lt;H&gt;</code></li>
<li><code>impl Debug for <a class="enum" href="../../core/fmt/enum.Alignment.html" title="core::fmt::Alignment">Alignment</a></code></li>
<li><code>impl Debug for <a class="primitive" href="../primitive.isize.html">isize</a></code></li>
<li><code>impl Debug for <a class="primitive" href="../primitive.usize.html">usize</a></code></li>
<li><code>impl Debug for <a class="primitive" href="../primitive.i8.html">i8</a></code></li>
<li><code>impl Debug for <a class="primitive" href="../primitive.u8.html">u8</a></code></li>
<li><code>impl Debug for <a class="primitive" href="../primitive.i16.html">i16</a></code></li>
<li><code>impl Debug for <a class="primitive" href="../primitive.u16.html">u16</a></code></li>
<li><code>impl Debug for <a class="primitive" href="../primitive.i32.html">i32</a></code></li>
<li><code>impl Debug for <a class="primitive" href="../primitive.u32.html">u32</a></code></li>
<li><code>impl Debug for <a class="primitive" href="../primitive.i64.html">i64</a></code></li>
<li><code>impl Debug for <a class="primitive" href="../primitive.u64.html">u64</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/fmt/struct.Error.html" title="std::fmt::Error">Error</a></code></li>
<li><code>impl&lt;'a&gt; Debug for <a class="struct" href="../../std/fmt/struct.Arguments.html" title="std::fmt::Arguments">Arguments</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Debug for &amp;'a T <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Debug for &amp;'a mut T <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl Debug for <a class="primitive" href="../primitive.bool.html">bool</a></code></li>
<li><code>impl Debug for <a class="primitive" href="../primitive.str.html">str</a></code></li>
<li><code>impl Debug for <a class="primitive" href="../primitive.char.html">char</a></code></li>
<li><code>impl Debug for <a class="primitive" href="../primitive.f32.html">f32</a></code></li>
<li><code>impl Debug for <a class="primitive" href="../primitive.f64.html">f64</a></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.pointer.html">*const T</a></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.pointer.html">*mut T</a></code></li>
<li><code>impl&lt;T0,&nbsp;T1,&nbsp;T2,&nbsp;T3,&nbsp;T4,&nbsp;T5,&nbsp;T6,&nbsp;T7,&nbsp;T8,&nbsp;T9,&nbsp;T10,&nbsp;T11&gt; Debug for <a class="primitive" href="../primitive.tuple.html">(</a>T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where T0: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T1: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T10: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T11: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T2: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T3: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T4: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T5: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T6: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T7: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T8: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T9: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T1,&nbsp;T2,&nbsp;T3,&nbsp;T4,&nbsp;T5,&nbsp;T6,&nbsp;T7,&nbsp;T8,&nbsp;T9,&nbsp;T10,&nbsp;T11&gt; Debug for <a class="primitive" href="../primitive.tuple.html">(</a>T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where T1: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T10: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T11: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T2: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T3: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T4: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T5: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T6: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T7: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T8: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T9: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T2,&nbsp;T3,&nbsp;T4,&nbsp;T5,&nbsp;T6,&nbsp;T7,&nbsp;T8,&nbsp;T9,&nbsp;T10,&nbsp;T11&gt; Debug for <a class="primitive" href="../primitive.tuple.html">(</a>T2, T3, T4, T5, T6, T7, T8, T9, T10, T11<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where T10: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T11: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T2: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T3: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T4: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T5: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T6: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T7: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T8: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T9: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T3,&nbsp;T4,&nbsp;T5,&nbsp;T6,&nbsp;T7,&nbsp;T8,&nbsp;T9,&nbsp;T10,&nbsp;T11&gt; Debug for <a class="primitive" href="../primitive.tuple.html">(</a>T3, T4, T5, T6, T7, T8, T9, T10, T11<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where T10: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T11: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T3: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T4: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T5: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T6: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T7: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T8: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T9: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T4,&nbsp;T5,&nbsp;T6,&nbsp;T7,&nbsp;T8,&nbsp;T9,&nbsp;T10,&nbsp;T11&gt; Debug for <a class="primitive" href="../primitive.tuple.html">(</a>T4, T5, T6, T7, T8, T9, T10, T11<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where T10: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T11: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T4: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T5: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T6: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T7: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T8: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T9: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T5,&nbsp;T6,&nbsp;T7,&nbsp;T8,&nbsp;T9,&nbsp;T10,&nbsp;T11&gt; Debug for <a class="primitive" href="../primitive.tuple.html">(</a>T5, T6, T7, T8, T9, T10, T11<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where T10: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T11: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T5: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T6: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T7: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T8: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T9: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T6,&nbsp;T7,&nbsp;T8,&nbsp;T9,&nbsp;T10,&nbsp;T11&gt; Debug for <a class="primitive" href="../primitive.tuple.html">(</a>T6, T7, T8, T9, T10, T11<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where T10: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T11: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T6: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T7: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T8: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T9: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T7,&nbsp;T8,&nbsp;T9,&nbsp;T10,&nbsp;T11&gt; Debug for <a class="primitive" href="../primitive.tuple.html">(</a>T7, T8, T9, T10, T11<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where T10: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T11: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T7: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T8: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T9: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T8,&nbsp;T9,&nbsp;T10,&nbsp;T11&gt; Debug for <a class="primitive" href="../primitive.tuple.html">(</a>T8, T9, T10, T11<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where T10: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T11: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T8: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T9: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T9,&nbsp;T10,&nbsp;T11&gt; Debug for <a class="primitive" href="../primitive.tuple.html">(</a>T9, T10, T11<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where T10: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T11: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T9: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T10,&nbsp;T11&gt; Debug for <a class="primitive" href="../primitive.tuple.html">(</a>T10, T11<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where T10: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, T11: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T11&gt; Debug for <a class="primitive" href="../primitive.tuple.html">(</a>T11,<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where T11: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="primitive" href="../primitive.slice.html">[</a>T<a class="primitive" href="../primitive.slice.html">]</a> <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl Debug for <a class="primitive" href="../primitive.tuple.html">()</a></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/marker/struct.PhantomData.html" title="std::marker::PhantomData">PhantomData</a>&lt;T&gt; <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/cell/struct.Cell.html" title="std::cell::Cell">Cell</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a> + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/cell/struct.RefCell.html" title="std::cell::RefCell">RefCell</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;'b,&nbsp;T&gt; Debug for <a class="struct" href="../../std/cell/struct.Ref.html" title="std::cell::Ref">Ref</a>&lt;'b,&nbsp;T&gt; <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;'b,&nbsp;T&gt; Debug for <a class="struct" href="../../std/cell/struct.RefMut.html" title="std::cell::RefMut">RefMut</a>&lt;'b,&nbsp;T&gt; <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/cell/struct.UnsafeCell.html" title="std::cell::UnsafeCell">UnsafeCell</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/boxed/struct.Box.html" title="std::boxed::Box">Box</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/sync/struct.Weak.html" title="std::sync::Weak">Weak</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/sync/struct.Arc.html" title="std::sync::Arc">Arc</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/rc/struct.Rc.html" title="std::rc::Rc">Rc</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/rc/struct.Weak.html" title="std::rc::Weak">Weak</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/collections/binary_heap/struct.BinaryHeap.html" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a> + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;K,&nbsp;V&gt; Debug for <a class="struct" href="../../std/collections/btree_map/struct.BTreeMap.html" title="std::collections::btree_map::BTreeMap">BTreeMap</a>&lt;K,&nbsp;V&gt; <span class="where">where K: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, V: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/collections/btree_set/struct.BTreeSet.html" title="std::collections::btree_set::BTreeSet">BTreeSet</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;B&gt; Debug for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a,&nbsp;B&gt; <span class="where">where B: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a> + <a class="trait" href="../../std/borrow/trait.ToOwned.html" title="std::borrow::ToOwned">ToOwned</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a>, B::<a class="trait" href="../../std/borrow/trait.ToOwned.html" title="std::borrow::ToOwned">Owned</a>: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;E&gt; Debug for <a class="struct" href="../../collections/enum_set/struct.EnumSet.html" title="collections::enum_set::EnumSet">EnumSet</a>&lt;E&gt; <span class="where">where E: <a class="trait" href="../../collections/enum_set/trait.CLike.html" title="collections::enum_set::CLike">CLike</a> + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;A&gt; Debug for <a class="struct" href="../../std/collections/linked_list/struct.LinkedList.html" title="std::collections::linked_list::LinkedList">LinkedList</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/string/struct.FromUtf8Error.html" title="std::string::FromUtf8Error">FromUtf8Error</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/string/struct.FromUtf16Error.html" title="std::string::FromUtf16Error">FromUtf16Error</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/string/struct.String.html" title="std::string::String">String</a></code></li>
<li><code>impl Debug for <a class="enum" href="../../std/string/enum.ParseError.html" title="std::string::ParseError">ParseError</a></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/collections/vec_deque/struct.VecDeque.html" title="std::collections::vec_deque::VecDeque">VecDeque</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="enum" href="../../std/collections/enum.Bound.html" title="std::collections::Bound">Bound</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/char/struct.DecodeUtf16Error.html" title="std::char::DecodeUtf16Error">DecodeUtf16Error</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/thread/struct.Thread.html" title="std::thread::Thread">Thread</a></code></li>
<li><code>impl&lt;K,&nbsp;V,&nbsp;S&gt; Debug for <a class="struct" href="../../std/collections/struct.HashMap.html" title="std::collections::HashMap">HashMap</a>&lt;K,&nbsp;V,&nbsp;S&gt; <span class="where">where K: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a> + <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a> + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, V: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, S: <a class="trait" href="../../std/hash/trait.BuildHasher.html" title="std::hash::BuildHasher">BuildHasher</a></span></code></li>
<li><code>impl&lt;T,&nbsp;S&gt; Debug for <a class="struct" href="../../std/collections/struct.HashSet.html" title="std::collections::HashSet">HashSet</a>&lt;T,&nbsp;S&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a> + <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a> + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>, S: <a class="trait" href="../../std/hash/trait.BuildHasher.html" title="std::hash::BuildHasher">BuildHasher</a></span></code></li>
<li><code>impl Debug for <a class="enum" href="../../std/env/enum.VarError.html" title="std::env::VarError">VarError</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/env/struct.JoinPathsError.html" title="std::env::JoinPathsError">JoinPathsError</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/ffi/struct.NulError.html" title="std::ffi::NulError">NulError</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/ffi/struct.FromBytesWithNulError.html" title="std::ffi::FromBytesWithNulError">FromBytesWithNulError</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/ffi/struct.IntoStringError.html" title="std::ffi::IntoStringError">IntoStringError</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/ffi/struct.CString.html" title="std::ffi::CString">CString</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/ffi/struct.CStr.html" title="std::ffi::CStr">CStr</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/fs/struct.Permissions.html" title="std::fs::Permissions">Permissions</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/fs/struct.File.html" title="std::fs::File">File</a></code></li>
<li><code>impl&lt;R&gt; Debug for <a class="struct" href="../../std/io/struct.BufReader.html" title="std::io::BufReader">BufReader</a>&lt;R&gt; <span class="where">where R: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;W:&nbsp;<a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>&gt; Debug for <a class="struct" href="../../std/io/struct.IntoInnerError.html" title="std::io::IntoInnerError">IntoInnerError</a>&lt;W&gt;</code></li>
<li><code>impl&lt;W:&nbsp;<a class="trait" href="../../std/io/trait.Write.html" title="std::io::Write">Write</a>&gt; Debug for <a class="struct" href="../../std/io/struct.BufWriter.html" title="std::io::BufWriter">BufWriter</a>&lt;W&gt; <span class="where">where W: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;W:&nbsp;<a class="trait" href="../../std/io/trait.Write.html" title="std::io::Write">Write</a>&gt; Debug for <a class="struct" href="../../std/io/struct.LineWriter.html" title="std::io::LineWriter">LineWriter</a>&lt;W&gt; <span class="where">where W: <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a></span></code></li>
<li><code>impl&lt;T:&nbsp;<a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>&gt; Debug for <a class="struct" href="../../std/io/struct.Cursor.html" title="std::io::Cursor">Cursor</a>&lt;T&gt;</code></li>
<li><code>impl Debug for <a class="struct" href="../../std/io/struct.Error.html" title="std::io::Error">Error</a></code></li>
<li><code>impl Debug for <a class="enum" href="../../std/io/enum.ErrorKind.html" title="std::io::ErrorKind">ErrorKind</a></code></li>
<li><code>impl Debug for <a class="enum" href="../../std/io/enum.SeekFrom.html" title="std::io::SeekFrom">SeekFrom</a></code></li>
<li><code>impl Debug for <a class="enum" href="../../std/io/enum.CharsError.html" title="std::io::CharsError">CharsError</a></code></li>
<li><code>impl Debug for <a class="enum" href="../../std/net/enum.IpAddr.html" title="std::net::IpAddr">IpAddr</a></code></li>
<li><code>impl Debug for <a class="enum" href="../../std/net/enum.Ipv6MulticastScope.html" title="std::net::Ipv6MulticastScope">Ipv6MulticastScope</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/net/struct.Ipv4Addr.html" title="std::net::Ipv4Addr">Ipv4Addr</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/net/struct.Ipv6Addr.html" title="std::net::Ipv6Addr">Ipv6Addr</a></code></li>
<li><code>impl Debug for <a class="enum" href="../../std/net/enum.SocketAddr.html" title="std::net::SocketAddr">SocketAddr</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/net/struct.SocketAddrV4.html" title="std::net::SocketAddrV4">SocketAddrV4</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/net/struct.SocketAddrV6.html" title="std::net::SocketAddrV6">SocketAddrV6</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/net/struct.TcpStream.html" title="std::net::TcpStream">TcpStream</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/net/struct.TcpListener.html" title="std::net::TcpListener">TcpListener</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/net/struct.UdpSocket.html" title="std::net::UdpSocket">UdpSocket</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/net/struct.AddrParseError.html" title="std::net::AddrParseError">AddrParseError</a></code></li>
<li><code>impl Debug for <a class="enum" href="../../std/net/enum.Shutdown.html" title="std::net::Shutdown">Shutdown</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/os/unix/net/struct.SocketAddr.html" title="std::os::unix::net::SocketAddr">SocketAddr</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/os/unix/net/struct.UnixStream.html" title="std::os::unix::net::UnixStream">UnixStream</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/os/unix/net/struct.UnixListener.html" title="std::os::unix::net::UnixListener">UnixListener</a></code></li>
<li><code>impl&lt;'a&gt; Debug for <a class="struct" href="../../std/os/unix/net/struct.Incoming.html" title="std::os::unix::net::Incoming">Incoming</a>&lt;'a&gt;</code></li>
<li><code>impl Debug for <a class="struct" href="../../std/os/unix/net/struct.UnixDatagram.html" title="std::os::unix::net::UnixDatagram">UnixDatagram</a></code></li>
<li><code>impl&lt;'a&gt; Debug for <a class="enum" href="../../std/path/enum.Prefix.html" title="std::path::Prefix">Prefix</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; Debug for <a class="struct" href="../../std/path/struct.PrefixComponent.html" title="std::path::PrefixComponent">PrefixComponent</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; Debug for <a class="enum" href="../../std/path/enum.Component.html" title="std::path::Component">Component</a>&lt;'a&gt;</code></li>
<li><code>impl Debug for <a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/path/struct.StripPrefixError.html" title="std::path::StripPrefixError">StripPrefixError</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/path/struct.Path.html" title="std::path::Path">Path</a></code></li>
<li><code>impl&lt;'a&gt; Debug for <a class="struct" href="../../std/path/struct.Display.html" title="std::path::Display">Display</a>&lt;'a&gt;</code></li>
<li><code>impl Debug for <a class="struct" href="../../std/process/struct.Command.html" title="std::process::Command">Command</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/process/struct.Output.html" title="std::process::Output">Output</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/process/struct.ExitStatus.html" title="std::process::ExitStatus">ExitStatus</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/sync/mpsc/struct.Select.html" title="std::sync::mpsc::Select">Select</a></code></li>
<li><code>impl&lt;'rx,&nbsp;T:&nbsp;<a class="trait" href="../../std/marker/trait.Send.html" title="std::marker::Send">Send</a> + 'rx&gt; Debug for <a class="struct" href="../../std/sync/mpsc/struct.Handle.html" title="std::sync::mpsc::Handle">Handle</a>&lt;'rx,&nbsp;T&gt;</code></li>
<li><code>impl Debug for <a class="struct" href="../../std/sync/mpsc/struct.RecvError.html" title="std::sync::mpsc::RecvError">RecvError</a></code></li>
<li><code>impl Debug for <a class="enum" href="../../std/sync/mpsc/enum.TryRecvError.html" title="std::sync::mpsc::TryRecvError">TryRecvError</a></code></li>
<li><code>impl Debug for <a class="enum" href="../../std/sync/mpsc/enum.RecvTimeoutError.html" title="std::sync::mpsc::RecvTimeoutError">RecvTimeoutError</a></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/sync/mpsc/struct.Sender.html" title="std::sync::mpsc::Sender">Sender</a>&lt;T&gt;</code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/sync/mpsc/struct.SyncSender.html" title="std::sync::mpsc::SyncSender">SyncSender</a>&lt;T&gt;</code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/sync/mpsc/struct.Receiver.html" title="std::sync::mpsc::Receiver">Receiver</a>&lt;T&gt;</code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/sync/mpsc/struct.SendError.html" title="std::sync::mpsc::SendError">SendError</a>&lt;T&gt;</code></li>
<li><code>impl&lt;T&gt; Debug for <a class="enum" href="../../std/sync/mpsc/enum.TrySendError.html" title="std::sync::mpsc::TrySendError">TrySendError</a>&lt;T&gt;</code></li>
<li><code>impl Debug for <a class="struct" href="../../std/sync/struct.WaitTimeoutResult.html" title="std::sync::WaitTimeoutResult">WaitTimeoutResult</a></code></li>
<li><code>impl&lt;T:&nbsp;?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a> + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>&gt; Debug for <a class="struct" href="../../std/sync/struct.Mutex.html" title="std::sync::Mutex">Mutex</a>&lt;T&gt;</code></li>
<li><code>impl&lt;T:&nbsp;?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a> + <a class="trait" href="../../std/fmt/trait.Debug.html" title="std::fmt::Debug">Debug</a>&gt; Debug for <a class="struct" href="../../std/sync/struct.RwLock.html" title="std::sync::RwLock">RwLock</a>&lt;T&gt;</code></li>
<li><code>impl Debug for <a class="struct" href="../../std/time/struct.Duration.html" title="std::time::Duration">Duration</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/time/struct.SystemTimeError.html" title="std::time::SystemTimeError">SystemTimeError</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/time/struct.Instant.html" title="std::time::Instant">Instant</a></code></li>
<li><code>impl Debug for <a class="struct" href="../../std/time/struct.SystemTime.html" title="std::time::SystemTime">SystemTime</a></code></li>
<li><code>impl&lt;T&gt; Debug for <a class="struct" href="../../std/sync/struct.PoisonError.html" title="std::sync::PoisonError">PoisonError</a>&lt;T&gt;</code></li>
<li><code>impl&lt;T&gt; Debug for <a class="enum" href="../../std/sync/enum.TryLockError.html" title="std::sync::TryLockError">TryLockError</a>&lt;T&gt;</code></li>
</ul><script src="../../implementors/core/fmt/trait.Debug.js" async="" type="text/javascript">
                 </script></div></div><div class="outerdoc" id="trait.Copy"><div class="docblock" id="trait.Copy">
<h1 class="fqn"><span class="in-band">Trait <a href="../">std</a>::<wbr><a href="index.html">marker</a>::<wbr><a class="trait" href="">Copy</a></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><span id="render-detail">
                   <a href="javascript:void(0)" id="toggle-all-docs" title="collapse all docs">
                       [<span class="inner"></span>]
                   </a>
               </span><a class="srclink" href="../../core/marker/trait.Copy.html?gotosrc=13549" id="src-13549" title="goto source code">[src]</a></span></h1>
<pre class="rust trait">pub trait Copy: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a> { }</pre><div class="docblock"><p>Types that can be copied by simply copying bits (i.e. <code>memcpy</code>).</p>

<p>By default, variable bindings have 'move semantics.' In other
words:</p>

<span class="rusttest">fn main() {
    #[derive(Debug)]
struct Foo;

let x = Foo;

let y = x;

// `x` has moved into `y`, and so cannot be used

// println!("{:?}", x); // error: use of moved value
}</span><pre class="rust rust-example-rendered"><span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
<span class="kw">struct</span> <span class="ident">Foo</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Foo</span>;

<span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="ident">x</span>;

<span class="comment">// `x` has moved into `y`, and so cannot be used</span>

<span class="comment">// println!("{:?}", x); // error: use of moved value</span></pre>

<p>However, if a type implements <code>Copy</code>, it instead has 'copy semantics':</p>

<span class="rusttest">fn main() {
    // we can just derive a `Copy` implementation
#[derive(Debug, Copy, Clone)]
struct Foo;

let x = Foo;

let y = x;

// `y` is a copy of `x`

println!("{:?}", x); // A-OK!
}</span><pre class="rust rust-example-rendered"><span class="comment">// we can just derive a `Copy` implementation</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>, <span class="ident">Copy</span>, <span class="ident">Clone</span>)]</span>
<span class="kw">struct</span> <span class="ident">Foo</span>;

<span class="kw">let</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">Foo</span>;

<span class="kw">let</span> <span class="ident">y</span> <span class="op">=</span> <span class="ident">x</span>;

<span class="comment">// `y` is a copy of `x`</span>

<span class="macro">println</span><span class="macro">!</span>(<span class="string">"{:?}"</span>, <span class="ident">x</span>); <span class="comment">// A-OK!</span></pre>

<p>It's important to note that in these two examples, the only difference is if you are allowed to
access <code>x</code> after the assignment: a move is also a bitwise copy under the hood.</p>

<h2 class="section-header" id="when-can-my-type-be-copy"><a href="#when-can-my-type-be-copy">When can my type be <code>Copy</code>?</a></h2>
<p>A type can implement <code>Copy</code> if all of its components implement <code>Copy</code>. For example, this
<code>struct</code> can be <code>Copy</code>:</p>

<span class="rusttest">fn main() {
    #[allow(dead_code)]
struct Point {
   x: i32,
   y: i32,
}
}</span><pre class="rust rust-example-rendered"><span class="kw">struct</span> <span class="ident">Point</span> {
   <span class="ident">x</span>: <span class="ident">i32</span>,
   <span class="ident">y</span>: <span class="ident">i32</span>,
}</pre>

<p>A <code>struct</code> can be <code>Copy</code>, and <code>i32</code> is <code>Copy</code>, so therefore, <code>Point</code> is eligible to be <code>Copy</code>.</p>

<span class="rusttest">fn main() {
    #![allow(dead_code)]
struct Point;
struct PointList {
    points: Vec&lt;Point&gt;,
}
}</span><pre class="rust rust-example-rendered"><span class="kw">struct</span> <span class="ident">PointList</span> {
    <span class="ident">points</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">Point</span><span class="op">&gt;</span>,
}</pre>

<p>The <code>PointList</code> <code>struct</code> cannot implement <code>Copy</code>, because <code>Vec&lt;T&gt;</code> is not <code>Copy</code>. If we
attempt to derive a <code>Copy</code> implementation, we'll get an error:</p>

<pre><code class="language-text">the trait `Copy` may not be implemented for this type; field `points` does not implement `Copy`
</code></pre>

<h2 class="section-header" id="when-can-my-type-not-be-copy"><a href="#when-can-my-type-not-be-copy">When can my type <em>not</em> be <code>Copy</code>?</a></h2>
<p>Some types can't be copied safely. For example, copying <code>&amp;mut T</code> would create an aliased
mutable reference, and copying <code>String</code> would result in two attempts to free the same buffer.</p>

<p>Generalizing the latter case, any type implementing <code>Drop</code> can't be <code>Copy</code>, because it's
managing some resource besides its own <code>size_of::&lt;T&gt;()</code> bytes.</p>

<h2 class="section-header" id="when-should-my-type-be-copy"><a href="#when-should-my-type-be-copy">When should my type be <code>Copy</code>?</a></h2>
<p>Generally speaking, if your type <em>can</em> implement <code>Copy</code>, it should. There's one important thing
to consider though: if you think your type may <em>not</em> be able to implement <code>Copy</code> in the future,
then it might be prudent to not implement <code>Copy</code>. This is because removing <code>Copy</code> is a breaking
change: that second example would fail to compile if we made <code>Foo</code> non-<code>Copy</code>.</p>

<h2 class="section-header" id="derivable"><a href="#derivable">Derivable</a></h2>
<p>This trait can be used with <code>#[derive]</code> if all of its components implement <code>Copy</code> and the type
implements <code>Clone</code>. The implementation will copy the bytes of each field using <code>memcpy</code>.</p>

<h2 class="section-header" id="how-can-i-implement-copy"><a href="#how-can-i-implement-copy">How can I implement <code>Copy</code>?</a></h2>
<p>There are two ways to implement <code>Copy</code> on your type:</p>

<span class="rusttest">fn main() {
    #[derive(Copy, Clone)]
struct MyStruct;
}</span><pre class="rust rust-example-rendered"><span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Copy</span>, <span class="ident">Clone</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyStruct</span>;</pre>

<p>and</p>

<span class="rusttest">fn main() {
    struct MyStruct;
impl Copy for MyStruct {}
impl Clone for MyStruct { fn clone(&amp;self) -&gt; MyStruct { *self } }
}</span><pre class="rust rust-example-rendered"><span class="kw">struct</span> <span class="ident">MyStruct</span>;
<span class="kw">impl</span> <span class="ident">Copy</span> <span class="kw">for</span> <span class="ident">MyStruct</span> {}
<span class="kw">impl</span> <span class="ident">Clone</span> <span class="kw">for</span> <span class="ident">MyStruct</span> { <span class="kw">fn</span> <span class="ident">clone</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">MyStruct</span> { <span class="op">*</span><span class="self">self</span> } }</pre>

<p>There is a small difference between the two: the <code>derive</code> strategy will also place a <code>Copy</code>
bound on type parameters, which isn't always desired.</p>
</div>
        <h2 id="implementors">Implementors</h2>
        <ul class="item-list" id="implementors-list">
    <li><code>impl&lt;T&gt; Copy for <a class="struct" href="../../std/num/struct.Wrapping.html" title="std::num::Wrapping">Wrapping</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl Copy for <a class="enum" href="../../std/num/enum.FpCategory.html" title="std::num::FpCategory">FpCategory</a></code></li>
<li><code>impl Copy for <a class="struct" href="../../std/num/struct.TryFromIntError.html" title="std::num::TryFromIntError">TryFromIntError</a></code></li>
<li><code>impl&lt;T&gt; Copy for <a class="struct" href="../../core/nonzero/struct.NonZero.html" title="core::nonzero::NonZero">NonZero</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a> + <a class="trait" href="../../core/nonzero/trait.Zeroable.html" title="core::nonzero::Zeroable">Zeroable</a></span></code></li>
<li><code>impl&lt;T&gt; Copy for <a class="struct" href="../../std/ptr/struct.Shared.html" title="std::ptr::Shared">Shared</a>&lt;T&gt; <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Copy for <a class="struct" href="../../std/marker/struct.PhantomData.html" title="std::marker::PhantomData">PhantomData</a>&lt;T&gt; <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl Copy for <a class="struct" href="../../std/ops/struct.RangeFull.html" title="std::ops::RangeFull">RangeFull</a></code></li>
<li><code>impl&lt;Idx&gt; Copy for <a class="struct" href="../../std/ops/struct.RangeTo.html" title="std::ops::RangeTo">RangeTo</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;Idx&gt; Copy for <a class="struct" href="../../std/ops/struct.RangeToInclusive.html" title="std::ops::RangeToInclusive">RangeToInclusive</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl Copy for <a class="enum" href="../../std/cmp/enum.Ordering.html" title="std::cmp::Ordering">Ordering</a></code></li>
<li><code>impl Copy for <a class="struct" href="../../std/any/struct.TypeId.html" title="std::any::TypeId">TypeId</a></code></li>
<li><code>impl Copy for <a class="enum" href="../../std/sync/atomic/enum.Ordering.html" title="std::sync::atomic::Ordering">Ordering</a></code></li>
<li><code>impl Copy for <a class="enum" href="../../std/cell/enum.BorrowState.html" title="std::cell::BorrowState">BorrowState</a></code></li>
<li><code>impl&lt;T&gt; Copy for <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl Copy for <a class="struct" href="../../std/raw/struct.TraitObject.html" title="std::raw::TraitObject">TraitObject</a></code></li>
<li><code>impl&lt;T,&nbsp;E&gt; Copy for <a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;T,&nbsp;E&gt; <span class="where">where E: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a>, T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl Copy for <a class="enum" href="../../std/str/pattern/enum.SearchStep.html" title="std::str::pattern::SearchStep">SearchStep</a></code></li>
<li><code>impl Copy for <a class="struct" href="../../std/str/struct.Utf8Error.html" title="std::str::Utf8Error">Utf8Error</a></code></li>
<li><code>impl Copy for <a class="struct" href="../../std/fmt/struct.Error.html" title="std::fmt::Error">Error</a></code></li>
<li><code>impl&lt;'a&gt; Copy for <a class="struct" href="../../std/fmt/struct.Arguments.html" title="std::fmt::Arguments">Arguments</a>&lt;'a&gt;</code></li>
<li><code>impl Copy for <a class="struct" href="../../std/boxed/struct.ExchangeHeapSingleton.html" title="std::boxed::ExchangeHeapSingleton">ExchangeHeapSingleton</a></code></li>
<li><code>impl&lt;E&gt; Copy for <a class="struct" href="../../collections/enum_set/struct.EnumSet.html" title="collections::enum_set::EnumSet">EnumSet</a>&lt;E&gt;</code></li>
<li><code>impl Copy for <a class="enum" href="../../std/string/enum.ParseError.html" title="std::string::ParseError">ParseError</a></code></li>
<li><code>impl&lt;T&gt; Copy for <a class="enum" href="../../std/collections/enum.Bound.html" title="std::collections::Bound">Bound</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl Copy for <a class="enum" href="../../std/thread/enum.LocalKeyState.html" title="std::thread::LocalKeyState">LocalKeyState</a></code></li>
<li><code>impl Copy for <a class="struct" href="../../std/fs/struct.FileType.html" title="std::fs::FileType">FileType</a></code></li>
<li><code>impl Copy for <a class="enum" href="../../std/io/enum.ErrorKind.html" title="std::io::ErrorKind">ErrorKind</a></code></li>
<li><code>impl Copy for <a class="enum" href="../../std/io/enum.SeekFrom.html" title="std::io::SeekFrom">SeekFrom</a></code></li>
<li><code>impl Copy for <a class="enum" href="../../std/net/enum.IpAddr.html" title="std::net::IpAddr">IpAddr</a></code></li>
<li><code>impl Copy for <a class="struct" href="../../std/net/struct.Ipv4Addr.html" title="std::net::Ipv4Addr">Ipv4Addr</a></code></li>
<li><code>impl Copy for <a class="struct" href="../../std/net/struct.Ipv6Addr.html" title="std::net::Ipv6Addr">Ipv6Addr</a></code></li>
<li><code>impl Copy for <a class="enum" href="../../std/net/enum.Ipv6MulticastScope.html" title="std::net::Ipv6MulticastScope">Ipv6MulticastScope</a></code></li>
<li><code>impl Copy for <a class="enum" href="../../std/net/enum.SocketAddr.html" title="std::net::SocketAddr">SocketAddr</a></code></li>
<li><code>impl Copy for <a class="struct" href="../../std/net/struct.SocketAddrV4.html" title="std::net::SocketAddrV4">SocketAddrV4</a></code></li>
<li><code>impl Copy for <a class="struct" href="../../std/net/struct.SocketAddrV6.html" title="std::net::SocketAddrV6">SocketAddrV6</a></code></li>
<li><code>impl Copy for <a class="enum" href="../../std/net/enum.Shutdown.html" title="std::net::Shutdown">Shutdown</a></code></li>
<li><code>impl&lt;'a&gt; Copy for <a class="enum" href="../../std/path/enum.Prefix.html" title="std::path::Prefix">Prefix</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; Copy for <a class="struct" href="../../std/path/struct.PrefixComponent.html" title="std::path::PrefixComponent">PrefixComponent</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; Copy for <a class="enum" href="../../std/path/enum.Component.html" title="std::path::Component">Component</a>&lt;'a&gt;</code></li>
<li><code>impl Copy for <a class="struct" href="../../std/process/struct.ExitStatus.html" title="std::process::ExitStatus">ExitStatus</a></code></li>
<li><code>impl&lt;T:&nbsp;<a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a>&gt; Copy for <a class="struct" href="../../std/sync/mpsc/struct.SendError.html" title="std::sync::mpsc::SendError">SendError</a>&lt;T&gt;</code></li>
<li><code>impl Copy for <a class="struct" href="../../std/sync/mpsc/struct.RecvError.html" title="std::sync::mpsc::RecvError">RecvError</a></code></li>
<li><code>impl Copy for <a class="enum" href="../../std/sync/mpsc/enum.TryRecvError.html" title="std::sync::mpsc::TryRecvError">TryRecvError</a></code></li>
<li><code>impl Copy for <a class="enum" href="../../std/sync/mpsc/enum.RecvTimeoutError.html" title="std::sync::mpsc::RecvTimeoutError">RecvTimeoutError</a></code></li>
<li><code>impl&lt;T:&nbsp;<a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a>&gt; Copy for <a class="enum" href="../../std/sync/mpsc/enum.TrySendError.html" title="std::sync::mpsc::TrySendError">TrySendError</a>&lt;T&gt;</code></li>
<li><code>impl Copy for <a class="struct" href="../../std/sync/struct.WaitTimeoutResult.html" title="std::sync::WaitTimeoutResult">WaitTimeoutResult</a></code></li>
<li><code>impl Copy for <a class="struct" href="../../std/time/struct.Duration.html" title="std::time::Duration">Duration</a></code></li>
<li><code>impl Copy for <a class="struct" href="../../std/time/struct.Instant.html" title="std::time::Instant">Instant</a></code></li>
<li><code>impl Copy for <a class="struct" href="../../std/time/struct.SystemTime.html" title="std::time::SystemTime">SystemTime</a></code></li>
<li><code>impl Copy for <a class="struct" href="https://doc.rust-lang.org/nightly/rand/distributions/normal/struct.StandardNormal.html" title="rand::distributions::normal::StandardNormal">StandardNormal</a></code></li>
<li><code>impl Copy for <a class="struct" href="https://doc.rust-lang.org/nightly/rand/distributions/normal/struct.Normal.html" title="rand::distributions::normal::Normal">Normal</a></code></li>
<li><code>impl Copy for <a class="struct" href="https://doc.rust-lang.org/nightly/rand/distributions/normal/struct.LogNormal.html" title="rand::distributions::normal::LogNormal">LogNormal</a></code></li>
<li><code>impl Copy for <a class="struct" href="https://doc.rust-lang.org/nightly/rand/distributions/exponential/struct.Exp1.html" title="rand::distributions::exponential::Exp1">Exp1</a></code></li>
<li><code>impl Copy for <a class="struct" href="https://doc.rust-lang.org/nightly/rand/distributions/exponential/struct.Exp.html" title="rand::distributions::exponential::Exp">Exp</a></code></li>
<li><code>impl Copy for <a class="struct" href="../../rand/isaac/struct.IsaacRng.html" title="rand::isaac::IsaacRng">IsaacRng</a></code></li>
<li><code>impl Copy for <a class="struct" href="../../rand/isaac/struct.Isaac64Rng.html" title="rand::isaac::Isaac64Rng">Isaac64Rng</a></code></li>
<li><code>impl Copy for <a class="struct" href="https://doc.rust-lang.org/nightly/rand/chacha/struct.ChaChaRng.html" title="rand::chacha::ChaChaRng">ChaChaRng</a></code></li>
<li><code>impl Copy for <a class="struct" href="../../rand/reseeding/struct.ReseedWithDefault.html" title="rand::reseeding::ReseedWithDefault">ReseedWithDefault</a></code></li>
</ul><script src="../../implementors/core/marker/trait.Copy.js" async="" type="text/javascript">
                 </script></div></div><div class="outerdoc" id="trait.Clone"><div class="docblock" id="trait.Clone">
<h1 class="fqn"><span class="in-band">Trait <a href="../">std</a>::<wbr><a href="index.html">clone</a>::<wbr><a class="trait" href="">Clone</a></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><span id="render-detail">
                   <a href="javascript:void(0)" id="toggle-all-docs" title="collapse all docs">
                       [<span class="inner"></span>]
                   </a>
               </span><a class="srclink" href="../../core/clone/trait.Clone.html?gotosrc=23124" id="src-23124" title="goto source code">[src]</a></span></h1>
<pre class="rust trait">pub trait Clone {
    fn <a class="fnname" href="#tymethod.clone">clone</a>(&amp;self) -&gt; Self;

    fn <a class="fnname" href="#method.clone_from">clone_from</a>(&amp;mut self, source: &amp;Self) { ... }
}</pre><div class="docblock"><p>A common trait for the ability to explicitly duplicate an object.</p>

<p>Differs from <code>Copy</code> in that <code>Copy</code> is implicit and extremely inexpensive, while
<code>Clone</code> is always explicit and may or may not be expensive. In order to enforce
these characteristics, Rust does not allow you to reimplement <code>Copy</code>, but you
may reimplement <code>Clone</code> and run arbitrary code.</p>

<p>Since <code>Clone</code> is more general than <code>Copy</code>, you can automatically make anything
<code>Copy</code> be <code>Clone</code> as well.</p>

<h2 class="section-header" id="derivable"><a href="#derivable">Derivable</a></h2>
<p>This trait can be used with <code>#[derive]</code> if all fields are <code>Clone</code>. The <code>derive</code>d
implementation of <code>clone()</code> calls <code>clone()</code> on each field.</p>

<h2 class="section-header" id="how-can-i-implement-clone"><a href="#how-can-i-implement-clone">How can I implement <code>Clone</code>?</a></h2>
<p>Types that are <code>Copy</code> should have a trivial implementation of <code>Clone</code>. More formally:
if <code>T: Copy</code>, <code>x: T</code>, and <code>y: &amp;T</code>, then <code>let x = y.clone();</code> is equivalent to <code>let x = *y;</code>.
Manual implementations should be careful to uphold this invariant; however, unsafe code
must not rely on it to ensure memory safety.</p>

<p>An example is an array holding more than 32 elements of a type that is <code>Clone</code>; the standard
library only implements <code>Clone</code> up until arrays of size 32. In this case, the implementation of
<code>Clone</code> cannot be <code>derive</code>d, but can be implemented as:</p>

<span class="rusttest">fn main() {
    #[derive(Copy)]
struct Stats {
   frequencies: [i32; 100],
}

impl Clone for Stats {
    fn clone(&amp;self) -&gt; Stats { *self }
}
}</span><pre class="rust rust-example-rendered"><span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Copy</span>)]</span>
<span class="kw">struct</span> <span class="ident">Stats</span> {
   <span class="ident">frequencies</span>: [<span class="ident">i32</span>; <span class="number">100</span>],
}

<span class="kw">impl</span> <span class="ident">Clone</span> <span class="kw">for</span> <span class="ident">Stats</span> {
    <span class="kw">fn</span> <span class="ident">clone</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">Stats</span> { <span class="op">*</span><span class="self">self</span> }
}</pre>
</div>
            <h2 id="required-methods">Required Methods</h2>
            <div class="methods">
        <h3 class="method stab " id="tymethod.clone"><code>fn <a class="fnname" href="#tymethod.clone">clone</a>(&amp;self) -&gt; Self</code></h3><div class="docblock"><p>Returns a copy of the value.</p>

<h1 class="section-header" id="examples"><a href="#examples">Examples</a></h1>
<span class="rusttest">fn main() {
    let hello = "Hello"; // &amp;str implements Clone

assert_eq!("Hello", hello.clone());
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">hello</span> <span class="op">=</span> <span class="string">"Hello"</span>; <span class="comment">// &amp;str implements Clone</span>

<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="string">"Hello"</span>, <span class="ident">hello</span>.<span class="ident">clone</span>());</pre>
</div></div>
            <h2 id="provided-methods">Provided Methods</h2>
            <div class="methods">
        <h3 class="method stab " id="method.clone_from"><code>fn <a class="fnname" href="#method.clone_from">clone_from</a>(&amp;mut self, source: &amp;Self)</code></h3><div class="docblock"><p>Performs copy-assignment from <code>source</code>.</p>

<p><code>a.clone_from(&amp;b)</code> is equivalent to <code>a = b.clone()</code> in functionality,
but can be overridden to reuse the resources of <code>a</code> to avoid unnecessary
allocations.</p>
</div></div>
        <h2 id="implementors">Implementors</h2>
        <ul class="item-list" id="implementors-list">
    <li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/num/struct.Wrapping.html" title="std::num::Wrapping">Wrapping</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/num/struct.ParseFloatError.html" title="std::num::ParseFloatError">ParseFloatError</a></code></li>
<li><code>impl Clone for <a class="enum" href="../../std/num/enum.FpCategory.html" title="std::num::FpCategory">FpCategory</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/num/struct.TryFromIntError.html" title="std::num::TryFromIntError">TryFromIntError</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/num/struct.ParseIntError.html" title="std::num::ParseIntError">ParseIntError</a></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../core/nonzero/struct.NonZero.html" title="core::nonzero::NonZero">NonZero</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../core/nonzero/trait.Zeroable.html" title="core::nonzero::Zeroable">Zeroable</a> + <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.pointer.html">*const T</a> <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.pointer.html">*mut T</a> <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;Ret&gt; Clone for fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret&gt; Clone for extern fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret&gt; Clone for unsafe fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret&gt; Clone for unsafe extern fn() -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A&gt; Clone for fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A&gt; Clone for extern fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A&gt; Clone for unsafe fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A&gt; Clone for unsafe extern fn(A) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B&gt; Clone for fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B&gt; Clone for extern fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B&gt; Clone for unsafe fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B&gt; Clone for unsafe extern fn(A, B) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C&gt; Clone for fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C&gt; Clone for extern fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C&gt; Clone for unsafe fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C&gt; Clone for unsafe extern fn(A, B, C) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D&gt; Clone for fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D&gt; Clone for extern fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D&gt; Clone for unsafe fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D&gt; Clone for unsafe extern fn(A, B, C, D) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E&gt; Clone for fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E&gt; Clone for extern fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E&gt; Clone for unsafe fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E&gt; Clone for unsafe extern fn(A, B, C, D, E) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F&gt; Clone for fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F&gt; Clone for extern fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F&gt; Clone for unsafe fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F&gt; Clone for unsafe extern fn(A, B, C, D, E, F) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G&gt; Clone for fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G&gt; Clone for extern fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G&gt; Clone for unsafe fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G&gt; Clone for unsafe extern fn(A, B, C, D, E, F, G) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H&gt; Clone for fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H&gt; Clone for extern fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H&gt; Clone for unsafe fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H&gt; Clone for unsafe extern fn(A, B, C, D, E, F, G, H) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I&gt; Clone for fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I&gt; Clone for extern fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I&gt; Clone for unsafe fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I&gt; Clone for unsafe extern fn(A, B, C, D, E, F, G, H, I) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J&gt; Clone for fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J&gt; Clone for extern fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J&gt; Clone for unsafe fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J&gt; Clone for unsafe extern fn(A, B, C, D, E, F, G, H, I, J) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K&gt; Clone for fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K&gt; Clone for extern fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K&gt; Clone for unsafe fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K&gt; Clone for unsafe extern fn(A, B, C, D, E, F, G, H, I, J, K) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K,&nbsp;L&gt; Clone for fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K,&nbsp;L&gt; Clone for extern fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K,&nbsp;L&gt; Clone for unsafe fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;Ret,&nbsp;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K,&nbsp;L&gt; Clone for unsafe extern fn(A, B, C, D, E, F, G, H, I, J, K, L) -&gt; Ret</code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/ptr/struct.Shared.html" title="std::ptr::Shared">Shared</a>&lt;T&gt; <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/marker/struct.PhantomData.html" title="std::marker::PhantomData">PhantomData</a>&lt;T&gt; <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/ops/struct.RangeFull.html" title="std::ops::RangeFull">RangeFull</a></code></li>
<li><code>impl&lt;Idx&gt; Clone for <a class="struct" href="../../std/ops/struct.Range.html" title="std::ops::Range">Range</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;Idx&gt; Clone for <a class="struct" href="../../std/ops/struct.RangeFrom.html" title="std::ops::RangeFrom">RangeFrom</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;Idx&gt; Clone for <a class="struct" href="../../std/ops/struct.RangeTo.html" title="std::ops::RangeTo">RangeTo</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;Idx&gt; Clone for <a class="enum" href="../../std/ops/enum.RangeInclusive.html" title="std::ops::RangeInclusive">RangeInclusive</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;Idx&gt; Clone for <a class="struct" href="../../std/ops/struct.RangeToInclusive.html" title="std::ops::RangeToInclusive">RangeToInclusive</a>&lt;Idx&gt; <span class="where">where Idx: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl Clone for <a class="enum" href="../../std/cmp/enum.Ordering.html" title="std::cmp::Ordering">Ordering</a></code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Clone for &amp;'a T <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl Clone for <a class="primitive" href="../primitive.isize.html">isize</a></code></li>
<li><code>impl Clone for <a class="primitive" href="../primitive.i8.html">i8</a></code></li>
<li><code>impl Clone for <a class="primitive" href="../primitive.i16.html">i16</a></code></li>
<li><code>impl Clone for <a class="primitive" href="../primitive.i32.html">i32</a></code></li>
<li><code>impl Clone for <a class="primitive" href="../primitive.i64.html">i64</a></code></li>
<li><code>impl Clone for <a class="primitive" href="../primitive.usize.html">usize</a></code></li>
<li><code>impl Clone for <a class="primitive" href="../primitive.u8.html">u8</a></code></li>
<li><code>impl Clone for <a class="primitive" href="../primitive.u16.html">u16</a></code></li>
<li><code>impl Clone for <a class="primitive" href="../primitive.u32.html">u32</a></code></li>
<li><code>impl Clone for <a class="primitive" href="../primitive.u64.html">u64</a></code></li>
<li><code>impl Clone for <a class="primitive" href="../primitive.f32.html">f32</a></code></li>
<li><code>impl Clone for <a class="primitive" href="../primitive.f64.html">f64</a></code></li>
<li><code>impl Clone for <a class="primitive" href="../primitive.tuple.html">()</a></code></li>
<li><code>impl Clone for <a class="primitive" href="../primitive.bool.html">bool</a></code></li>
<li><code>impl Clone for <a class="primitive" href="../primitive.char.html">char</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/any/struct.TypeId.html" title="std::any::TypeId">TypeId</a></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 0]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 1]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 2]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 3]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 4]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 5]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 6]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 7]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 8]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 9]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 10]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 11]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 12]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 13]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 14]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 15]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 16]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 17]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 18]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 19]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 20]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 21]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 22]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 23]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 24]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 25]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 26]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 27]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 28]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 29]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 30]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 31]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 32]</a> <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl Clone for <a class="enum" href="../../std/sync/atomic/enum.Ordering.html" title="std::sync::atomic::Ordering">Ordering</a></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/cell/struct.Cell.html" title="std::cell::Cell">Cell</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a></span></code></li>
<li><code>impl Clone for <a class="enum" href="../../std/cell/enum.BorrowState.html" title="std::cell::BorrowState">BorrowState</a></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/cell/struct.RefCell.html" title="std::cell::RefCell">RefCell</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/char/struct.EscapeUnicode.html" title="std::char::EscapeUnicode">EscapeUnicode</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/char/struct.EscapeDefault.html" title="std::char::EscapeDefault">EscapeDefault</a></code></li>
<li><code>impl&lt;A,&nbsp;R&gt; Clone for <a class="struct" href="../../std/iter/struct.StepBy.html" title="std::iter::StepBy">StepBy</a>&lt;A,&nbsp;R&gt; <span class="where">where A: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, R: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;A&gt; Clone for <a class="struct" href="../../std/iter/struct.Repeat.html" title="std::iter::Repeat">Repeat</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/iter/struct.Empty.html" title="std::iter::Empty">Empty</a>&lt;T&gt;</code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/iter/struct.Once.html" title="std::iter::Once">Once</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/iter/struct.Rev.html" title="std::iter::Rev">Rev</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;I&gt; Clone for <a class="struct" href="../../std/iter/struct.Cloned.html" title="std::iter::Cloned">Cloned</a>&lt;I&gt; <span class="where">where I: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;I&gt; Clone for <a class="struct" href="../../std/iter/struct.Cycle.html" title="std::iter::Cycle">Cycle</a>&lt;I&gt; <span class="where">where I: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B&gt; Clone for <a class="struct" href="../../std/iter/struct.Chain.html" title="std::iter::Chain">Chain</a>&lt;A,&nbsp;B&gt; <span class="where">where A: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, B: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B&gt; Clone for <a class="struct" href="../../std/iter/struct.Zip.html" title="std::iter::Zip">Zip</a>&lt;A,&nbsp;B&gt; <span class="where">where A: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, B: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;I,&nbsp;F&gt; Clone for <a class="struct" href="../../std/iter/struct.Map.html" title="std::iter::Map">Map</a>&lt;I,&nbsp;F&gt; <span class="where">where F: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, I: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;I,&nbsp;P&gt; Clone for <a class="struct" href="../../std/iter/struct.Filter.html" title="std::iter::Filter">Filter</a>&lt;I,&nbsp;P&gt; <span class="where">where I: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, P: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;I,&nbsp;F&gt; Clone for <a class="struct" href="../../std/iter/struct.FilterMap.html" title="std::iter::FilterMap">FilterMap</a>&lt;I,&nbsp;F&gt; <span class="where">where F: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, I: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;I&gt; Clone for <a class="struct" href="../../std/iter/struct.Enumerate.html" title="std::iter::Enumerate">Enumerate</a>&lt;I&gt; <span class="where">where I: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;I&gt; Clone for <a class="struct" href="../../std/iter/struct.Peekable.html" title="std::iter::Peekable">Peekable</a>&lt;I&gt; <span class="where">where I: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a> + <a class="trait" href="../../std/iter/trait.Iterator.html" title="std::iter::Iterator">Iterator</a>, I::<a class="trait" href="../../std/iter/trait.Iterator.html" title="std::iter::Iterator">Item</a>: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;I,&nbsp;P&gt; Clone for <a class="struct" href="../../std/iter/struct.SkipWhile.html" title="std::iter::SkipWhile">SkipWhile</a>&lt;I,&nbsp;P&gt; <span class="where">where I: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, P: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;I,&nbsp;P&gt; Clone for <a class="struct" href="../../std/iter/struct.TakeWhile.html" title="std::iter::TakeWhile">TakeWhile</a>&lt;I,&nbsp;P&gt; <span class="where">where I: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, P: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;I&gt; Clone for <a class="struct" href="../../std/iter/struct.Skip.html" title="std::iter::Skip">Skip</a>&lt;I&gt; <span class="where">where I: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;I&gt; Clone for <a class="struct" href="../../std/iter/struct.Take.html" title="std::iter::Take">Take</a>&lt;I&gt; <span class="where">where I: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;I,&nbsp;St,&nbsp;F&gt; Clone for <a class="struct" href="../../std/iter/struct.Scan.html" title="std::iter::Scan">Scan</a>&lt;I,&nbsp;St,&nbsp;F&gt; <span class="where">where F: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, I: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, St: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;I,&nbsp;U,&nbsp;F&gt; Clone for <a class="struct" href="../../std/iter/struct.FlatMap.html" title="std::iter::FlatMap">FlatMap</a>&lt;I,&nbsp;U,&nbsp;F&gt; <span class="where">where F: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, I: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, U: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a> + <a class="trait" href="../../std/iter/trait.IntoIterator.html" title="std::iter::IntoIterator">IntoIterator</a>, U::<a class="trait" href="../../std/iter/trait.IntoIterator.html" title="std::iter::IntoIterator">IntoIter</a>: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;I&gt; Clone for <a class="struct" href="../../std/iter/struct.Fuse.html" title="std::iter::Fuse">Fuse</a>&lt;I&gt; <span class="where">where I: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;I,&nbsp;F&gt; Clone for <a class="struct" href="../../std/iter/struct.Inspect.html" title="std::iter::Inspect">Inspect</a>&lt;I,&nbsp;F&gt; <span class="where">where F: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, I: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;A&gt; Clone for <a class="struct" href="../../std/option/struct.Iter.html" title="std::option::Iter">Iter</a>&lt;'a,&nbsp;A&gt;</code></li>
<li><code>impl&lt;A&gt; Clone for <a class="struct" href="../../std/option/struct.IntoIter.html" title="std::option::IntoIter">IntoIter</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/raw/struct.TraitObject.html" title="std::raw::TraitObject">TraitObject</a></code></li>
<li><code>impl&lt;T,&nbsp;E&gt; Clone for <a class="enum" href="../../std/result/enum.Result.html" title="std::result::Result">Result</a>&lt;T,&nbsp;E&gt; <span class="where">where E: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, T: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Clone for <a class="struct" href="../../std/result/struct.Iter.html" title="std::result::Iter">Iter</a>&lt;'a,&nbsp;T&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Clone for <a class="struct" href="../../std/slice/struct.Iter.html" title="std::slice::Iter">Iter</a>&lt;'a,&nbsp;T&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;T,&nbsp;P&gt; Clone for <a class="struct" href="../../std/slice/struct.Split.html" title="std::slice::Split">Split</a>&lt;'a,&nbsp;T,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a> + <a class="trait" href="../../std/ops/trait.FnMut.html" title="std::ops::FnMut">FnMut</a>(&amp;T) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Clone for <a class="struct" href="../../std/slice/struct.Windows.html" title="std::slice::Windows">Windows</a>&lt;'a,&nbsp;T&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Clone for <a class="struct" href="../../std/slice/struct.Chunks.html" title="std::slice::Chunks">Chunks</a>&lt;'a,&nbsp;T&gt;</code></li>
<li><code>impl Clone for <a class="enum" href="../../std/str/pattern/enum.SearchStep.html" title="std::str::pattern::SearchStep">SearchStep</a></code></li>
<li><code>impl&lt;'a&gt; Clone for <a class="struct" href="../../std/str/pattern/struct.CharSearcher.html" title="std::str::pattern::CharSearcher">CharSearcher</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;'b&gt; Clone for <a class="struct" href="../../std/str/pattern/struct.CharSliceSearcher.html" title="std::str::pattern::CharSliceSearcher">CharSliceSearcher</a>&lt;'a,&nbsp;'b&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;F&gt; Clone for <a class="struct" href="../../std/str/pattern/struct.CharPredicateSearcher.html" title="std::str::pattern::CharPredicateSearcher">CharPredicateSearcher</a>&lt;'a,&nbsp;F&gt; <span class="where">where F: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a> + <a class="trait" href="../../std/ops/trait.FnMut.html" title="std::ops::FnMut">FnMut</a>(<a class="primitive" href="../primitive.char.html">char</a>) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;'b&gt; Clone for <a class="struct" href="../../std/str/pattern/struct.StrSearcher.html" title="std::str::pattern::StrSearcher">StrSearcher</a>&lt;'a,&nbsp;'b&gt;</code></li>
<li><code>impl Clone for <a class="struct" href="../../std/str/struct.ParseBoolError.html" title="std::str::ParseBoolError">ParseBoolError</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/str/struct.Utf8Error.html" title="std::str::Utf8Error">Utf8Error</a></code></li>
<li><code>impl&lt;'a&gt; Clone for <a class="struct" href="../../std/str/struct.Chars.html" title="std::str::Chars">Chars</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; Clone for <a class="struct" href="../../std/str/struct.CharIndices.html" title="std::str::CharIndices">CharIndices</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; Clone for <a class="struct" href="../../std/str/struct.Bytes.html" title="std::str::Bytes">Bytes</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;P&gt; Clone for <a class="struct" href="../../std/str/struct.Split.html" title="std::str::Split">Split</a>&lt;'a,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;P&gt; Clone for <a class="struct" href="../../std/str/struct.RSplit.html" title="std::str::RSplit">RSplit</a>&lt;'a,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;P&gt; Clone for <a class="struct" href="../../std/str/struct.SplitTerminator.html" title="std::str::SplitTerminator">SplitTerminator</a>&lt;'a,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;P&gt; Clone for <a class="struct" href="../../std/str/struct.RSplitTerminator.html" title="std::str::RSplitTerminator">RSplitTerminator</a>&lt;'a,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;P&gt; Clone for <a class="struct" href="../../std/str/struct.SplitN.html" title="std::str::SplitN">SplitN</a>&lt;'a,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;P&gt; Clone for <a class="struct" href="../../std/str/struct.RSplitN.html" title="std::str::RSplitN">RSplitN</a>&lt;'a,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;P&gt; Clone for <a class="struct" href="../../std/str/struct.MatchIndices.html" title="std::str::MatchIndices">MatchIndices</a>&lt;'a,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;P&gt; Clone for <a class="struct" href="../../std/str/struct.RMatchIndices.html" title="std::str::RMatchIndices">RMatchIndices</a>&lt;'a,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;P&gt; Clone for <a class="struct" href="../../std/str/struct.Matches.html" title="std::str::Matches">Matches</a>&lt;'a,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;P&gt; Clone for <a class="struct" href="../../std/str/struct.RMatches.html" title="std::str::RMatches">RMatches</a>&lt;'a,&nbsp;P&gt; <span class="where">where P: <a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Pattern</a>&lt;'a&gt;, P::<a class="trait" href="../../std/str/pattern/trait.Pattern.html" title="std::str::pattern::Pattern">Searcher</a>: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;'a&gt; Clone for <a class="struct" href="../../std/str/struct.Lines.html" title="std::str::Lines">Lines</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; Clone for <a class="struct" href="../../std/str/struct.LinesAny.html" title="std::str::LinesAny">LinesAny</a>&lt;'a&gt;</code></li>
<li><code>impl Clone for <a class="struct" href="../../std/hash/struct.SipHasher13.html" title="std::hash::SipHasher13">SipHasher13</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/hash/struct.SipHasher24.html" title="std::hash::SipHasher24">SipHasher24</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/hash/struct.SipHasher.html" title="std::hash::SipHasher">SipHasher</a></code></li>
<li><code>impl&lt;H&gt; Clone for <a class="struct" href="../../std/hash/struct.BuildHasherDefault.html" title="std::hash::BuildHasherDefault">BuildHasherDefault</a>&lt;H&gt;</code></li>
<li><code>impl Clone for <a class="struct" href="../../std/fmt/struct.Error.html" title="std::fmt::Error">Error</a></code></li>
<li><code>impl&lt;'a&gt; Clone for <a class="struct" href="../../std/fmt/struct.Arguments.html" title="std::fmt::Arguments">Arguments</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;A&gt; Clone for <a class="primitive" href="../primitive.tuple.html">(</a>A,<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B&gt; Clone for <a class="primitive" href="../primitive.tuple.html">(</a>A, B<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, B: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C&gt; Clone for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, B: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, C: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D&gt; Clone for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, B: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, C: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, D: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E&gt; Clone for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, B: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, C: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, D: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, E: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F&gt; Clone for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, B: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, C: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, D: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, E: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, F: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G&gt; Clone for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, B: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, C: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, D: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, E: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, F: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, G: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H&gt; Clone for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, B: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, C: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, D: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, E: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, F: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, G: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, H: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I&gt; Clone for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, B: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, C: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, D: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, E: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, F: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, G: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, H: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, I: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J&gt; Clone for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, B: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, C: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, D: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, E: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, F: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, G: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, H: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, I: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, J: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K&gt; Clone for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J, K<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, B: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, C: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, D: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, E: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, F: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, G: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, H: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, I: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, J: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, K: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K,&nbsp;L&gt; Clone for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J, K, L<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, B: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, C: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, D: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, E: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, F: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, G: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, H: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, I: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, J: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, K: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, L: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/boxed/struct.ExchangeHeapSingleton.html" title="std::boxed::ExchangeHeapSingleton">ExchangeHeapSingleton</a></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/boxed/struct.Box.html" title="std::boxed::Box">Box</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/boxed/struct.Box.html" title="std::boxed::Box">Box</a>&lt;<a class="primitive" href="../primitive.str.html">str</a>&gt;</code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/boxed/struct.Box.html" title="std::boxed::Box">Box</a>&lt;<a class="primitive" href="../primitive.slice.html">[</a>T<a class="primitive" href="../primitive.slice.html">]</a>&gt; <span class="where">where T: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/sync/struct.Arc.html" title="std::sync::Arc">Arc</a>&lt;T&gt; <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/sync/struct.Weak.html" title="std::sync::Weak">Weak</a>&lt;T&gt; <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/rc/struct.Rc.html" title="std::rc::Rc">Rc</a>&lt;T&gt; <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/rc/struct.Weak.html" title="std::rc::Weak">Weak</a>&lt;T&gt; <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/collections/binary_heap/struct.BinaryHeap.html" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Clone for <a class="struct" href="../../std/collections/binary_heap/struct.Iter.html" title="std::collections::binary_heap::Iter">Iter</a>&lt;'a,&nbsp;T&gt;</code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/collections/binary_heap/struct.IntoIter.html" title="std::collections::binary_heap::IntoIter">IntoIter</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;K,&nbsp;V&gt; Clone for <a class="struct" href="../../std/collections/btree_map/struct.BTreeMap.html" title="std::collections::btree_map::BTreeMap">BTreeMap</a>&lt;K,&nbsp;V&gt; <span class="where">where K: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>, V: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;K,&nbsp;V&gt; Clone for <a class="struct" href="../../std/collections/btree_map/struct.Iter.html" title="std::collections::btree_map::Iter">Iter</a>&lt;'a,&nbsp;K,&nbsp;V&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;K,&nbsp;V&gt; Clone for <a class="struct" href="../../std/collections/btree_map/struct.Keys.html" title="std::collections::btree_map::Keys">Keys</a>&lt;'a,&nbsp;K,&nbsp;V&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;K,&nbsp;V&gt; Clone for <a class="struct" href="../../std/collections/btree_map/struct.Values.html" title="std::collections::btree_map::Values">Values</a>&lt;'a,&nbsp;K,&nbsp;V&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;K,&nbsp;V&gt; Clone for <a class="struct" href="../../std/collections/btree_map/struct.Range.html" title="std::collections::btree_map::Range">Range</a>&lt;'a,&nbsp;K,&nbsp;V&gt;</code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/collections/btree_set/struct.BTreeSet.html" title="std::collections::btree_set::BTreeSet">BTreeSet</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Clone for <a class="struct" href="../../std/collections/btree_set/struct.Iter.html" title="std::collections::btree_set::Iter">Iter</a>&lt;'a,&nbsp;T&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Clone for <a class="struct" href="../../std/collections/btree_set/struct.Range.html" title="std::collections::btree_set::Range">Range</a>&lt;'a,&nbsp;T&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Clone for <a class="struct" href="../../std/collections/btree_set/struct.Difference.html" title="std::collections::btree_set::Difference">Difference</a>&lt;'a,&nbsp;T&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Clone for <a class="struct" href="../../std/collections/btree_set/struct.SymmetricDifference.html" title="std::collections::btree_set::SymmetricDifference">SymmetricDifference</a>&lt;'a,&nbsp;T&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Clone for <a class="struct" href="../../std/collections/btree_set/struct.Intersection.html" title="std::collections::btree_set::Intersection">Intersection</a>&lt;'a,&nbsp;T&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Clone for <a class="struct" href="../../std/collections/btree_set/struct.Union.html" title="std::collections::btree_set::Union">Union</a>&lt;'a,&nbsp;T&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;B&gt; Clone for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a,&nbsp;B&gt; <span class="where">where B: <a class="trait" href="../../std/borrow/trait.ToOwned.html" title="std::borrow::ToOwned">ToOwned</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl&lt;E&gt; Clone for <a class="struct" href="../../collections/enum_set/struct.EnumSet.html" title="collections::enum_set::EnumSet">EnumSet</a>&lt;E&gt;</code></li>
<li><code>impl&lt;E&gt; Clone for <a class="struct" href="../../collections/enum_set/struct.Iter.html" title="collections::enum_set::Iter">Iter</a>&lt;E&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Clone for <a class="struct" href="../../std/collections/linked_list/struct.Iter.html" title="std::collections::linked_list::Iter">Iter</a>&lt;'a,&nbsp;T&gt;</code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/collections/linked_list/struct.IntoIter.html" title="std::collections::linked_list::IntoIter">IntoIter</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;A&gt; Clone for <a class="struct" href="../../std/collections/linked_list/struct.LinkedList.html" title="std::collections::linked_list::LinkedList">LinkedList</a>&lt;A&gt; <span class="where">where A: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;'a&gt; Clone for <a class="struct" href="../../std/str/struct.EncodeUtf16.html" title="std::str::EncodeUtf16">EncodeUtf16</a>&lt;'a&gt;</code></li>
<li><code>impl Clone for <a class="struct" href="../../std/string/struct.String.html" title="std::string::String">String</a></code></li>
<li><code>impl Clone for <a class="enum" href="../../std/string/enum.ParseError.html" title="std::string::ParseError">ParseError</a></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/vec/struct.IntoIter.html" title="std::vec::IntoIter">IntoIter</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/collections/vec_deque/struct.VecDeque.html" title="std::collections::vec_deque::VecDeque">VecDeque</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Clone for <a class="struct" href="../../std/collections/vec_deque/struct.Iter.html" title="std::collections::vec_deque::Iter">Iter</a>&lt;'a,&nbsp;T&gt;</code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/collections/vec_deque/struct.IntoIter.html" title="std::collections::vec_deque::IntoIter">IntoIter</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;T&gt; Clone for <a class="enum" href="../../std/collections/enum.Bound.html" title="std::collections::Bound">Bound</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;I&gt; Clone for <a class="struct" href="../../rustc_unicode/u_str/struct.Utf16Encoder.html" title="rustc_unicode::u_str::Utf16Encoder">Utf16Encoder</a>&lt;I&gt; <span class="where">where I: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a></span></code></li>
<li><code>impl&lt;I&gt; Clone for <a class="struct" href="../../std/char/struct.DecodeUtf16.html" title="std::char::DecodeUtf16">DecodeUtf16</a>&lt;I&gt; <span class="where">where I: <a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a> + <a class="trait" href="../../std/iter/trait.Iterator.html" title="std::iter::Iterator">Iterator</a>&lt;Item=<a class="primitive" href="../primitive.u16.html">u16</a>&gt;</span></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/char/struct.DecodeUtf16Error.html" title="std::char::DecodeUtf16Error">DecodeUtf16Error</a></code></li>
<li><code>impl Clone for <a class="enum" href="../../std/thread/enum.LocalKeyState.html" title="std::thread::LocalKeyState">LocalKeyState</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/thread/struct.Thread.html" title="std::thread::Thread">Thread</a></code></li>
<li><code>impl&lt;K:&nbsp;<a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>,&nbsp;V:&nbsp;<a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>,&nbsp;S:&nbsp;<a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>&gt; Clone for <a class="struct" href="../../std/collections/struct.HashMap.html" title="std::collections::HashMap">HashMap</a>&lt;K,&nbsp;V,&nbsp;S&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;K,&nbsp;V&gt; Clone for <a class="struct" href="../../std/collections/hash_map/struct.Iter.html" title="std::collections::hash_map::Iter">Iter</a>&lt;'a,&nbsp;K,&nbsp;V&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;K,&nbsp;V&gt; Clone for <a class="struct" href="../../std/collections/hash_map/struct.Keys.html" title="std::collections::hash_map::Keys">Keys</a>&lt;'a,&nbsp;K,&nbsp;V&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;K,&nbsp;V&gt; Clone for <a class="struct" href="../../std/collections/hash_map/struct.Values.html" title="std::collections::hash_map::Values">Values</a>&lt;'a,&nbsp;K,&nbsp;V&gt;</code></li>
<li><code>impl Clone for <a class="struct" href="../../std/collections/hash_map/struct.RandomState.html" title="std::collections::hash_map::RandomState">RandomState</a></code></li>
<li><code>impl&lt;T:&nbsp;<a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>,&nbsp;S:&nbsp;<a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>&gt; Clone for <a class="struct" href="../../std/collections/struct.HashSet.html" title="std::collections::HashSet">HashSet</a>&lt;T,&nbsp;S&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;K&gt; Clone for <a class="struct" href="../../std/collections/hash_set/struct.Iter.html" title="std::collections::hash_set::Iter">Iter</a>&lt;'a,&nbsp;K&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;T,&nbsp;S&gt; Clone for <a class="struct" href="../../std/collections/hash_set/struct.Intersection.html" title="std::collections::hash_set::Intersection">Intersection</a>&lt;'a,&nbsp;T,&nbsp;S&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;T,&nbsp;S&gt; Clone for <a class="struct" href="../../std/collections/hash_set/struct.Difference.html" title="std::collections::hash_set::Difference">Difference</a>&lt;'a,&nbsp;T,&nbsp;S&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;T,&nbsp;S&gt; Clone for <a class="struct" href="../../std/collections/hash_set/struct.SymmetricDifference.html" title="std::collections::hash_set::SymmetricDifference">SymmetricDifference</a>&lt;'a,&nbsp;T,&nbsp;S&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;T,&nbsp;S&gt; Clone for <a class="struct" href="../../std/collections/hash_set/struct.Union.html" title="std::collections::hash_set::Union">Union</a>&lt;'a,&nbsp;T,&nbsp;S&gt;</code></li>
<li><code>impl Clone for <a class="enum" href="../../std/env/enum.VarError.html" title="std::env::VarError">VarError</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/ffi/struct.CString.html" title="std::ffi::CString">CString</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/ffi/struct.NulError.html" title="std::ffi::NulError">NulError</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/ffi/struct.FromBytesWithNulError.html" title="std::ffi::FromBytesWithNulError">FromBytesWithNulError</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/ffi/struct.IntoStringError.html" title="std::ffi::IntoStringError">IntoStringError</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/fs/struct.Metadata.html" title="std::fs::Metadata">Metadata</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/fs/struct.OpenOptions.html" title="std::fs::OpenOptions">OpenOptions</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/fs/struct.Permissions.html" title="std::fs::Permissions">Permissions</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/fs/struct.FileType.html" title="std::fs::FileType">FileType</a></code></li>
<li><code>impl&lt;T:&nbsp;<a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>&gt; Clone for <a class="struct" href="../../std/io/struct.Cursor.html" title="std::io::Cursor">Cursor</a>&lt;T&gt;</code></li>
<li><code>impl Clone for <a class="enum" href="../../std/io/enum.ErrorKind.html" title="std::io::ErrorKind">ErrorKind</a></code></li>
<li><code>impl Clone for <a class="enum" href="../../std/io/enum.SeekFrom.html" title="std::io::SeekFrom">SeekFrom</a></code></li>
<li><code>impl Clone for <a class="enum" href="../../std/net/enum.IpAddr.html" title="std::net::IpAddr">IpAddr</a></code></li>
<li><code>impl Clone for <a class="enum" href="../../std/net/enum.Ipv6MulticastScope.html" title="std::net::Ipv6MulticastScope">Ipv6MulticastScope</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/net/struct.Ipv4Addr.html" title="std::net::Ipv4Addr">Ipv4Addr</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/net/struct.Ipv6Addr.html" title="std::net::Ipv6Addr">Ipv6Addr</a></code></li>
<li><code>impl Clone for <a class="enum" href="../../std/net/enum.SocketAddr.html" title="std::net::SocketAddr">SocketAddr</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/net/struct.SocketAddrV4.html" title="std::net::SocketAddrV4">SocketAddrV4</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/net/struct.SocketAddrV6.html" title="std::net::SocketAddrV6">SocketAddrV6</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/net/struct.AddrParseError.html" title="std::net::AddrParseError">AddrParseError</a></code></li>
<li><code>impl Clone for <a class="enum" href="../../std/net/enum.Shutdown.html" title="std::net::Shutdown">Shutdown</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/os/unix/net/struct.SocketAddr.html" title="std::os::unix::net::SocketAddr">SocketAddr</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/os/linux/raw/struct.stat.html" title="std::os::linux::raw::stat">stat</a></code></li>
<li><code>impl&lt;'a&gt; Clone for <a class="enum" href="../../std/path/enum.Prefix.html" title="std::path::Prefix">Prefix</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; Clone for <a class="struct" href="../../std/path/struct.PrefixComponent.html" title="std::path::PrefixComponent">PrefixComponent</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; Clone for <a class="enum" href="../../std/path/enum.Component.html" title="std::path::Component">Component</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; Clone for <a class="struct" href="../../std/path/struct.Components.html" title="std::path::Components">Components</a>&lt;'a&gt;</code></li>
<li><code>impl&lt;'a&gt; Clone for <a class="struct" href="../../std/path/struct.Iter.html" title="std::path::Iter">Iter</a>&lt;'a&gt;</code></li>
<li><code>impl Clone for <a class="struct" href="../../std/path/struct.PathBuf.html" title="std::path::PathBuf">PathBuf</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/path/struct.StripPrefixError.html" title="std::path::StripPrefixError">StripPrefixError</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/process/struct.Output.html" title="std::process::Output">Output</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/process/struct.ExitStatus.html" title="std::process::ExitStatus">ExitStatus</a></code></li>
<li><code>impl&lt;T:&nbsp;<a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>&gt; Clone for <a class="struct" href="../../std/sync/mpsc/struct.SendError.html" title="std::sync::mpsc::SendError">SendError</a>&lt;T&gt;</code></li>
<li><code>impl Clone for <a class="struct" href="../../std/sync/mpsc/struct.RecvError.html" title="std::sync::mpsc::RecvError">RecvError</a></code></li>
<li><code>impl Clone for <a class="enum" href="../../std/sync/mpsc/enum.TryRecvError.html" title="std::sync::mpsc::TryRecvError">TryRecvError</a></code></li>
<li><code>impl Clone for <a class="enum" href="../../std/sync/mpsc/enum.RecvTimeoutError.html" title="std::sync::mpsc::RecvTimeoutError">RecvTimeoutError</a></code></li>
<li><code>impl&lt;T:&nbsp;<a class="trait" href="../../std/clone/trait.Clone.html" title="std::clone::Clone">Clone</a>&gt; Clone for <a class="enum" href="../../std/sync/mpsc/enum.TrySendError.html" title="std::sync::mpsc::TrySendError">TrySendError</a>&lt;T&gt;</code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/sync/mpsc/struct.Sender.html" title="std::sync::mpsc::Sender">Sender</a>&lt;T&gt;</code></li>
<li><code>impl&lt;T&gt; Clone for <a class="struct" href="../../std/sync/mpsc/struct.SyncSender.html" title="std::sync::mpsc::SyncSender">SyncSender</a>&lt;T&gt;</code></li>
<li><code>impl Clone for <a class="struct" href="../../std/sync/struct.WaitTimeoutResult.html" title="std::sync::WaitTimeoutResult">WaitTimeoutResult</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/time/struct.Duration.html" title="std::time::Duration">Duration</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/time/struct.Instant.html" title="std::time::Instant">Instant</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/time/struct.SystemTime.html" title="std::time::SystemTime">SystemTime</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../std/time/struct.SystemTimeError.html" title="std::time::SystemTimeError">SystemTimeError</a></code></li>
<li><code>impl Clone for <a class="struct" href="https://doc.rust-lang.org/nightly/rand/distributions/normal/struct.StandardNormal.html" title="rand::distributions::normal::StandardNormal">StandardNormal</a></code></li>
<li><code>impl Clone for <a class="struct" href="https://doc.rust-lang.org/nightly/rand/distributions/normal/struct.Normal.html" title="rand::distributions::normal::Normal">Normal</a></code></li>
<li><code>impl Clone for <a class="struct" href="https://doc.rust-lang.org/nightly/rand/distributions/normal/struct.LogNormal.html" title="rand::distributions::normal::LogNormal">LogNormal</a></code></li>
<li><code>impl Clone for <a class="struct" href="https://doc.rust-lang.org/nightly/rand/distributions/exponential/struct.Exp1.html" title="rand::distributions::exponential::Exp1">Exp1</a></code></li>
<li><code>impl Clone for <a class="struct" href="https://doc.rust-lang.org/nightly/rand/distributions/exponential/struct.Exp.html" title="rand::distributions::exponential::Exp">Exp</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../rand/isaac/struct.IsaacRng.html" title="rand::isaac::IsaacRng">IsaacRng</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../rand/isaac/struct.Isaac64Rng.html" title="rand::isaac::Isaac64Rng">Isaac64Rng</a></code></li>
<li><code>impl Clone for <a class="struct" href="https://doc.rust-lang.org/nightly/rand/chacha/struct.ChaChaRng.html" title="rand::chacha::ChaChaRng">ChaChaRng</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../rand/reseeding/struct.ReseedWithDefault.html" title="rand::reseeding::ReseedWithDefault">ReseedWithDefault</a></code></li>
<li><code>impl Clone for <a class="struct" href="../../rand/struct.XorShiftRng.html" title="rand::XorShiftRng">XorShiftRng</a></code></li>
</ul><script src="../../implementors/core/clone/trait.Clone.js" async="" type="text/javascript">
                 </script></div></div><div class="outerdoc" id="trait.Default"><div class="docblock" id="trait.Default">
<h1 class="fqn"><span class="in-band">Trait <a href="../">std</a>::<wbr><a href="index.html">default</a>::<wbr><a class="trait" href="">Default</a></span><span class="out-of-band"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><span id="render-detail">
                   <a href="javascript:void(0)" id="toggle-all-docs" title="collapse all docs">
                       [<span class="inner"></span>]
                   </a>
               </span><a class="srclink" href="../../core/default/trait.Default.html?gotosrc=23184" id="src-23184" title="goto source code">[src]</a></span></h1>
<pre class="rust trait">pub trait Default {
    fn <a class="fnname" href="#tymethod.default">default</a>() -&gt; Self;
}</pre><div class="docblock"><p>A trait for giving a type a useful default value.</p>

<p>Sometimes, you want to fall back to some kind of default value, and
don't particularly care what it is. This comes up often with <code>struct</code>s
that define a set of options:</p>

<span class="rusttest">fn main() {
    #[allow(dead_code)]
struct SomeOptions {
    foo: i32,
    bar: f32,
}
}</span><pre class="rust rust-example-rendered"><span class="kw">struct</span> <span class="ident">SomeOptions</span> {
    <span class="ident">foo</span>: <span class="ident">i32</span>,
    <span class="ident">bar</span>: <span class="ident">f32</span>,
}</pre>

<p>How can we define some default values? You can use <code>Default</code>:</p>

<span class="rusttest">#[allow(dead_code)]
#[derive(Default)]
struct SomeOptions {
    foo: i32,
    bar: f32,
}


fn main() {
    let options: SomeOptions = Default::default();
}
</span><pre class="rust rust-example-rendered"><span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Default</span>)]</span>
<span class="kw">struct</span> <span class="ident">SomeOptions</span> {
    <span class="ident">foo</span>: <span class="ident">i32</span>,
    <span class="ident">bar</span>: <span class="ident">f32</span>,
}


<span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">options</span>: <span class="ident">SomeOptions</span> <span class="op">=</span> <span class="ident">Default</span>::<span class="ident">default</span>();
}</pre>

<p>Now, you get all of the default values. Rust implements <code>Default</code> for various primitives types.</p>

<p>If you want to override a particular option, but still retain the other defaults:</p>

<span class="rusttest">#[allow(dead_code)]
#[derive(Default)]
struct SomeOptions {
    foo: i32,
    bar: f32,
}
fn main() {
    let options = SomeOptions { foo: 42, ..Default::default() };
}
</span><pre class="rust rust-example-rendered"><span class="kw">fn</span> <span class="ident">main</span>() {
    <span class="kw">let</span> <span class="ident">options</span> <span class="op">=</span> <span class="ident">SomeOptions</span> { <span class="ident">foo</span>: <span class="number">42</span>, ..<span class="ident">Default</span>::<span class="ident">default</span>() };
}</pre>

<h2 class="section-header" id="derivable"><a href="#derivable">Derivable</a></h2>
<p>This trait can be used with <code>#[derive]</code> if all of the type's fields implement
<code>Default</code>. When <code>derive</code>d, it will use the default value for each field's type.</p>

<h2 class="section-header" id="how-can-i-implement-default"><a href="#how-can-i-implement-default">How can I implement <code>Default</code>?</a></h2>
<p>Provide an implementation for the <code>default()</code> method that returns the value of
your type that should be the default:</p>

<span class="rusttest">fn main() {
    #![allow(dead_code)]
enum Kind {
    A,
    B,
    C,
}

impl Default for Kind {
    fn default() -&gt; Kind { Kind::A }
}
}</span><pre class="rust rust-example-rendered"><span class="kw">enum</span> <span class="ident">Kind</span> {
    <span class="ident">A</span>,
    <span class="ident">B</span>,
    <span class="ident">C</span>,
}

<span class="kw">impl</span> <span class="ident">Default</span> <span class="kw">for</span> <span class="ident">Kind</span> {
    <span class="kw">fn</span> <span class="ident">default</span>() <span class="op">-&gt;</span> <span class="ident">Kind</span> { <span class="ident">Kind</span>::<span class="ident">A</span> }
}</pre>

<h1 class="section-header" id="examples"><a href="#examples">Examples</a></h1>
<span class="rusttest">fn main() {
    #[allow(dead_code)]
#[derive(Default)]
struct SomeOptions {
    foo: i32,
    bar: f32,
}
}</span><pre class="rust rust-example-rendered"><span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Default</span>)]</span>
<span class="kw">struct</span> <span class="ident">SomeOptions</span> {
    <span class="ident">foo</span>: <span class="ident">i32</span>,
    <span class="ident">bar</span>: <span class="ident">f32</span>,
}</pre>
</div>
            <h2 id="required-methods">Required Methods</h2>
            <div class="methods">
        <h3 class="method stab " id="tymethod.default"><code>fn <a class="fnname" href="#tymethod.default">default</a>() -&gt; Self</code></h3><div class="docblock"><p>Returns the "default value" for a type.</p>

<p>Default values are often some kind of initial value, identity value, or anything else that
may make sense as a default.</p>

<h1 class="section-header" id="examples-1"><a href="#examples-1">Examples</a></h1>
<p>Using built-in default values:</p>

<span class="rusttest">fn main() {
    let i: i8 = Default::default();
let (x, y): (Option&lt;String&gt;, f64) = Default::default();
let (a, b, (c, d)): (i32, u32, (bool, bool)) = Default::default();
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">i</span>: <span class="ident">i8</span> <span class="op">=</span> <span class="ident">Default</span>::<span class="ident">default</span>();
<span class="kw">let</span> (<span class="ident">x</span>, <span class="ident">y</span>): (<span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>, <span class="ident">f64</span>) <span class="op">=</span> <span class="ident">Default</span>::<span class="ident">default</span>();
<span class="kw">let</span> (<span class="ident">a</span>, <span class="ident">b</span>, (<span class="ident">c</span>, <span class="ident">d</span>)): (<span class="ident">i32</span>, <span class="ident">u32</span>, (<span class="ident">bool</span>, <span class="ident">bool</span>)) <span class="op">=</span> <span class="ident">Default</span>::<span class="ident">default</span>();</pre>

<p>Making your own:</p>

<span class="rusttest">fn main() {
    #[allow(dead_code)]
enum Kind {
    A,
    B,
    C,
}

impl Default for Kind {
    fn default() -&gt; Kind { Kind::A }
}
}</span><pre class="rust rust-example-rendered"><span class="kw">enum</span> <span class="ident">Kind</span> {
    <span class="ident">A</span>,
    <span class="ident">B</span>,
    <span class="ident">C</span>,
}

<span class="kw">impl</span> <span class="ident">Default</span> <span class="kw">for</span> <span class="ident">Kind</span> {
    <span class="kw">fn</span> <span class="ident">default</span>() <span class="op">-&gt;</span> <span class="ident">Kind</span> { <span class="ident">Kind</span>::<span class="ident">A</span> }
}</pre>
</div></div>
        <h2 id="implementors">Implementors</h2>
        <ul class="item-list" id="implementors-list">
    <li><code>impl&lt;T&gt; Default for <a class="struct" href="../../std/num/struct.Wrapping.html" title="std::num::Wrapping">Wrapping</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="struct" href="../../std/marker/struct.PhantomData.html" title="std::marker::PhantomData">PhantomData</a>&lt;T&gt; <span class="where">where T: ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a></span></code></li>
<li><code>impl Default for <a class="primitive" href="../primitive.tuple.html">()</a></code></li>
<li><code>impl Default for <a class="primitive" href="../primitive.bool.html">bool</a></code></li>
<li><code>impl Default for <a class="primitive" href="../primitive.char.html">char</a></code></li>
<li><code>impl Default for <a class="primitive" href="../primitive.usize.html">usize</a></code></li>
<li><code>impl Default for <a class="primitive" href="../primitive.u8.html">u8</a></code></li>
<li><code>impl Default for <a class="primitive" href="../primitive.u16.html">u16</a></code></li>
<li><code>impl Default for <a class="primitive" href="../primitive.u32.html">u32</a></code></li>
<li><code>impl Default for <a class="primitive" href="../primitive.u64.html">u64</a></code></li>
<li><code>impl Default for <a class="primitive" href="../primitive.isize.html">isize</a></code></li>
<li><code>impl Default for <a class="primitive" href="../primitive.i8.html">i8</a></code></li>
<li><code>impl Default for <a class="primitive" href="../primitive.i16.html">i16</a></code></li>
<li><code>impl Default for <a class="primitive" href="../primitive.i32.html">i32</a></code></li>
<li><code>impl Default for <a class="primitive" href="../primitive.i64.html">i64</a></code></li>
<li><code>impl Default for <a class="primitive" href="../primitive.f32.html">f32</a></code></li>
<li><code>impl Default for <a class="primitive" href="../primitive.f64.html">f64</a></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 32]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 31]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 30]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 29]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 28]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 27]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 26]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 25]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 24]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 23]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 22]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 21]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 20]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 19]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 18]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 17]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 16]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 15]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 14]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 13]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 12]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 11]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 10]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 9]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 8]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 7]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 6]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 5]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 4]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 3]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 2]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 1]</a> <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="primitive" href="../primitive.array.html">[</a>T<a class="primitive" href="../primitive.array.html">; 0]</a></code></li>
<li><code>impl Default for <a class="struct" href="../../std/sync/atomic/struct.AtomicBool.html" title="std::sync::atomic::AtomicBool">AtomicBool</a></code></li>
<li><code>impl&lt;T&gt; Default for <a class="struct" href="../../std/sync/atomic/struct.AtomicPtr.html" title="std::sync::atomic::AtomicPtr">AtomicPtr</a>&lt;T&gt;</code></li>
<li><code>impl Default for <a class="struct" href="../../std/sync/atomic/struct.AtomicI8.html" title="std::sync::atomic::AtomicI8">AtomicI8</a></code></li>
<li><code>impl Default for <a class="struct" href="../../std/sync/atomic/struct.AtomicU8.html" title="std::sync::atomic::AtomicU8">AtomicU8</a></code></li>
<li><code>impl Default for <a class="struct" href="../../std/sync/atomic/struct.AtomicI16.html" title="std::sync::atomic::AtomicI16">AtomicI16</a></code></li>
<li><code>impl Default for <a class="struct" href="../../std/sync/atomic/struct.AtomicU16.html" title="std::sync::atomic::AtomicU16">AtomicU16</a></code></li>
<li><code>impl Default for <a class="struct" href="../../std/sync/atomic/struct.AtomicI32.html" title="std::sync::atomic::AtomicI32">AtomicI32</a></code></li>
<li><code>impl Default for <a class="struct" href="../../std/sync/atomic/struct.AtomicU32.html" title="std::sync::atomic::AtomicU32">AtomicU32</a></code></li>
<li><code>impl Default for <a class="struct" href="../../std/sync/atomic/struct.AtomicI64.html" title="std::sync::atomic::AtomicI64">AtomicI64</a></code></li>
<li><code>impl Default for <a class="struct" href="../../std/sync/atomic/struct.AtomicU64.html" title="std::sync::atomic::AtomicU64">AtomicU64</a></code></li>
<li><code>impl Default for <a class="struct" href="../../std/sync/atomic/struct.AtomicIsize.html" title="std::sync::atomic::AtomicIsize">AtomicIsize</a></code></li>
<li><code>impl Default for <a class="struct" href="../../std/sync/atomic/struct.AtomicUsize.html" title="std::sync::atomic::AtomicUsize">AtomicUsize</a></code></li>
<li><code>impl&lt;T&gt; Default for <a class="struct" href="../../std/cell/struct.Cell.html" title="std::cell::Cell">Cell</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/marker/trait.Copy.html" title="std::marker::Copy">Copy</a> + <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="struct" href="../../std/cell/struct.RefCell.html" title="std::cell::RefCell">RefCell</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="struct" href="../../std/cell/struct.UnsafeCell.html" title="std::cell::UnsafeCell">UnsafeCell</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="struct" href="../../std/iter/struct.Empty.html" title="std::iter::Empty">Empty</a>&lt;T&gt;</code></li>
<li><code>impl&lt;T&gt; Default for <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;T&gt;</code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Default for <a class="primitive" href="../primitive.slice.html">&amp;'a [T]</a></code></li>
<li><code>impl&lt;'a,&nbsp;T&gt; Default for <a class="primitive" href="../primitive.slice.html">&amp;'a mut [T]</a></code></li>
<li><code>impl&lt;'a&gt; Default for &amp;'a <a class="primitive" href="../primitive.str.html">str</a></code></li>
<li><code>impl Default for <a class="struct" href="../../std/hash/struct.SipHasher13.html" title="std::hash::SipHasher13">SipHasher13</a></code></li>
<li><code>impl Default for <a class="struct" href="../../std/hash/struct.SipHasher24.html" title="std::hash::SipHasher24">SipHasher24</a></code></li>
<li><code>impl Default for <a class="struct" href="../../std/hash/struct.SipHasher.html" title="std::hash::SipHasher">SipHasher</a></code></li>
<li><code>impl&lt;H&gt; Default for <a class="struct" href="../../std/hash/struct.BuildHasherDefault.html" title="std::hash::BuildHasherDefault">BuildHasherDefault</a>&lt;H&gt;</code></li>
<li><code>impl Default for <a class="struct" href="../../std/fmt/struct.Error.html" title="std::fmt::Error">Error</a></code></li>
<li><code>impl&lt;A&gt; Default for <a class="primitive" href="../primitive.tuple.html">(</a>A,<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B&gt; Default for <a class="primitive" href="../primitive.tuple.html">(</a>A, B<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, B: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C&gt; Default for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, B: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, C: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D&gt; Default for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, B: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, C: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, D: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E&gt; Default for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, B: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, C: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, D: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, E: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F&gt; Default for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, B: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, C: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, D: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, E: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, F: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G&gt; Default for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, B: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, C: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, D: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, E: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, F: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, G: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H&gt; Default for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, B: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, C: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, D: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, E: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, F: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, G: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, H: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I&gt; Default for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, B: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, C: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, D: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, E: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, F: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, G: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, H: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, I: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J&gt; Default for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, B: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, C: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, D: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, E: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, F: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, G: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, H: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, I: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, J: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K&gt; Default for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J, K<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, B: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, C: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, D: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, E: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, F: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, G: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, H: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, I: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, J: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, K: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;A,&nbsp;B,&nbsp;C,&nbsp;D,&nbsp;E,&nbsp;F,&nbsp;G,&nbsp;H,&nbsp;I,&nbsp;J,&nbsp;K,&nbsp;L&gt; Default for <a class="primitive" href="../primitive.tuple.html">(</a>A, B, C, D, E, F, G, H, I, J, K, L<a class="primitive" href="../primitive.tuple.html">)</a> <span class="where">where A: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, B: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, C: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, D: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, E: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, F: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, G: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, H: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, I: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, J: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, K: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>, L: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="struct" href="../../std/boxed/struct.Box.html" title="std::boxed::Box">Box</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="struct" href="../../std/boxed/struct.Box.html" title="std::boxed::Box">Box</a>&lt;<a class="primitive" href="../primitive.slice.html">[</a>T<a class="primitive" href="../primitive.slice.html">]</a>&gt;</code></li>
<li><code>impl&lt;T&gt; Default for <a class="struct" href="../../std/sync/struct.Weak.html" title="std::sync::Weak">Weak</a>&lt;T&gt;</code></li>
<li><code>impl&lt;T&gt; Default for <a class="struct" href="../../std/sync/struct.Arc.html" title="std::sync::Arc">Arc</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="struct" href="../../std/rc/struct.Rc.html" title="std::rc::Rc">Rc</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="struct" href="../../std/rc/struct.Weak.html" title="std::rc::Weak">Weak</a>&lt;T&gt;</code></li>
<li><code>impl&lt;T&gt; Default for <a class="struct" href="../../std/collections/binary_heap/struct.BinaryHeap.html" title="std::collections::binary_heap::BinaryHeap">BinaryHeap</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;K,&nbsp;V&gt; Default for <a class="struct" href="../../std/collections/btree_map/struct.BTreeMap.html" title="std::collections::btree_map::BTreeMap">BTreeMap</a>&lt;K,&nbsp;V&gt; <span class="where">where K: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="struct" href="../../std/collections/btree_set/struct.BTreeSet.html" title="std::collections::btree_set::BTreeSet">BTreeSet</a>&lt;T&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Ord.html" title="std::cmp::Ord">Ord</a></span></code></li>
<li><code>impl&lt;'a,&nbsp;B&gt; Default for <a class="enum" href="../../std/borrow/enum.Cow.html" title="std::borrow::Cow">Cow</a>&lt;'a,&nbsp;B&gt; <span class="where">where B: <a class="trait" href="../../std/borrow/trait.ToOwned.html" title="std::borrow::ToOwned">ToOwned</a> + ?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a>, B::<a class="trait" href="../../std/borrow/trait.ToOwned.html" title="std::borrow::ToOwned">Owned</a>: <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;T&gt; Default for <a class="struct" href="../../std/collections/linked_list/struct.LinkedList.html" title="std::collections::linked_list::LinkedList">LinkedList</a>&lt;T&gt;</code></li>
<li><code>impl Default for <a class="struct" href="../../std/string/struct.String.html" title="std::string::String">String</a></code></li>
<li><code>impl&lt;T&gt; Default for <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;</code></li>
<li><code>impl&lt;T&gt; Default for <a class="struct" href="../../std/collections/vec_deque/struct.VecDeque.html" title="std::collections::vec_deque::VecDeque">VecDeque</a>&lt;T&gt;</code></li>
<li><code>impl&lt;K,&nbsp;V,&nbsp;S&gt; Default for <a class="struct" href="../../std/collections/struct.HashMap.html" title="std::collections::HashMap">HashMap</a>&lt;K,&nbsp;V,&nbsp;S&gt; <span class="where">where K: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a> + <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, S: <a class="trait" href="../../std/hash/trait.BuildHasher.html" title="std::hash::BuildHasher">BuildHasher</a> + <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl Default for <a class="struct" href="../../std/collections/hash_map/struct.RandomState.html" title="std::collections::hash_map::RandomState">RandomState</a></code></li>
<li><code>impl&lt;T,&nbsp;S&gt; Default for <a class="struct" href="../../std/collections/struct.HashSet.html" title="std::collections::HashSet">HashSet</a>&lt;T,&nbsp;S&gt; <span class="where">where T: <a class="trait" href="../../std/cmp/trait.Eq.html" title="std::cmp::Eq">Eq</a> + <a class="trait" href="../../std/hash/trait.Hash.html" title="std::hash::Hash">Hash</a>, S: <a class="trait" href="../../std/hash/trait.BuildHasher.html" title="std::hash::BuildHasher">BuildHasher</a> + <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a></span></code></li>
<li><code>impl&lt;'a&gt; Default for &amp;'a <a class="struct" href="../../std/ffi/struct.CStr.html" title="std::ffi::CStr">CStr</a></code></li>
<li><code>impl Default for <a class="struct" href="../../std/ffi/struct.CString.html" title="std::ffi::CString">CString</a></code></li>
<li><code>impl Default for <a class="struct" href="../../std/ffi/struct.OsString.html" title="std::ffi::OsString">OsString</a></code></li>
<li><code>impl&lt;'a&gt; Default for &amp;'a <a class="struct" href="../../std/ffi/struct.OsStr.html" title="std::ffi::OsStr">OsStr</a></code></li>
<li><code>impl Default for <a class="struct" href="../../std/sync/struct.Condvar.html" title="std::sync::Condvar">Condvar</a></code></li>
<li><code>impl&lt;T:&nbsp;?<a class="trait" href="../../std/marker/trait.Sized.html" title="std::marker::Sized">Sized</a> + <a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>&gt; Default for <a class="struct" href="../../std/sync/struct.Mutex.html" title="std::sync::Mutex">Mutex</a>&lt;T&gt;</code></li>
<li><code>impl&lt;T:&nbsp;<a class="trait" href="../../std/default/trait.Default.html" title="std::default::Default">Default</a>&gt; Default for <a class="struct" href="../../std/sync/struct.RwLock.html" title="std::sync::RwLock">RwLock</a>&lt;T&gt;</code></li>
<li><code>impl Default for <a class="struct" href="../../rand/reseeding/struct.ReseedWithDefault.html" title="rand::reseeding::ReseedWithDefault">ReseedWithDefault</a></code></li>
</ul><script src="../../implementors/core/default/trait.Default.js" async="" type="text/javascript">
                 </script></div></div>
</div>

<div id="overlay">
    <div id="overlayclose">X</div>
    <div id="overlaycontent"></div>
</div>



<script src="jquery-2.2.3.min.js"></script>
<script src="fuse.min.js"></script>
<script type="text/javascript">
$(document).ready(function() {
    $("a[data-doc]").each(function() {
        var a = $(this);
        a.click(function() {
            var doc_id = a.attr("data-doc").replace('.', '\\.');
            var doc = $('div.outerdoc#' + doc_id);
            var overlay = $("#overlay");
            $("#overlaycontent").html(doc.html());
            overlay.show();
        });

    });

    // $("div.docblock").each(function() {
    //     var docblock = $(this);
    //     $(this).prev().click(function() {
    //         var overlay = $("#overlay");
    //         $("#overlaycontent").html(docblock.html());
    //         overlay.show();

    //     });
    //     $(this).prev().css("cursor", "pointer");
    // });
    $("#overlayclose").click(function() {
        $("#overlay").hide();
    });
    $("#overlay").click(function() {
        $("#overlay").hide();
    });
    $("#overlaycontent").click(function(event) {
        event.stopPropagation();
    });
    $("#overlaycontent").addClass("docblock");

    document.rarelyused_are_hidden = true;

    $(document).keypress(function(event) {
        if (event.key == "Escape") {
            if (!$("#overlay").is(":hidden")) {
                $("#overlay").hide();
            } else if ($("div#search input").val().length != 0) {
                $("div#search input").val("");
                filter("");
            }
        } else if (event.key == "s" || (event.key == "p" && event.ctrlKey)) {
            if ($("div#search input").is(":focus")) {
                return;
            }
            event.preventDefault();
            $("div#search input").val("");
            $("div#search input").focus();
        } else if (event.key == "h" || (event.key == "h" && event.ctrlKey)) {
            if ($("div#search input").is(":focus")) {
                return;
            }
            event.preventDefault();
            if (document.rarelyused_are_hidden) {
                $("section > div.rarelyused").slideDown();
                document.rarelyused_are_hidden = false;
            } else {
                $("section > div.rarelyused").slideUp();
                document.rarelyused_are_hidden = true;
            }

        }
    });


    function prepare() {
        var texts = [];
        $("section.filterable > div").each(function() {
            var line = this;
            texts.push( {"text" : line.innerText,
                         "dom" : line,
                         "tags" : $(line).attr("data-tags"),
                         "visible" : 0 } );
        });
        document.texts = texts;
        return texts;
    }

    function make_fuse(index) {
        var options = {
          caseSensitive: false,
          shouldSort: false,
          tokenize: false,
          threshold: 0.2,
          location: 0,
          distance: 10000,
          maxPatternLength: 32,
          keys: [
            "text",
            "tags"
          ]
        };
        return new Fuse(index, options); // "list" is the item array
    }

    var visible = 0;
    var index = prepare();
    var fuse = make_fuse(index);

    function filter(str) {
        visible++;
        document.rarelyused_are_hidden = false;
        if (str.length == 0) {
            index.forEach(function(f) {
                f.visible = visible;
            });
        } else {
            var result = fuse.search(str);
            document.r = result;
            result.forEach(function(f) {
                f.visible = visible;
            });
        }
        index.forEach(function(f) {
            if (f.visible == visible) {
                $(f.dom).show();
            } else {
                $(f.dom).hide();
            }
        });
    }

    $("div#search input").keyup(function () {
        filter($("div#search input").val());
    });


});

</script>

</body>
</html>