<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">

    <title>Rust Cheatsheet</title>

    <link rel="stylesheet" type="text/css" href="rustdoc.css">
    <link rel="stylesheet" type="text/css" href="main.css">

    <style type="text/css">
    body {
    }

    .hide {
        display: none;
    }
    .clear_right {
        clear: right;
    }

    span.out-of-band {
        display: none;
    }

    section {
        font-family: Arial, Helvetica, Sans;
        font-size: 1em;

        border: 1px solid black;
        //border-collapse: collapse;
        //display: table;
        width: 20%;
        box-shadow: inset 0px 0px 4px #666;
        padding: 0 0 2px 0;
        float: left;
    }

    section header {
        font-family: "Nimbus Sans L";
        font-weight: bold;
        text-align: center;
        border-bottom: 1px solid black;
        padding: 3px;
        font-size: 0.8em;
    }
    section div {
        padding: 0px 8px ;
        clear: right;
    }
    section div:nth-child(even) {
        background-color: rgba(0, 0, 0, 0.01);
    }
    section div code {
        white-space: pre;
        font-size: 0.7em;
        font-family: "Nimbus Sans L";
        font-weight: bold;
        line-height: 0.4em;
    }
    section div span {
        color: #53dafc;
    }
    section div details {
        display: block;
        //line-height: 0.4em;
        float: right;
        padding-top: 0.4em;
        font-size: 0.7em;
        color: #555;
        text-align: right;
    }

    section hr {
        margin: 0px 0px -2px 0px;
        border: 0;
        height: 0;
        border-top: 1px solid rgba(0, 0, 0, 0.3);
        border-bottom: 1px solid rgba(255, 255, 255, 0.3);
        clear: right;

    }

    section p {
        padding: 3px 10px;
        margin: 0;
        font-size: 0.7em;
    }

    section a {
        color: black;
    }

    /* COLORS */
    section.red header {
        background-image: linear-gradient(to right bottom, #E07F7F 0%, #FFAB7A 51%);
    }
    section.red {
        background-color: #f7dcdc;
    }

    section.green header {
        background-image: linear-gradient(to right bottom, #62C958 0%, #BFF2E9 100%);
    }

    section.green {
        background-color: #e3ede1;
    }

    div.unstable code {
        color: #999;
    }

    div.outerdoc {
        display: none;
    }

    div#overlay {
        display: none;
        position: fixed;
        top: 0px;
        bottom: 0px;
        left: 0px;
        right: 0px;
        background-color: rgba(0,0,0,0.5);
    }

    div#overlayclose {
        position: fixed;
        top: 30px;
        left: 50%;
        margin-left: 413px;
        margin-top: 20px;
        font-size: 20px;
        z-index: 20; /* keep on top of other elements on the page */
    }

    div#overlaycontent {
        position: fixed;
        top: 30px;
        left: 50%;
        width: 900px;
        /* line-height: 200px; */
        height: 80%;
        overflow-y: auto;
        margin-left: -450px;
        padding: 20px;
        background-color: #f3f3f3;
        border: 1px solid gray;
        border-radius: 4px;


        /* needed styles for the overlay */
        z-index: 10; /* keep on top of other elements on the page */

    }

    div#overlaycontent {
        display: block !important;
    }

    </style>
</head>

<body>




<section id="vec" class="red">
<header>Variable sized arrays / Vectors</header>
<div><a data-doc="vec.new"><code>let mut vec: Vec&lt;T&gt; = Vec::new();</code></a><details></details></div>
    <div><a data-doc="vec.with_capacity"><code>            = Vec::with_capacity();</code></a><details></details></div>
    <div><a data-doc="vec.initmacro"><code>            = vec![];</code></a><details></details></div>
    <div><a data-doc="vec.elementaccess"><code>vec[3];</code></a><details></details></div>
    <div><a data-doc="vec.len"><code>vec.len()</code></a><details></details></div>
    <div><a data-doc="vec.first"><code>   .first</a><a data-doc="vec.first_mut"><span>_mut</span>() </a><a data-doc="vec.last">.last</a><a data-doc="vec.last_mut"><span>_mut</span>()</code></a><details>-&gt; Option</details></div>
    <div><a data-doc="vec.get"><code>   .get</a><a data-doc="vec.get_mut"><span>_mut</span>()</code></a><details>-&gt; Option</details></div>
    <div><a data-doc="vec.is_empty"><code>   .is_empty();</code></a><details></details></div>
    

<div><code>let mut vec: Vec&lt;T&gt; = Vec::new();</code></div>
<div><code>            = Vec::with_capacity();</code></div>
<div><code>            = vec![];</code></div>
<div><code>vec[3];</code><details></details></div>
<div><code>vec.len()</code><details></details></div>
<div><code>   .first<span>_mut</span>() .last<span>_mut</span>()</code><details>-&gt; Option</details></div>
<div><code>   .get<span>_mut</span>()</code><details>-&gt; Option</details></div>
<div><code>   .is_empty();</code><details></details></div>
<div><code>   .hash(state: Hasher)</code><details>if T:Hash</details></div>
<hr><hr class="hide">
<div><code>   .push(3);</code><details>to end</details></div>
<div><code>   .insert(index, element);</code><details></details></div>
<div><code>   .extend(iterable)</code><details></details></div>
<div class="unstable hide"><code>   .push_all(&[1, 2, 3]);</code><details></details></div>
<div class="unstable hide"><code>   .append(vec![]);</code><details></details></div>
<div><code>   .clone()</code><details>if T:Clone</details></div>
<div><code>   .clone_from()</code><details>if T:Clone</details></div>
<hr><hr class="hide">
<div><code>   .pop()</code><details></details></div>
<div><code>   .remove(index);</code><details>-&gt; el, shifts left</details></div>
<div><code>   .swap_remove(index);</code><details>-&gt; el, fills with last</details></div>
<div><code>   .truncate(i);</code><details>cut until .len() = i</details></div>
<div class="unstable hide"><code>   .drain();</code><details>-&gt; iter that drains</details></div>
<div><code>   .clear();</code><details></details></div>
<div><code>   .retain(|i| -&gt; bool);</code><details>in place</details></div>
<div><code>   .dedup();</code><details>removes duplicates (if T:PartialEq)</details></div>
<div><code>   .sort()</code><details>in place</details></div>
<div><code>   .reverse()</code><details>in place</details></div>
<div><code>   .swap(index1, index2)</code><details></details></div>
<div class="unstable hide"><code>   .map_in_place(|i| ..)</code><details></details></div>
<hr><hr class="hide">
<div><code>   .ends_with(needle)</code><details></details></div>
<div><code>   .starts_with(needle)</code><details></details></div>
<div><code>   .contains(needle)</code><details>-&gt; bool</details></div>
<div><code>   .binary_search(n)</code><details>-&gt; Result&lt;usize, usize&gt;<br>Ok(i): pos, Err(i): pos for insertion</details></div>
<div><code>   .binary_search_by(||->Ordering)</code><details></details></div>
<hr><hr class="hide">
<div><code>   .capacity();</code><details></details></div>
<div><code>   .reserve(100);</code><details>in addition to .len() or more</details></div>
<div><code>   .reserve_exact(100);</code><details>in addition to .len()</details></div>
<div><code>   .shrink_to_fit();</code><details></details></div>
<hr><hr class="hide">
<div><code>   .into_boxed_slice()</code><details>-&gt; Box&lt;T&gt;</details></div>
<div><code>   .as_ref();</code><details>-&gt; &amp;[T] or &amp;Vec&lt;T&gt;</details></div>
<div><code>   .to_vec()</code><details>like clone(), if T:Clone</details></div>
<div class="unstable hide"><code>   .as_slice()</code><details>-&gt; &amp;[T]</details></div>
<div class="unstable hide"><code>   .as_mut_slice()</code><details>-&gt; &amp;mut [T]</details></div>
<div><code>   .into_cow();</code><details>Cow: clone on write</details></div>
<hr><hr class="hide">
<div><code>   .iter<span>_mut</span>();</code><details title="borrows value">-&gt;&<span>mut </span>T, keeps vector</details></div>
<div><code>   .into_iter();</code><details title="transfers ownership">-&gt;T, consumes vector</details></div>
<div><code>   .chunks<span>_mut</span>(cnk_sz)</code><details>-&gt; iter over a non overlapping slice at a time</details></div>
<div><code>   .windows(wnd_sz)</code><details>-&gt; iter over an overlapping slice at a time</details></div>
<hr><hr class="hide">
<div><code>   .split_at<span>_mut</span>(mid)</code><details>-&gt; (p1, p2), [mid] in 2nd part</details></div>
<div><code>   .<span>r</span>split<span>n_mut</span>(<span>n</span>, || -&gt; bool)</code><details>-&gt; iter over <span>mutable</span> subslices,<br> seperated by ||-&gt;true, <span>at most n times</span></details></div>
<div class="unstable hide"><code>   .split_off(at_index)</code><details></details></div>
<hr><hr class="hide">
<div><code>.cmp() .eq() .ne()</code><details>T: PartialEq</details></div>
<div><code>.lt() .le() .gt() .ge()</code><details>if T:PartialOrd</details></div>
<hr><hr class="hide">
<div><code>boxedvec.into_vec()</code><details>-&gt; &amp;Vec&lt;T&gt;</details></div>
<div><code>vecslice.hash_slice(state:Hasher)</code><details></details></div>
<div><code>Vec::from(str|clonable)</code><details></details></div>
<hr><hr class="hide">

<div>Traits: <code>IntoIterator</code>, <code>FromIterator</code>, <code>IntoCow</code>, <code>Debug (if T:Debug)</code>, <code>Default</code>, <code>Drop</code>, <code>Add</code>, <code>Extend</code>, <code>Deref<span>Mut</span></code>, <code>Index<span>Mut</span></code></div>
</section>





<section id="vec" class="green">
<header>Hashmaps / Dicts</header>

<div><code>use std::collections::HashMap;</code></div>
<div><code>let mut foo: HashMap&lt;K,V&gt; = HashMap::new();</code></div>
<div><code>                = HashMap::with_capacity();</code><details>K:Eq, Hash</details></div>
<div><code>foo[key];</code><details></details></div>
<div><code>foo.len()</code><details></details></div>
<div><code>   .contains_key(key)</code><details>-&gt; bool</details></div>
<div><code>   .get<span>_mut</span>(key)</code><details>-&gt; Option</details></div>
<div><code>   .entry(key)</code><details>-&gt; Entry&lt;..&gt;, for insertion or in-place manipulation</details></div>
<div><code>   .insert(key, value);</code><details></details></div>
<div><code>   .extend(iterable)</code><details></details></div>
<div><code>   .remove(key);</code><details>-&gt; el</details></div>
<div><code>   .clear();</code><details></details></div>
<div><code>   .is_empty();</code><details></details></div>
<hr><hr class="hide">
<div><code>   .iter<span>_mut</span>();</code><details> -&gt; iter over (key, value) pairs</details></div>
<div><code>   .keys();</code><details> -&gt; iter over all keys</details></div>
<div><code>   .values();</code><details> -&gt; iter over all values</details></div>
<div class="unstable hide"><code>   .drain();</code><details>-&gt; iter that drains</details></div>
<hr><hr class="hide">
<div><code>   .clone()</code><details>if K and V:Clone</details></div>
<div><code>   .clone_from()</code><details>if K and V:Clone</details></div>
<hr><hr class="hide">
<div><code>   .capacity();</code><details></details></div>
<div><code>   .reserve(100);</code><details>in addition to .len() or more</details></div>
<div><code>   .shrink_to_fit();</code><details></details></div>
<hr><hr class="hide">
<div><code>   .eq(other_hm) .ne(..)</code><details>K:Eq, V: PartialEq</details></div>
<hr><hr class="hide">

<div>Traits: <code>IntoIterator</code>, <code>FromIterator</code>, <code>Debug (if K and V:Debug)</code>, <code>Default</code>, <code>Extend</code>, <code>Index</code></div>
<hr><hr class="hide">
<div>Custom Key: use <code>#[derive(Hash, Eq, PartialEq, Debug)] <br>stuct my_key_struct { ... }</code></div>
</section>




<section class="next_row">
<header>Rust Cheatsheet</header>
<p>Contribute at <a href="http://github.com/phaiax/rust-cheatsheet">github.com/phaiax/rust-cheatsheet</a></p>
<div><a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" /></a>
<details>This work is licensed under a<br> <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-<br>ShareAlike 4.0 International License</a>.</details>
</div>
<div class="clear_right"></div>
</section>

<div class="outerdoc" id="vec.new"><h4 class="method" id="method.new"><code>fn <a class="fnname" href="#method.new">new</a>() -&gt; <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;</code></h4><div class="docblock"><p>Constructs a new, empty <code>Vec&lt;T&gt;</code>.</p>

<p>The vector will not allocate until elements are pushed onto it.</p>

<h1 class="section-header" id="examples-1"><a href="#examples-1">Examples</a></h1>
<span class="rusttest">fn main() {
    #![allow(unused_mut)]
let mut vec: Vec&lt;i32&gt; = Vec::new();
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">i32</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">new</span>();</pre>
</div></div><div class="outerdoc" id="vec.with_capacity"><h4 class="method" id="method.with_capacity"><code>fn <a class="fnname" href="#method.with_capacity">with_capacity</a>(capacity: <a class="primitive" href="../primitive.usize.html">usize</a>) -&gt; <a class="struct" href="../../std/vec/struct.Vec.html" title="std::vec::Vec">Vec</a>&lt;T&gt;</code></h4><div class="docblock"><p>Constructs a new, empty <code>Vec&lt;T&gt;</code> with the specified capacity.</p>

<p>The vector will be able to hold exactly <code>capacity</code> elements without
reallocating. If <code>capacity</code> is 0, the vector will not allocate.</p>

<p>It is important to note that this function does not specify the <em>length</em>
of the returned vector, but only the <em>capacity</em>. (For an explanation of
the difference between length and capacity, see the main <code>Vec&lt;T&gt;</code> docs
above, 'Capacity and reallocation'.)</p>

<h1 class="section-header" id="examples-2"><a href="#examples-2">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut vec = Vec::with_capacity(10);

// The vector contains no items, even though it has capacity for more
assert_eq!(vec.len(), 0);

// These are all done without reallocating...
for i in 0..10 {
    vec.push(i);
}

// ...but this may make the vector reallocate
vec.push(11);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vec</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">with_capacity</span>(<span class="number">10</span>);

<span class="comment">// The vector contains no items, even though it has capacity for more</span>
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">vec</span>.<span class="ident">len</span>(), <span class="number">0</span>);

<span class="comment">// These are all done without reallocating...</span>
<span class="kw">for</span> <span class="ident">i</span> <span class="kw">in</span> <span class="number">0</span>..<span class="number">10</span> {
    <span class="ident">vec</span>.<span class="ident">push</span>(<span class="ident">i</span>);
}

<span class="comment">// ...but this may make the vector reallocate</span>
<span class="ident">vec</span>.<span class="ident">push</span>(<span class="number">11</span>);</pre>
</div></div><div class="outerdoc" id="vec.elementaccess"><div class="docblock" id="vec.elementaccess"><h1 class="section-header" id="indexing"><a href="#indexing">Indexing</a></h1><p>The Vec type allows to access values by index, because it implements the
<code>Index</code> trait. An example will be more explicit:</p><span class="rusttest">fn main() {
    let v = vec!(0, 2, 4, 6);
println!("{}", v[1]); // it will display '2'
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>);
<span class="macro">println</span><span class="macro">!</span>(<span class="string">"{}"</span>, <span class="ident">v</span>[<span class="number">1</span>]); <span class="comment">// it will display '2'</span></pre><p>However be careful: if you try to access an index which isn't in the Vec,
your software will panic! You cannot do this:</p><span class="rusttest">fn main() {
    let v = vec!(0, 2, 4, 6);
println!("{}", v[6]); // it will panic!
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>(<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>);
<span class="macro">println</span><span class="macro">!</span>(<span class="string">"{}"</span>, <span class="ident">v</span>[<span class="number">6</span>]); <span class="comment">// it will panic!</span></pre><p>In conclusion: always check if the index you want to get really exists
before doing it.</p></div></div><div class="outerdoc" id="vec.len"><h4 class="method" id="method.len"><code>fn <a class="fnname" href="#method.len">len</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.usize.html">usize</a></code></h4><div class="docblock"><p>Returns the number of elements in the vector.</p>

<h1 class="section-header" id="examples-19"><a href="#examples-19">Examples</a></h1>
<span class="rusttest">fn main() {
    let a = vec![1, 2, 3];
assert_eq!(a.len(), 3);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">a</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">a</span>.<span class="ident">len</span>(), <span class="number">3</span>);</pre>
</div></div><div class="outerdoc" id="vec.first"><h4 class="method" id="method.first"><code>fn <a class="fnname" href="#method.first">first</a>(&amp;self) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;&amp;T&gt;</code></h4><div class="docblock"><p>Returns the first element of a slice, or <code>None</code> if it is empty.</p>

<h1 class="section-header" id="examples-25"><a href="#examples-25">Examples</a></h1>
<span class="rusttest">fn main() {
    let v = [10, 40, 30];
assert_eq!(Some(&amp;10), v.first());

let w: &amp;[i32] = &amp;[];
assert_eq!(None, w.first());
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">10</span>), <span class="ident">v</span>.<span class="ident">first</span>());

<span class="kw">let</span> <span class="ident">w</span>: <span class="kw-2">&amp;</span>[<span class="ident">i32</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">w</span>.<span class="ident">first</span>());</pre>
</div></div><div class="outerdoc" id="vec.first_mut"><h4 class="method" id="method.first_mut"><code>fn <a class="fnname" href="#method.first_mut">first_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;&amp;mut T&gt;</code></h4><div class="docblock"><p>Returns a mutable pointer to the first element of a slice, or <code>None</code> if it is empty</p>
</div></div><div class="outerdoc" id="vec.last"><h4 class="method" id="method.last"><code>fn <a class="fnname" href="#method.last">last</a>(&amp;self) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;&amp;T&gt;</code></h4><div class="docblock"><p>Returns the last element of a slice, or <code>None</code> if it is empty.</p>

<h1 class="section-header" id="examples-26"><a href="#examples-26">Examples</a></h1>
<span class="rusttest">fn main() {
    let v = [10, 40, 30];
assert_eq!(Some(&amp;30), v.last());

let w: &amp;[i32] = &amp;[];
assert_eq!(None, w.last());
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">30</span>), <span class="ident">v</span>.<span class="ident">last</span>());

<span class="kw">let</span> <span class="ident">w</span>: <span class="kw-2">&amp;</span>[<span class="ident">i32</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">w</span>.<span class="ident">last</span>());</pre>
</div></div><div class="outerdoc" id="vec.last_mut"><h4 class="method" id="method.last_mut"><code>fn <a class="fnname" href="#method.last_mut">last_mut</a>(&amp;mut self) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;&amp;mut T&gt;</code></h4><div class="docblock"><p>Returns a mutable pointer to the last item in the slice.</p>
</div></div><div class="outerdoc" id="vec.get"><h4 class="method" id="method.get"><code>fn <a class="fnname" href="#method.get">get</a>(&amp;self, index: <a class="primitive" href="../primitive.usize.html">usize</a>) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;&amp;T&gt;</code></h4><div class="docblock"><p>Returns the element of a slice at the given index, or <code>None</code> if the
index is out of bounds.</p>

<h1 class="section-header" id="examples-27"><a href="#examples-27">Examples</a></h1>
<span class="rusttest">fn main() {
    let v = [10, 40, 30];
assert_eq!(Some(&amp;40), v.get(1));
assert_eq!(None, v.get(3));
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> [<span class="number">10</span>, <span class="number">40</span>, <span class="number">30</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">40</span>), <span class="ident">v</span>.<span class="ident">get</span>(<span class="number">1</span>));
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="prelude-val">None</span>, <span class="ident">v</span>.<span class="ident">get</span>(<span class="number">3</span>));</pre>
</div></div><div class="outerdoc" id="vec.get_mut"><h4 class="method" id="method.get_mut"><code>fn <a class="fnname" href="#method.get_mut">get_mut</a>(&amp;mut self, index: <a class="primitive" href="../primitive.usize.html">usize</a>) -&gt; <a class="enum" href="../../std/option/enum.Option.html" title="std::option::Option">Option</a>&lt;&amp;mut T&gt;</code></h4><div class="docblock"><p>Returns a mutable reference to the element at the given index,
or <code>None</code> if the index is out of bounds</p>
</div></div><div class="outerdoc" id="vec.is_empty"><h4 class="method" id="method.is_empty"><code>fn <a class="fnname" href="#method.is_empty">is_empty</a>(&amp;self) -&gt; <a class="primitive" href="../primitive.bool.html">bool</a></code></h4><div class="docblock"><p>Returns <code>true</code> if the vector contains no elements.</p>

<h1 class="section-header" id="examples-20"><a href="#examples-20">Examples</a></h1>
<span class="rusttest">fn main() {
    let mut v = Vec::new();
assert!(v.is_empty());

v.push(1);
assert!(!v.is_empty());
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">v</span> <span class="op">=</span> <span class="ident">Vec</span>::<span class="ident">new</span>();
<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">v</span>.<span class="ident">is_empty</span>());

<span class="ident">v</span>.<span class="ident">push</span>(<span class="number">1</span>);
<span class="macro">assert</span><span class="macro">!</span>(<span class="op">!</span><span class="ident">v</span>.<span class="ident">is_empty</span>());</pre>
</div></div><div class="outerdoc" id="vec.initmacro"><div class="docblock" id="vec.initmacro">
<h1 class="fqn"><span class="in-band"><a href="index.html">std</a>::<wbr><a class="macro" href="">vec!</a></span><span class="out-of-band"><span id="render-detail">
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class="inner">−</span>]
                   </a>
               </span></span></h1>
<pre class="rust macro"><span class="macro">macro_rules</span><span class="macro">!</span> <span class="ident">vec</span> {
    ( $ <span class="ident">elem</span> : <span class="ident">expr</span> ; $ <span class="ident">n</span> : <span class="ident">expr</span> ) <span class="op">=&gt;</span> { ... };
    ( $ ( $ <span class="ident">x</span> : <span class="ident">expr</span> ) , <span class="op">*</span> ) <span class="op">=&gt;</span> { ... };
    ( $ ( $ <span class="ident">x</span> : <span class="ident">expr</span> , ) <span class="op">*</span> ) <span class="op">=&gt;</span> { ... };
}</pre>
<div class="docblock"><p>Creates a <code>Vec</code> containing the arguments.</p>

<p><code>vec!</code> allows <code>Vec</code>s to be defined with the same syntax as array expressions.
There are two forms of this macro:</p>

<ul>
<li>Create a <code>Vec</code> containing a given list of elements:</li>
</ul>

<span class="rusttest">fn main() {
    let v = vec![1, 2, 3];
assert_eq!(v[0], 1);
assert_eq!(v[1], 2);
assert_eq!(v[2], 3);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>[<span class="number">0</span>], <span class="number">1</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>[<span class="number">1</span>], <span class="number">2</span>);
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>[<span class="number">2</span>], <span class="number">3</span>);</pre>

<ul>
<li>Create a <code>Vec</code> from a given element and size:</li>
</ul>

<span class="rusttest">fn main() {
    let v = vec![1; 3];
assert_eq!(v, [1, 1, 1]);
}</span><pre class="rust rust-example-rendered"><span class="kw">let</span> <span class="ident">v</span> <span class="op">=</span> <span class="macro">vec</span><span class="macro">!</span>[<span class="number">1</span>; <span class="number">3</span>];
<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">v</span>, [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]);</pre>

<p>Note that unlike array expressions this syntax supports all elements
which implement <code>Clone</code> and the number of elements doesn't have to be
a constant.</p>

<p>This will use <code>clone()</code> to duplicate an expression, so one should be careful
using this with types having a nonstandard <code>Clone</code> implementation. For
example, <code>vec![Rc::new(1); 5]</code> will create a vector of five references
to the same boxed integer value, not five references pointing to independently
boxed integers.</p>
</div></div></div>

<div id="overlay">
    <div id="overlayclose">X</div>
    <div id="overlaycontent"></div>
</div>



<script src="jquery-2.2.3.min.js"></script>
<script type="text/javascript">
$(document).ready(function() {
    $("a[data-doc]").each(function() {
        var a = $(this);
        a.click(function() {
            var doc_id = a.attr("data-doc").replace('.', '\\.');
            var doc = $('div.outerdoc#' + doc_id);
            var overlay = $("#overlay");
            $("#overlaycontent").html(doc.html());
            overlay.show();
        });

    });

    // $("div.docblock").each(function() {
    //     var docblock = $(this);
    //     $(this).prev().click(function() {
    //         var overlay = $("#overlay");
    //         $("#overlaycontent").html(docblock.html());
    //         overlay.show();

    //     });
    //     $(this).prev().css("cursor", "pointer");
    // });
    $("#overlayclose").click(function() {
        $("#overlay").hide();
    });
    $("#overlay").click(function() {
        $("#overlay").hide();
    });
    $("#overlaycontent").click(function(event) {
        event.stopPropagation();
    });
    $("#overlaycontent").addClass("docblock");


});

</script>

</body>
</html>